Cheat Sheet
-----------

Initial project setup
~~~~~~~~~~~~~~~~~~~~~

* Start with a 'User Story' and map it to a first Functional Test

* Pick a test framework -- `unittest` is fine, options like `py.test`
  and `nose` can also offer some attributes

* Run the Functional Test and see your first 'expected failure'

* Pick a web framework such as Django, and find out how to run
  'unit tests' against it.

* Create your first 'unit test' to address the current FT failure,,
  and see it fail.

* Consider doing your 'first commit' to a VCS like 'Git'.

Relevant chapters: 1, 2, 3


The TDD workflow
----------------

* Double-loop TDD

* Red, Green, Refactor

* Trianglulation

* The scratchpad

* "3 Strikes and Refactor"

* "Working State to Working State"

* "YAGNI"

Chapters 5, 6


[[Double-Loop-TDD-diagram]]
.The TDD process with Functional and Unit tests
image::images/twdp_0404.png[A flowchart showing functional tests as the overall cycle, and unit tests helping to code]



Moving beyond dev-only testing
------------------------------

* Start system testing early

* Ensure your components work together: web server, static content, database

* Build a staging environment to match your production environment

* Run your FT suite against staging

* Automate your staging and production environments:
    * PaaS vs VPS
    * Fabric
    * Configuration management (Chef, Puppett, Salt, Ansible...)
    * Vagrant

* Think through deployment pain points


Testing best practices
-----------------------

* Each test should test one thing
* One tests file per application code source file
* Thin views
* Consider a placeholder test for every function and class
* "Don't test constants"
* Try to test behaviour rather than implementation
* Testing templates: consider testing any ifs or fors -- using
  your FTs for this may be fine, but some lower-level tests may
  give you faster feedback
* Testing input validation -- test error cases thoroughly.


Set up CI as soon as possible for your project::
    As soon as your functional tests take more than a few seconds to run,
    you'll find yourself avoiding running them all. Give this job to a CI
    server, to make sure that all your tests are getting run somewhere.

Set up screenshots and HTML dumps for failures::
    Debugging test failures is easier if you can see what the page looked
    at when the failure occurs.  This is particularly useful for debugging
    CI failures, but it's also very useful for tests that you run locally.

Use waits in Selenium tests::
    Selenium's `implicitly_wait` only applies to uses of its `find_element` 
    functions, and even that can be unreliable (it can find an element that's
    still on the old page).  Build a `wait_for` helper function, and alternate
    between actions on the site, and then some sort of wait to see that they've
    taken effect.

Look in to hooking up CI and staging::
    Tests against that use LiveServerTestCase are all very well for dev boxes,
    but the true reassurance comes from running your tests against a real 
    server.  Look into getting your CI server to deploy to your stagin server,
    and run the functional tests against that instead.  It has the side benefit
    of testing your automated deploy scripts.

*******************************************************************************


JavaScript
----------

* Selenium gives you the ability to test your client-side JavaScript and your
  server-side Python together, at the Functional Test level

* But it's also possible to use unit tests for Javascript

* The JavaScript testing world is not yet mature, so there are lots of choices.
  Qunit and Sinon.js worked OK for me, but you may want to investigate others,
  particularly if you want to use an MVC framework like Angular, Ember,
  Backbone et al.


* Don't forget to read <<jsgoodparts,JavaScript: The Good Parts>>.

See chapter 13


Spiking
-------

* TDD isn't always the best way to code.  It's often the best way to write your
  final application code, but you can use other approaches for exploratory
  coding, for learning a new API, or for proof-of-concept prototypes.

* De-spiking means throwing away the prototype, and building the "real" version
  with rigorous TDD

See chapter 15


Outside-in, Test Isolation, Mocking and third-party dependencies
-----------------------------------------------------------------

see chaps 16-19

Outside-in TDD::
    A methodology for building code, driven by tests, which proceeds by
    starting from the "outside" layers (presentation, GUI), and moving
    "inwards" step-by-step, via view/controller layers, down towards 
    the model layer.  The idea is to drive the design of your code from
    the use to which it is going to be put, rather than trying to anticipate
    requirements from the ground up.

Programming by wishful thinking::
    The outside-in process is sometimes called "programming by wishful
    thinking".  Actually, any kind of TDD involves some wishful thinking. 
    We're always writing tests for things that don't exist yet.


On the relative merits of different types of test

Functional tests::
    * Provide the best guarantee that your application really works correctly,
    from the point of view of the user.
    * But: it's a slower feedback cycle,
    * And they don't necessarily help you write clean code.

Integrated tests (reliant on, eg, the ORM or the Django Test Client)::
    * Are quick to write,
    * Easy to understand,
    * Will warn you of any integration issues,
    * But may not always drive good design (that's up to you!).
    * And are usually slower than isolated tests

Isolated ("mocky") tests::
    * These involve the most hard work.
    * They can be harder to read and understand,
    * But: these are the best ones for guiding you towards better design.
    * And they run the fastest.

Decoupling our application from ORM code::
    When striving to write isolated tests, one of the consequences is that we
    find ourselves forced to remove ORM code from places like views and forms,
    by hiding it behind helper functions or methods.  This can be beneficial in
    terms of decoupling your application from the ORM, but also just because it
    makes your code more readable. As with all things, it's a judgement call as
    to whether the additional effort is worth it in particular circumstances.



[cols="1,5asciidoc",options="header"]
|================

|Objective|Some considerations

|'Correctness'|
* Do I have enough functional tests to reassure myself that my application
  'really' works, from the point of view of the user?
* Am I testing all the edge cases thoroughly?  This feels like a job for 
  low-level, isolated tests.
* Do I have tests that check whether all my components fit together properly?
  Could some integrated tests do this, or are functional tests enough?

|'Clean, maintainable code'|
* Are my tests giving me the confidence to refactor my code, fearlessly and
  frequently?
* Are my tests helping me to drive out a good design?  If I have a lot of
  integrated tests and few isolated tests, are there any parts of my application
  where putting in the effort to write more isolated tests would give me better
  feedback about my design?

|'Productive workflow'|
* Are my feedback cycles as fast as I would like them?  When do I get warned
  about bugs, and is there any practical way to make that happen sooner?
* If I have a lot of high-level, functional tests, that take a long time to
  run, and I have to wait overnight to get feedback about accidental
  regressions, is there some way I could write some faster tests, integrated
  tests perhaps, that would get me feedback quicker?  
* Can I run a subset of the full test suite when I need to?
* Am I spending too much time waiting for tests to run, and thus less time
  in a productive flow state?

|================

== chapter_21 

.The Page pattern, and the real exercise for the reader
*******************************************************************************

Apply DRY to your functional tests::
    Once your FT suite starts to grow, you'll find that different tests will
    inevitably find themselves using similar parts of the UI. Try to avoid 
    having constants, like the HTML IDs or classes of particular UI elements
    duplicated between your FTs.

The Page pattern::
    Moving helper methods into a base `FunctionalTest` class can become 
    unwieldy.  Consider using individual Page objects to hold all the
    logic for dealing with particular parts of your site. 

An exercise for the reader::
    I hope you've actually tried this out!  Try to follow the "Outside-In"
    method, and occasionally try things out manually if you get stuck. 
    The real exercise for the reader, of course, is to apply TDD to your
    next project.  I hope you'll enjoy it!

*******************************************************************************

