Testing deployment using a staging site
---------------------------------------

It's time to deploy the first version of our site and make it public.  They say
that if you wait until you feel ready to ship, then you've waited too long.

Is our site usable?  Is it better than nothing? Can make lists on it? Yes, yes,
yes.

No, you can't log in yet.  No you can't mark tasks as completed.  But do we
really need any of that stuff? Not really -- and you can never be sure what
your users are 'actually' going to do with your site once they get their 
hands on it. We think our users want to use the site for to-do lists, but maybe
they actually want to use it to make "top 10 best fly-fishing spots" lists, for
which you don't need any kind of ``mark completed'' function. We won't know
until we put it out there.

In this chapter I'm going to go through and actually deploy my site to a real,
live web server.  You might be tempted to skip this bit, but I strongly 
encourage you to actually go through and do this too.  It's only by doing
these things that we learn all the little gotchas.  Give it a buzzword
name like "DevOps" if that's what it takes to convince you it's worth
learning.


TDD and the Danger Areas of deployment
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Deploying a site to a live web server can be a tricky topic.  Oft heard is the
forlorn cry -- '``but it works on my machine'''.

Some of the danger areas of deployment include:

- 'static files' (CSS, JavaScript, images etc): web servers usually need
  special configuration for serving these
- the 'database': there can be permissions and path issues, and we need to be
  careful about preserving data between deploys
- 'dependencies': we need to make sure that the packages our software relies
  on are installed on the server, and have the correct versions

But there are solutions to all of these.  In order:

- Using a 'staging site', on the same infrastructure as the production site,
  can help us test out our deployments and get things right before we go to the
  "real" site
- We can also 'run our functional tests against the staging site'. Since we
  now have a "smoke test" for our site layout, we'll know that the CSS is 
  loaded correctly.
- We can write a special 'test that checks the deploy process',
  for example making sure database data is preserved (later, we can talk about
  South + data migrations...)
- 'Virtualenvs' are a useful tool for managing packages and dependencies on a
  server that's not entirely under your own control
- And finally, automation, automation, automation.  By using an 'automated
  script' to deploy new versions, and by using the same script to deploy to
  staging and production, we can reassure ourselves that staging is as much
  like live as possible.


As always, start with a test
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's adapt our functional tests slightly so that it can be run against
a staging site. We'll do it by slightly hacking an argument that is normally
used to change the address which the test's temporary server gets run on:

[role="sourcecode"]
.lists/tests.py
[source,python]
----
class NewVisitorTest(LiveServerTestCase):

    @classmethod
    def setUpClass(cls):
        for arg in sys.argv:
            if 'liveserver' in arg:
                cls.server_url = 'http://' + arg.split('=')[1]
                return
        LiveServerTestCase.setUpClass()
        cls.server_url = cls.live_server_url

    @classmethod
    def tearDownClass(cls):
        if cls.server_url == cls.live_server_url:
            LiveServerTestCase.tearDownClass()


    def setUp(self):
        [...]
----

OK, when I said slightly hacking, I meant seriously hacking. Do you remember I
said that `LiveServerTestCase` had certain limitations?  Well, one is that it
always assumes you want to use its own test server.  I still want to be able to
do that sometimes, but I also want to be able to selectively tell it not to
bother, and to use a real server instead.  

`setUpClass` is a similar method to `setUp`, also provided by `unittest`, which
is used to do test setup for the whole class. This is where `LiveServerTest`
usually starts up its test server.  We look for the 'liveserver' command-line
argument (which are found in `sys.argv`, and if we find it, we tell our test
class to skip the normal `setUpClass`, and just store away our staging server
URL in a variable called `server_url` instead.

This means we also need to change the three places we used to use
`self.live_server_url`:

[role="sourcecode"]
.lists/tests.py
[source,python]
----
    def test_can_start_a_list_and_retrieve_it_later(self):
        # Edith has heard about a cool new online to-do app. She goes
        # to check out its homepage
        self.browser.get(self.server_url)
        [...]
        # Francis visits the home page.  There is no sign of Edith's
        # list
        self.browser.get(self.server_url)
        [...]

    def test_layout_and_styling(self):
        # Edith goes to the home page
        self.browser.get(self.server_url)
----

We test that our little hack hasn't broken anything by running the functional
tests "normally":

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test functional_tests*] 
[...]
Ran 2 tests in 8.544s

OK
----

And now we can try them against our staging server URL.  I'm hosting my staging
server at 'book-example-staging.obeythetestinggoat.com':


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test functional_tests --liveserver=book-example-staging.obeythetestinggoat.com*]
$ python manage.py test functional_tests 
Creating test database for alias 'default'...
FF
======================================================================
FAIL: test_can_start_a_list_and_retrieve_it_later (functional_tests.tests.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/harry/Dropbox/book/source/chapter_7/superlists/functional_tests/tests.py", line 44, in test_can_start_a_list_and_retrieve_it_later
    self.assertIn('To-Do', self.browser.title)
AssertionError: 'To-Do' not found in u'Domain name registration | Domain names | Web Hosting | 123-reg'

======================================================================
FAIL: test_layout_and_styling (functional_tests.tests.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/harry/Dropbox/book/source/chapter_7/superlists/functional_tests/tests.py", line 118, in test_layout_and_styling
    delta=3
AssertionError: 0 != 470 within 3 delta

 ---------------------------------------------------------------------
Ran 2 tests in 16.480s

FAILED (failures=2)
Destroying test database for alias 'default'...
----

You can see that both tests are failing, as expected, since I haven't actually
set up my staging site yet. In fact, you can see from the first traceback that
the test is actually ending up on the home page of my domain registrar.


NOTE: We're going to need a couple of domain names at this point in the book -
they can both be subdomains of a single domain.  I'm going to use
'book-example.obeythetestinggoat.comm' and
'book-example-staging.obeythetestinggoat.com'.
If you don't already own a domain, this is the time to register one! Again,
this is something I really want you to 'actually' do.  If you've never
registered a domain before, just pick any old registrar and buy a cheap one
- it should only cost you $5! And I promise seeing your site on a "real"
web site will be a thrill :-)

TODO: commit


Manually provisioning a server to host our site
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We can separate out "deployment" into two tasks:
- 'provisioning' a new server to be able to host the code
- 'deploying' a new version of the code to an existing server.

Some people like to use a brand new server for every deployment -- it's what we
do at PythonAnywhere.  I think it's probably only necessary for larger, more 
complex sites though, or major changes to an existing site.

For a simple site like ours, it makes sense to separate the two tasks.  And, 
although we eventually want both to be completely automated, we can probably
live with a manual provisioning system for now.


Choosing where to host our site
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

There are loads of different solutions out there these days, but they broadly
fall into two camps:

- running your own (possibly virtual) server
- using a Platform-As-A-Service (PaaS) offering like Heroku, DotCloud or PythonAnywhere

Particularly for small sites, a PaaS offers a lot of advantages, and I would
definitely recommend looking into them.  We're not going to use a PaaS in this
book however, for several reasons..  Firstly, I have a conflict of interest, in
that I obviously think PythonAnywhere is the best, but then again I would say
that.  Secondly, all the PaaS offerings are quite different, and the procedures
to deploy to each vary a lot -- learning about one doesn't tell you about the 
others... And any one of them might change their process radically, or simply
go out of business by the time you get to read this book.

Instead, we'll learn just a tiny bit of good old-fashioned server admin,
including SSH and Apache.  They're unlikely to ever go away, and knowing a bit
about them will get you some respect from all the grizzled dinosaurs out there.

Spinning up a server
^^^^^^^^^^^^^^^^^^^^

I'm not going to dictate how you do this -- whether you choose Amazon AWS,
Rackspace, Digital Ocean, your own server in your own data centre or a
Raspberry Pi in a cupboard behind the stairs, I'm going to assume you've
managed to start up a server with some flavor of Linux on it, that it's on the
Internet, and that you can SSH into it.  I'd recommend Ubuntu as a distro,
because it has Python 2.7, and it has some specific ways of configuring 
Apache which I'm going to make use of below.  If you know what you're doing,
you can probably get away with using something else.


Installing Nginx
^^^^^^^^^^^^^^^^

We'll need a web server, and all the cool kids are using Nginx these days,
so let's use that.  Having fought with Apache for many years, I can tell
you it's a blessed relief in terms of the readability of its config files,
if nothing else!


////
TODO: switch to Arch?
////

Installing Nginx on my server was a matter of doing an `apt-get`, and I could
then see the default Nginx "Hello World" screen:

    apt-get install nginx

.Nginx - It works!
image::images/nginx_it_works.png[The default "Welcome to nginx!" page]


And in fact we can re-run our functional tests and see that their failure
messages have changed slightly

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test functional_tests --liveserver=book-example-staging.obeythetestinggoat.com*]
[...]
NoSuchElementException: Message: u'Unable to locate element: {"method":"tag
name","selector":"input"}' ; Stacktrace: [...]
[...]
AssertionError: 'To-Do' not found in u'Welcome to nginx!'
----

Progress!


Configuring domains for staging and live
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Next, we don't want to be messing about with IP addresses all the time, so we
should point our staging and live domains to the server. At my registrar, the
control screens looked a bit like this -- pointing a domain at a specific IP
address is called an "A-Record" in the DNS system.  All registrars are slightly
different, but a bit of clicking around should get you to yours...

.Domain setup
image::images/domain_setup.png[Registrar control screens for two domains]

To check this works, you can visit each domain in turn and check that you now
see the Nginx "welcome" page.

The final step is to get a copy of the staging site up and running, just
to check whether we can get Nginx and Django to talk to each other.

We then make a directory for the source to live in.  Let's assume we have
a home folder at '/home/harry' (this is likely to be the case on any
shared hosting system). I'm going to set up my sites like this:

----
/home/harry
├── sites
│   ├── www.live.my-website.com
│   │    ├── database
│   │    │     └── database.sqlite
│   │    ├── source
│   │    │    ├── manage.py
│   │    │    ├── superlists
│   │    │    ├── etc...
│   │    │    
│   │    ├── static
│   │    │    ├── base.css 
│   │    │    ├── etc...
│   │    │    
│   │    └── virtualenv
│   │         ├── lib
│   │         ├── etc...
│   │         
│   ├── www.staging.my-website.com
│   │    ├── database
│   │    ├── etc...
----
 
Each site (staging, live, or any other website) has its own folder. Within that
we have a separate folder for the source code, the database, and the static
files.  The logic is that, while the source code might change from one version
of the site to the next, the database will stay the same.  The static folder
is in the same relative location, '../static', that we set up at the end of
the last chapter. Finally, the virtualenv gets its own subfolder too.  What's a
virtualenv, I hear you ask? We'll find out shortly.

First let's change the location of our database in 'settings.py', and make sure
we can get that working on our local PC.  I often end up defining a variable
called `PROJECT_ROOT` in 'settings.py' sooner or later:

[role="sourcecode"]
.lists/tests.py
[source,python]
----

PROJECT_ROOT = path.join(path.dirname(__file__), '..')

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': path.abspath(path.join(PROJECT_ROOT, '../database/database.sqlite')),
        'USER': '',                      # Not used with sqlite3.
[...]

# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = path.abspath(path.join(PROJECT_ROOT, '../static'))
----

Now let's try it locally:

[subs="specialcharacters,quotes"]
----
$ *mkdir ../database*
$ *python manage.py syncdb*
Creating tables ...
[...]
$ ls ../database/
database.sqlite
----

That seems to work.

TODO: commit

To get our code onto the server, we'll use git and go via one of the code
sharing sites.  If you haven't already, push your code up to GitHub, BitBucket
or similar.  They all have excellent instructions for beginners on how to
do that.  We'll need to make sure Git is installed on the server:

    apt-get install git

Here's some bash commands that will set this all up. If you're not familiar
with it, note the `export` command which lets me set up a "local variable"
in bash:

    export SITENAME=book-example-staging.obeythetestinggoat.com
    mkdir -p /home/harry/sites/$SITENAME
    mkdir /home/harry/sites/$SITENAME/database
    mkdir /home/harry/sites/$SITENAME/static
    mkdir /home/harry/sites/$SITENAME/virtualenv
    cd ~/sites/$SITENAME
    # you should replace the next line with the URL to your own repo
    git clone https://github.com/hjwp/book-example.git source

Now we've got the site installed, let's just try running the dev server -- this
is a smoke test, to see if all the moving parts are connected:

    $ python manage.py runserver
    Traceback (most recent call last):
      File "manage.py", line 8, in <module>
        from django.core.management import execute_from_command_line
    ImportError: No module named django.core.management

Ah. Django isn't installed on the server.  We could install it at this point,
but that would leave us with a problem:  if we ever wanted to upgrade Django
when a new version comes out, it would be impossible to test the staging site
with a different version from live.  Similarly, if there are other users on 
the server, we'd all be forced to use the same version of Django.

The solution is a "virtualenv" -- a neat way of having different versions of
python packages installed in different places, in their own "virtual
environments".

Let's try it out on own PC first:

[subs="specialcharacters,quotes"]
----
$ *pip install virtualenv*
----

Let's get a virtualenv setup on our own PC first, as an experiment.  We'll 
follow the same folder structure as we're planning for the server:

[subs="specialcharacters,quotes"]
----
$ *virtualenv ../virtualenv*
$ *source ../virtualenv/bin/activate*
(virtualenv)$ python manage.py test lists
# will show ImportError: No module named django
# because Django isn't installed inside the virtualenv
(virtualenv)$ *pip install django*
[...]
Successfully installed django
Cleaning up...
(virtualenv)$ python manage.py test lists
[...]
OK
----

To "save" the list of packages we need in our virtualenv, and be able to 
re-create it later, we create a 'requirements.txt' file, using `pip freeze`,
and add that to our repository:

[subs="specialcharacters,quotes"]
----
(virtualenv)$ *pip freeze > requirements.txt*
(virtualenv)$ *git add requirements.txt*
(virtualenv)$ *git commit -m"Add requirements.txt for virtualenv"*
----

Next we do a `git push` to send our updates up to our code-sharing site

[subs="specialcharacters,quotes"]
----
(virtualenv)$ *git push* 
----

And we can pull those changes down to the server

    $ git pull
    $ sudo pip install virtualenv
    $ virtualenv ../virtualenv/
    (virtualenv)$ source ../virtualenv/bin/activate
    (virtualenv)$ pip install -r requirements.txt 
    Downloading/unpacking Django==1.5.1 (from -r requirements.txt (line 1))
    [...]
    (virtualenv)$ python manage.py runserver
    Validating models...
    0 errors found
    [...]

That looks like it worked.  Let's now go and edit our nginx config to 
tell it to send requests for our staging site along to Django. A minimal
config looks like this:


[role="sourcecode"]
.lists/tests.py
[source,conf]
----
server {
    listen 80;
    server_name book-example-staging.obeythetestinggoat.com;

    location /static {
        alias /home/harry/sites/$server_name/static;
    }

    location / {
        proxy_pass http://localhost:8000;
    }
}
----

I saved this to a file called 'nginx-staging.conf' inside 'superlists', 
and then added it to the enabled sites for the server by creating
a symlink to it:

   ln -s /home/harry/sites/$SITENAME/source/superlists/nginx-staging.conf /etc/nginx/sites-enabled/$SITENAME

NOTE: I also had to edit '/etc/nginx/nginx.conf' and uncomment a line saying
`server_names_hash_bucket_size 64;` to get my long domain name to work...

And now to test it:

    service nginx reload
    python manage.py runserver

That gets us as far as seeing the site, but static files aren't working:

.Staging site is up!
image::images/staging_is_up.png[Our staging version is live... but looks ugly again]

NOTE: The live domain should still show "Welcome to nginx". It's worth checking
this, to be sure that the configuration for live and staging are properly
separate.

Let's see what our functional tests say:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test functional_tests --liveserver=book-example-staging.obeythetestinggoat.com*]
[...]
NoSuchElementException: Message: u'Unable to locate element:
{"method":"id","selector":"id_list_table"}' ; [...]
[...]
AssertionError: 125 != 497 within 3 delta
FAILED (failures=1, errors=1)
----

The tests are telling us that our CSS isn't working, and are also failing
as soon as they try and submit a new item, because we haven't set up the 
database. Let's do those two things now


Configuring static files and the database
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


From this point we start to move from the "provisioning" area into the
"deployment" area -- one way of telling the difference is that you tend to 
need root permissions for the former, but we don't for the latter.

We run a `collectstatic` and a `syncdb` to set up static files and the
database. The `--noinput` suppresses the two little "are you sure" prompts:

----
(virtualenv)$ python manage.py collectstatic --noinput
(virtualenv)$ python manage.py syncdb --noinput
(virtualenv)$ ls ../static/
base.css  bootstrap
(virtualenv)$ ls ../database/
database.sqlite
(virtualenv)$ python manage.py runserver
----

Now if you have a look at the site, things are looking much healthier. We
can re-run our FTs:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test functional_tests --liveserver=book-example-staging.obeythetestinggoat.com*]
Creating test database for alias 'default'...
..
 ---------------------------------------------------------------------
Ran 2 tests in 10.718s

OK
----

Hooray!

