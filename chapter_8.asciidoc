Testing deployment using a staging site
---------------------------------------

WARNING: This chapter is still in draft format.  It may contain errors, and
may yet change substantially. See the end for my list of todos, and do send in
any suggestions.  If you've come to this without having read the rest of the 
book, you can find the code at
https://github.com/hjwp/book-example/tree/chapter_7 

It's time to deploy the first version of our site and make it public.  They say
that if you wait until you feel ready to ship, then you've waited too long.

Is our site usable?  Is it better than nothing? Can make lists on it? Yes, yes,
yes.

No, you can't log in yet.  No you can't mark tasks as completed.  But do we
really need any of that stuff? Not really -- and you can never be sure what
your users are 'actually' going to do with your site once they get their 
hands on it. We think our users want to use the site for to-do lists, but maybe
they actually want to use it to make "top 10 best fly-fishing spots" lists, for
which you don't need any kind of ``mark completed'' function. We won't know
until we put it out there.

In this chapter I'm going to go through and actually deploy my site to a real,
live web server.  You might be tempted to skip this bit, but I strongly 
encourage you to actually go through and do this too.  It's only by doing
these things that we learn all the little gotchas.  Give it a buzzword
name like "DevOps" if that's what it takes to convince you it's worth
learning.


TDD and the Danger Areas of deployment
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Deploying a site to a live web server can be a tricky topic.  Oft-heard is the
forlorn cry -- '``but it works on my machine'''.

Some of the danger areas of deployment include:

- 'Static files' (CSS, JavaScript, images etc): web servers usually need
  special configuration for serving these
- The 'Database': there can be permissions and path issues, and we need to be
  careful about preserving data between deploys
- 'Dependencies': we need to make sure that the packages our software relies
  on are installed on the server, and have the correct versions

[quote, 'https://twitter.com/DEVOPS_BORAT/status/192271992253190144[Devops Borat]']
______________________________________________________________
Is all fun and game until you are need of put it in production.
______________________________________________________________


But there are solutions to all of these.  In order:

- Using a 'staging site', on the same infrastructure as the production site,
  can help us test out our deployments and get things right before we go to the
  "real" site
- We can also 'run our functional tests against the staging site'. That will
  reassure us that we have the right code and packages on the server, and
  since we now have a "smoke test" for our site layout, we'll know that the CSS
  is loaded correctly.
- 'Virtualenvs' are a useful tool for managing packages and dependencies on a
  server that's not entirely under your own control
- And finally, 'automation, automation, automation'.  By using an automated
  script to deploy new versions, and by using the same script to deploy to
  staging and production, we can reassure ourselves that staging is as much
  like live as possible.


As always, start with a test
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's adapt our functional tests slightly so that it can be run against
a staging site. We'll do it by slightly hacking an argument that is normally
used to change the address which the test's temporary server gets run on:

[role="sourcecode"]
.lists/tests.py
[source,python]
----
class NewVisitorTest(LiveServerTestCase):

    @classmethod
    def setUpClass(cls):
        for arg in sys.argv:
            if 'liveserver' in arg:
                cls.server_url = 'http://' + arg.split('=')[1]
                return
        LiveServerTestCase.setUpClass()
        cls.server_url = cls.live_server_url

    @classmethod
    def tearDownClass(cls):
        if cls.server_url == cls.live_server_url:
            LiveServerTestCase.tearDownClass()


    def setUp(self):
        [...]
----

OK, when I said slightly hacking, I meant seriously hacking. Do you remember I
said that `LiveServerTestCase` had certain limitations?  Well, one is that it
always assumes you want to use its own test server.  I still want to be able to
do that sometimes, but I also want to be able to selectively tell it not to
bother, and to use a real server instead.  

`setUpClass` is a similar method to `setUp`, also provided by `unittest`, which
is used to do test setup for the whole class. This is where `LiveServerTest`
usually starts up its test server.  We look for the 'liveserver' command-line
argument (which are found in `sys.argv`, and if we find it, we tell our test
class to skip the normal `setUpClass`, and just store away our staging server
URL in a variable called `server_url` instead.

This means we also need to change the three places we used to use
`self.live_server_url`:

[role="sourcecode"]
.lists/tests.py
[source,python]
----
    def test_can_start_a_list_and_retrieve_it_later(self):
        # Edith has heard about a cool new online to-do app. She goes
        # to check out its homepage
        self.browser.get(self.server_url)
        [...]
        # Francis visits the home page.  There is no sign of Edith's
        # list
        self.browser.get(self.server_url)
        [...]

    def test_layout_and_styling(self):
        # Edith goes to the home page
        self.browser.get(self.server_url)
----

We test that our little hack hasn't broken anything by running the functional
tests "normally":

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test functional_tests*] 
[...]
Ran 2 tests in 8.544s

OK
----

And now we can try them against our staging server URL.  I'm hosting my staging
server at 'book-example-staging.obeythetestinggoat.com':


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test functional_tests --liveserver=book-example-staging.obeythetestinggoat.com*]
Creating test database for alias 'default'...
FF
======================================================================
FAIL: test_can_start_a_list_and_retrieve_it_later (functional_tests.tests.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/harry/Dropbox/book/source/chapter_7/superlists/functional_tests/tests.py", line 44, in test_can_start_a_list_and_retrieve_it_later
    self.assertIn('To-Do', self.browser.title)
AssertionError: 'To-Do' not found in u'Domain name registration | Domain names | Web Hosting | 123-reg'

======================================================================
FAIL: test_layout_and_styling (functional_tests.tests.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/harry/Dropbox/book/source/chapter_7/superlists/functional_tests/tests.py", line 118, in test_layout_and_styling
    delta=3
AssertionError: 0 != 470 within 3 delta

 ---------------------------------------------------------------------
Ran 2 tests in 16.480s

FAILED (failures=2)
Destroying test database for alias 'default'...
----

You can see that both tests are failing, as expected, since I haven't
actually set up my staging site yet. In fact, you can see from the
first traceback that the test is actually ending up on the home page of
my domain registrar.

The FT seems to be testing the right things though, so let's commit.

[subs="specialcharacters,quotes"]
----
$ *git diff* # should show to functional_tests.py
$ *git commit -am"Hack FT runner to be able to test staging"*
----

NOTE: We're going to need a couple of domain names at this point in the book -
they can both be subdomains of a single domain.  I'm going to use
'book-example.obeythetestinggoat.comm' and
'book-example-staging.obeythetestinggoat.com'.
If you don't already own a domain, this is the time to register one! Again,
this is something I really want you to 'actually' do.  If you've never
registered a domain before, just pick any old registrar and buy a cheap one
-- it should only cost you $5! And I promise seeing your site on a "real"
web site will be a thrill :-)


Manually provisioning a server to host our site
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We can separate out "deployment" into two tasks:

- 'provisioning' a new server to be able to host the code
- 'deploying' a new version of the code to an existing server.

Some people like to use a brand new server for every deployment -- it's what we
do at PythonAnywhere.  That's only necessary for larger, more complex sites
though, or major changes to an existing site. For a simple site like ours, it
makes sense to separate the two tasks.  And, although we eventually want both
to be completely automated, we can probably live with a manual provisioning
system for now.

As you go through this chapter, you should be aware that provisioning is
something that varies a lot, and that as a result there are few universal
best practices for deployment.  So, rather than trying to remember the 
specifics of what I'm doing here, you should be trying to understand the
rationale, so that you can apply the same kind of thinking in the
specific future circumstances you encounter.


Choosing where to host our site
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

There are loads of different solutions out there these days, but they broadly
fall into two camps:

- running your own (possibly virtual) server
- using a Platform-As-A-Service (PaaS) offering like Heroku, DotCloud or PythonAnywhere

Particularly for small sites, a PaaS offers a lot of advantages, and I would
definitely recommend looking into them.  We're not going to use a PaaS in this
book however, for several reasons..  Firstly, I have a conflict of interest, in
that I obviously think PythonAnywhere is the best, but then again I would say
that.  Secondly, all the PaaS offerings are quite different, and the procedures
to deploy to each vary a lot -- learning about one doesn't necessarily tell you
about the others... And any one of them might change their process radically,
or simply go out of business by the time you get to read this book.

Instead, we'll learn just a tiny bit of good old-fashioned server admin,
including SSH and web server config.  They're unlikely to ever go away, and
knowing a bit about them will get you some respect from all the grizzled
dinosaurs out there.

What I have done is to try and set up a server in such a way that it's a lot
like the environment you get from a PaaS, so you should be able to apply from
of the lessons we learn in the deployment section, no matter what provisioning
solution you choose.


Spinning up a server
^^^^^^^^^^^^^^^^^^^^

I'm not going to dictate how you do this -- whether you choose Amazon AWS,
Rackspace, Digital Ocean, your own server in your own data centre or a
Raspberry Pi in a cupboard behind the stairs, I'm going to assume you've
managed to start up a server with some flavor of Linux on it, that it's on the
Internet, and that you can SSH into it.  I'd recommend Ubuntu as a distro,
because it has Python 2.7, and it has some specific ways of configuring 
Nginx which I'm going to make use of below.  If you know what you're doing,
you can probably get away with using something else.


Installing Nginx
^^^^^^^^^^^^^^^^

We'll need a web server, and all the cool kids are using Nginx these days,
so let's use that.  Having fought with Apache for many years, I can tell
you it's a blessed relief in terms of the readability of its config files,
if nothing else!

Installing Nginx on my server was a matter of doing an `apt-get`, and I could
then see the default Nginx "Hello World" screen:

    apt-get install nginx

.Nginx - It works!
image::images/nginx_it_worked.png[The default "Welcome to nginx!" page]


While we've got root access, let's make sure the server has the three other
pieces of software we need at the system level: Git, pip and virtualenv

    apt-get install git
    apt-get install python-pip
    pip install virtualenv


Configuring domains for staging and live
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Next, we don't want to be messing about with IP addresses all the time, so we
should point our staging and live domains to the server. At my registrar, the
control screens looked a bit like this:

.Domain setup
image::images/domain_setup.png[Registrar control screens for two domains]

In the DNS system, pointing a domain at a specific IP address is called an
"A-Record".  All registrars are slightly different, but a bit of clicking around
should get you to the right screen in yours...

To check this works, we can re-run our functional tests and see that their
failure messages have changed slightly

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test functional_tests --liveserver=book-example-staging.obeythetestinggoat.com*]
[...]
NoSuchElementException: Message: u'Unable to locate element: {"method":"tag
name","selector":"input"}' ; Stacktrace: [...]
[...]
AssertionError: 'To-Do' not found in u'Welcome to nginx!'
----

Progress!  


Deploying our code manually
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The next step is to get a copy of the staging site up and running, just
to check whether we can get Nginx and Django to talk to each other.  As
we do so, we're starting to do some of what you'd call "deployment", as
well as provisioning, so we should be thinking about how we can automate the
process, as we go.

NOTE: One way of telling the difference between provisioning and deployment is
that you tend to need root permissions for the former, but we don't for the
latter.

We need a directory for the source to live in.  Let's assume we have a home
folder at '/home/harry' (this is likely to be the case on any shared hosting
system). I'm going to set up my sites like this:

----
/home/harry
├── sites
│   ├── www.live.my-website.com
│   │    ├── database
│   │    │     └── database.sqlite
│   │    ├── source
│   │    │    ├── manage.py
│   │    │    ├── superlists
│   │    │    ├── etc...
│   │    │    
│   │    ├── static
│   │    │    ├── base.css 
│   │    │    ├── etc...
│   │    │    
│   │    └── virtualenv
│   │         ├── lib
│   │         ├── etc...
│   │         
│   ├── www.staging.my-website.com
│   │    ├── database
│   │    ├── etc...
----
 
Each site (staging, live, or any other website) has its own folder. Within that
we have a separate folder for the source code, the database, and the static
files.  The logic is that, while the source code might change from one version
of the site to the next, the database will stay the same.  The static folder
is in the same relative location, '../static', that we set up at the end of
the last chapter. Finally, the virtualenv gets its own subfolder too.  What's a
virtualenv, I hear you ask? We'll find out shortly.


Adjusting the database location
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

First let's change the location of our database in 'settings.py', and make sure
we can get that working on our local PC.  I often end up defining a variable
called `PROJECT_ROOT` in 'settings.py' sooner or later:

[role="sourcecode"]
.lists/tests.py
[source,python]
----

PROJECT_ROOT = path.join(path.dirname(__file__), '..')

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': path.abspath(path.join(PROJECT_ROOT, '../database/database.sqlite')),
        'USER': '',                      # Not used with sqlite3.
[...]

# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = path.abspath(path.join(PROJECT_ROOT, '../static'))
----

Now let's try it locally:

[subs="specialcharacters,quotes"]
----
$ *mkdir ../database*
$ *python manage.py syncdb*
Creating tables ...
[...]
$ ls ../database/
database.sqlite
----

That seems to work.  Let's commit it.

[subs="specialcharacters,quotes"]
----
$ *git diff* # should show changes in settings.py
$ *git commit -am"move sqlite database outside of main source tree"*
----

To get our code onto the server, we'll use git and go via one of the code
sharing sites.  If you haven't already, push your code up to GitHub, BitBucket
or similar.  They all have excellent instructions for beginners on how to
do that.  

Here's some bash commands that will set this all up. If you're not familiar
with it, note the `export` command which lets me set up a "local variable"
in bash:

    export SITENAME=book-example-staging.obeythetestinggoat.com
    mkdir -p /home/harry/sites/$SITENAME
    mkdir /home/harry/sites/$SITENAME/database
    mkdir /home/harry/sites/$SITENAME/static
    mkdir /home/harry/sites/$SITENAME/virtualenv
    cd ~/sites/$SITENAME
    # you should replace the next line with the URL to your own repo
    git clone https://github.com/hjwp/book-example.git source

Now we've got the site installed, let's just try running the dev server -- this
is a smoke test, to see if all the moving parts are connected:

    $ python manage.py runserver
    Traceback (most recent call last):
      File "manage.py", line 8, in <module>
        from django.core.management import execute_from_command_line
    ImportError: No module named django.core.management

Ah. Django isn't installed on the server. 

Creating a virtualenv
^^^^^^^^^^^^^^^^^^^^^

We could install it at this point, but that would leave us with a problem:  if
we ever wanted to upgrade Django when a new version comes out, it would be
impossible to test the staging site with a different version from live.
Similarly, if there are other users on the server, we'd all be forced to use
the same version of Django.

The solution is a "virtualenv" -- a neat way of having different versions of
python packages installed in different places, in their own "virtual
environments".

Let's try it out on own PC first:

[subs="specialcharacters,quotes"]
----
$ *pip install virtualenv*
----

We'll follow the same folder structure as we're planning for the server:

[subs="specialcharacters,quotes"]
----
$ *virtualenv ../virtualenv*
$ *source ../virtualenv/bin/activate*
(virtualenv)$ python manage.py test lists
# will show ImportError: No module named django
# because Django isn't installed inside the virtualenv
(virtualenv)$ *pip install django*
[...]
Successfully installed django
Cleaning up...
(virtualenv)$ python manage.py test lists
[...]
OK
----

To "save" the list of packages we need in our virtualenv, and be able to 
re-create it later, we create a 'requirements.txt' file, using `pip freeze`,
and add that to our repository:

[subs="specialcharacters,quotes"]
----
(virtualenv)$ *pip freeze > requirements.txt*
(virtualenv)$ *git add requirements.txt*
(virtualenv)$ *deactivate*
$ *git commit -m"Add requirements.txt for virtualenv"*
----

Have a look inside 'requirements.txt' if you're curious, it's just a list of
the package names and versions.


And now we do a `git push` to send our updates up to our code-sharing site

[subs="specialcharacters,quotes"]
----
$ *git push* 
----

And we can pull those changes down to the server

    $ git pull
    $ virtualenv ../virtualenv/
    (virtualenv)$ source ../virtualenv/bin/activate
    (virtualenv)$ pip install -r requirements.txt 
    Downloading/unpacking Django==1.5.1 (from -r requirements.txt (line 1))
    [...]
    (virtualenv)$ python manage.py runserver
    Validating models...
    0 errors found
    [...]

That looks like it worked.  

Simple nginx configuration
^^^^^^^^^^^^^^^^^^^^^^^^^^

Let's now go and edit our nginx config to tell it to send requests for our
staging site along to Django. A minimal config looks like this:


[role="sourcecode"]
.basic nginx config
[source,nginx]
----
server {
    listen 80;
    server_name book-example-staging.obeythetestinggoat.com;

    location /static {
        alias /home/harry/sites/book-example-staging.obeythetestinggoat.com/static;
    }

    location / {
        proxy_pass http://localhost:8000;
    }
}
----

This config says it will only work for our staging domain, it points the web
server to the folder where our static files are, and then it says to "proxy"
all other requests to the local port 8000 where it expects to find Django
waiting to respond to requests.

////
TODO: log files
////

I saved this to a file called 'book-example-staging.obeythetestinggoat.com'
inside '/etc/nginx/sites-available' folder, and then added it to the enabled
sites for the server by creating a symlink to it:

----
$ ln -s ../sites-available/$SITENAME /etc/nginx/sites-enabled/$SITENAME
----

That's the Debian/Ubuntu preferred way of saving nginx configurations -- 
the real file in 'site-available', and a symlink in 'sites-enabled', the
idea is that it makes it easier to switch sites on or off.

NOTE: I also had to edit '/etc/nginx/nginx.conf' and uncomment a line saying
`server_names_hash_bucket_size 64;` to get my long domain name to work...

And now to test it:

    (virtualenv)$ service nginx reload
    (virtualenv)$ python manage.py runserver

That gets us as far as seeing the site, but static files aren't working:

.Staging site is up!
image::images/staging_is_up.png[Our staging version is live... but looks ugly again]

Let's see what our functional tests say:

TODO: update this -- DEBUG is now True, so static files will work.

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test functional_tests --liveserver=book-example-staging.obeythetestinggoat.com*]
[...]
NoSuchElementException: Message: u'Unable to locate element:
{"method":"id","selector":"id_list_table"}' ; [...]
[...]
AssertionError: 125 != 497 within 3 delta
FAILED (failures=1, errors=1)
----

The tests are telling us that our CSS isn't working, and are also failing
as soon as they try and submit a new item, because we haven't set up the 
database. Let's do those two things now



Deploying static files and the database
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We run a `collectstatic` and a `syncdb` to set up static files and the
database. The `--noinput` suppresses the two little "are you sure" prompts:

----
(virtualenv)$ python manage.py collectstatic --noinput
(virtualenv)$ python manage.py syncdb --noinput
(virtualenv)$ ls ../static/
base.css  bootstrap
(virtualenv)$ ls ../database/
database.sqlite
(virtualenv)$ python manage.py runserver
----

Now if you have a look at the site, things are looking much healthier. We
can re-run our FTs:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test functional_tests --liveserver=book-example-staging.obeythetestinggoat.com*]
Creating test database for alias 'default'...
..
 ---------------------------------------------------------------------
Ran 2 tests in 10.718s

OK
----

Hooray!  We're reassured that the piping works, but we really can't be
using the Django dev. server in production.  We also can't be relying
on manually starting it up with `runserver`.

Switching to Gunicorn
^^^^^^^^^^^^^^^^^^^^^

Do you know why the Django mascot is a pony?  The story is that Django
comes with so many things you want -- an ORM, all sorts of middleware,
the admin site -- "what else do you want, a pony?". Well, Gunicorn stands
for "Green Unicorn", which I guess is what you'd want next if you already
had a pony...

    (virtualenv)$ pip install gunicorn

Gunicorn will need to know a path to a WSGI server, which is usually
a function called `application`.  Django provides one at 'superlists/wsgi.py'.

We can try that out, and check that all the virtualenv magic works too, by
deactivating the virtualenv and seeing if we can still serve our app using
the `gunicorn` executable that pip just put in there for us:


    (virtualenv)$ deactivate
    $ ../virtualenv/bin/gunicorn superlists.wsgi:application
    2013-05-27 16:22:01 [10592] [INFO] Starting gunicorn 0.17.4
    2013-05-27 16:22:01 [10592] [INFO] Listening at: http://127.0.0.1:8000 (10592)
    [...]

That looks good!  

Switching to using Unix sockets
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When we want to serve both staging and live, we can't have both servers trying
to use port 8000.  We could decide to allocate different ports, but that's a
bit arbitrary, and it would be dangerously easy to get it wrong and start
the staging server on the live port, or vice versa.

A better solution is to use unix domain sockets -- they're like files on disk,
but can be used by nginx and gunicorn to talk to each other.  We'll put our
sockets in '/tmp'.  We change the proxy settings in nginx:

[role="sourcecode"]
./etc/nginx/sites-available/book-example-staging.obeythetestinggoat.com
[source,nginx]
----
[...]
    location / {
        proxy_set_header Host $host;
        proxy_pass http://unix:/tmp/book-example-staging.obeythetestinggoat.com.socket;
    }
}
----

`proxy_set_header` is needed to make sure gunicorn knows what domain
it's running on.


Adding gunicorn to our requirements.txt
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Back in the local copy of your repo, we should add gunicorn to the list
of packages we need in our virtualenvs:

[subs="specialcharacters,quotes"]
----
$ *source ../virtualenv/bin/activate*
(virtualenv)$ pip install gunicorn
(virtualenv)$ *pip freeze > requirements.txt*
$ *git commit -am"Add gunicorn to virtualenv requirements"*
$ *git push* 
----

Using upstart to make sure gunicorn starts on boot
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Our final step is to make sure that the server always starts
up gunicorn on boot.  On Ubuntu, the way to do this is using upstart.

[role="sourcecode"]
.Upstart script for Gunicorn
[source,bash]
----
description "Gunicorn server for book-example-staging.obeythetestinggoat.com"

start on net-device-up
stop on shutdown

respawn

chdir /home/harry/sites/book-example-staging.obeythetestinggoat.com/source
exec ../virtualenv/bin/gunicorn --bind /tmp/book-example-staging.obeythetestinggoat.com.socket superlists.wsgi:application
----

You can see the exta `--bind` parameter which tells Gunicorn to listen
to that Unix domain socket.

I copied this file into '/etc/init' on the server, calling it
'/etc/init/gunicorn-book-example-staging.obeythetestinggoat.conf'

Now we can start gunicorn with

    sudo service gunicorn-book-example-staging.obeythetestinggoat.com start

And you can even test that the site comes back up if you reboot the server!


TODO: at this point there will be a server error and the css will be broken.


Switching DEBUG to False and setting ALLOWED_HOSTS
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

At the top of 'settings.py', you'll find the `DEBUG` setting.  In production,
we should always set this to `False`.  When we do that, we also need to set
another setting called `ALLOWED_HOSTS`. This was
https://docs.djangoproject.com/en/1.5/ref/settings/#std:setting-ALLOWED_HOSTS[added
as a security feature] in Django 1.5.  Unfortunately it doesn't have an entry
with a helpful comment in the default 'settings.py', but we can add one
ourselves:

[role="sourcecode"]
.superlists/settings.py
[source,python]
----
# Django settings for superlists project.
from os import path

DEBUG = False
TEMPLATE_DEBUG = DEBUG

# This next setting is needed when DEBUG=False
ALLOWED_HOSTS = ['localhost', '.obeythetestinggoat.com']
[...]
----

We add that to version control:

[subs="specialcharacters,quotes"]
----
$ *git commit -am"Set DEBUG to False and add domain to ALLOWED_HOSTS"*
----

Deploying static files 
^^^^^^^^^^^^^^^^^^^^^^

We run a `collectstatic --noinput` :

----
(virtualenv)$ python manage.py collectstatic --noinput
(virtualenv)$ ls ../static/
base.css  bootstrap
----

Now if you have a look at the site, things are looking much healthier. We
can re-run our FTs:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test functional_tests --liveserver=book-example-staging.obeythetestinggoat.com*]
Creating test database for alias 'default'...
..
 ---------------------------------------------------------------------
Ran 2 tests in 10.718s

OK
----



Automating:
~~~~~~~~~~~


Let's re-cap on our provisioning and deployment procedures

Provisioning:

* apt-get nginx git python-pip
* pip install virtualenv
* add nginx config for virtual host
* add upstart job for gunicorn
* create user account + home folder for user

TODO: DEBUG = False

Deployment

* create directory structure
* pull down source code into source
* pip install -r requirements.txt
* syncdb for database
* collectstatic for static files
* restart gunicorn job
* run FTs


Assuming we're not ready to entirely automate our provisioning process, how
should we save the results of our investigation so far?  I would say that 
the nginx and upstart config files should probably be saved for later, in
a way that makes it easy to re-use them later.  Let's save them in a new
subfolder in our repo:


[subs="specialcharacters,quotes"]
----
$ *mkdir deploy_tools*
----


[role="sourcecode"]
.deploy_tools/nginx.template.conf
[source,nginx]
----
server {
    listen 80;
    server_name SITENAME;

    location /static {
        alias /home/harry/sites/SITENAME/static;
    }

    location / {
        proxy_set_header Host $host;
        proxy_pass http://unix:/tmp/SITENAME.socket;
    }
}
----


[role="sourcecode"]
.deploy_tools/gunicorn-upstart.template.conf
[source,bash]
----
description "Gunicorn server for SITENAME"

start on net-device-up
stop on shutdown

respawn

chdir /home/harry/sites/SITENAME/source
exec ../virtualenv/bin/gunicorn --bind unix:/tmp/SITENAME.socket superlists.wsgi:application
----

Then it's easy for us to use those two files to generate
a new site, by doing a find & replace on  `SITENAME`

For the rest, just keeping a few notes is OK. Why not keep
them in a file in the repo?


[role="sourcecode"]
.deploy_tools/provisioning_notes.md
[source,rst]
----
Provisioning a new site
=======================

## Required packages:

* nginx
* git
* pip
* virtualenv

eg, on Ubuntu:

    apt-get install nginx git python-pip
    pip install virtualenv

## Nginx Virtual Host config

* see nginx.template.conf
* replace SITENAME with, eg, staging.my-domain.com

## Upstart Job

* see gunicorn-upstart.template.conf
* replace SITENAME with, eg, staging.my-domain.com

## Folder structure:
Assume we have a user account at /home/username

/home/username
└── sites
    └── SITENAME
         ├── database
         ├── source
         ├── static
         └── virtualenv
----

We can do a commit for those:

[subs="specialcharacters,quotes"]
----
$ *git add deploy_tools*
$ *git status* # see three new files
$ *git commit -m"Notes and template config files for provisioning"*
----

Our source tree will now look something like this:

----
$ tree -I \*.pyc
.
├── deploy_tools
│   ├── gunicorn-upstart.template.conf
│   ├── nginx.template.conf
│   └── provisioning_notes.md
├── functional_tests
│   ├── __init__.py
│   ├── [...]
├── lists
│   ├── __init__.py
│   ├── [...]
├── manage.py
├── requirements.txt
└── superlists
    ├── [...]
----


Automating deployment with fabric
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Fabric is a tool which lets you automate commands that you want to run on
servers. You can install fabric system-wide -- it's not part of the core
functionality of our site, so it doesn't need to go into our virtualenv and
'requirements.txt'.

[subs="specialcharacters,quotes"]
----
$ *pip install fabric*
----

The usual setup is to have a file called 'fabfile.py', which will
contain one or more functions that can later be invoked from a command-line
tool called `fab`, like this:

----
fab function_name,host=SERVER_ADDRESS
----

That will invoke the function called function_name, passing in a connection
to the server at SERVER_ADDRESS.  There are many other options for specifying
usernames and passwords, which you can find out about using `fab --help`

The best way to see how it works is with an example.  Here's a fabfile I've 
built which automates all the steps we went through in the deploy earlier.  The 
main function is called `deploy`, that's the one we'll invoke from the command-line.
It uses several helper functions.  `env.host` will contain the server address that
we've passed in.

[role="sourcecode"]
.deploy_tools/fabfile.py
[source,python]
----
from fabric.contrib.files import exists
from fabric.api import env, run
from os import path


REPO_URL = 'https://github.com/hjwp/book-example.git' #<1>
SITES_FOLDER = '/home/harry/sites'

def deploy():
    _create_directory_structure_if_necessary(env.host) #<2>
    source_folder = path.join(SITES_FOLDER, env.host, 'source')
    _get_latest_source(source_folder)
    _update_virtualenv(source_folder)
    _update_static_files(source_folder)
    _update_database(source_folder)


def _create_directory_structure_if_necessary(site_name):
    base_folder = path.join(SITES_FOLDER, site_name)
    run('mkdir -p %s' % (base_folder)) #<3><4>
    for subfolder in ('database', 'static', 'virtualenv', 'source'):
        run('mkdir -p %s/%s' % (base_folder, subfolder))

def _get_latest_source(source_folder):
    if exists(path.join(source_folder, '.git')): #<5><6>
        run('cd %s && git reset --hard' % (source_folder,))
        run('cd %s && git pull' % (source_folder,)) #<7>
    else:
        run('git clone %s %s' % (REPO_URL, source_folder))

def _update_virtualenv(source_folder):
    virtualenv_folder = path.join(source_folder, '../virtualenv')
    if not exists(path.join(virtualenv_folder, 'bin', 'pip')): #<8>
        run('virtualenv %s' % (virtualenv_folder,))
    run('%s/bin/pip install -r %s/requirements.txt' % (
            virtualenv_folder, source_folder
    ))


def _update_static_files(source_folder):
    run('cd %s && ../virtualenv/bin/python manage.py collectstatic --noinput' % ( # <9>
        source_folder,
    ))


def _update_database(source_folder):
    run('cd %s && ../virtualenv/bin/python manage.py syncdb --noinput' % (
        source_folder,
    ))


----

A few explanations of what's going on:

<1> You'll want to update the `REPO_URL` variable with the URL of your
own git repo on its code sharing site
<2> `env.host` will contain the address of the server we've specified at the 
command-line, eg 'book-example.obeythetestinggoat.com'.
<3> `run` is the most common fabric command.  It says "run this shell command on
the server".
<4> `mkdir -p` is a useful flavor of `mkdir`, which is better than mkdir in two
ways: it can create directories several levels deep, and it only creates them
if necessary.  So, `mkdir -p /tmp/foo/bar` will create the directory 'foo' but
also its parent directory 'bar' if it needs to.  It also won't complain if
'bar' already exists.
<5> `exists` checks whether a directory or file already exists on the server.
<6> We look for the '.git' hidden folder to check whether the repo has already
been cloned in a particular folder
<7> Many commands start with a `cd` in order to set the current working directory.
Fabric doesn't have any state, so it doesn't remember what directory you're in
from one `run` to the next.
<8> We look inside the virtualenv folder for the `pip` executable as a way of
checking whether it already exists.
<9> We use the virtualenv version of python whenever we need to run a Django 
'manage.py' command, to make sure we get the virtualenv version of django, not
the system one.

We can try this command out on our existing staging site -- the script should work
for an existing site as well as for a new one.  If you liked your Latin, you might
describe it as idempotent, which means it does nothing if run twice...

[subs="specialcharacters,macros"]
----
$ pass:quotes[*fab deploy:host=book-example-staging.obeythetestinggoat.com*]
[book-example-staging.obeythetestinggoat.com] Executing task 'deploy'
[book-example-staging.obeythetestinggoat.com] run: mkdir -p /home/harry/sites/book-example-staging.obeythetestinggoat.com
[book-example-staging.obeythetestinggoat.com] Login password for 'harry': 
[book-example-staging.obeythetestinggoat.com] run: mkdir -p /home/harry/sites/book-example-staging.obeythetestinggoat.com/database
[book-example-staging.obeythetestinggoat.com] run: mkdir -p /home/harry/sites/book-example-staging.obeythetestinggoat.com/static
[book-example-staging.obeythetestinggoat.com] run: mkdir -p /home/harry/sites/book-example-staging.obeythetestinggoat.com/virtualenv
[book-example-staging.obeythetestinggoat.com] run: mkdir -p /home/harry/sites/book-example-staging.obeythetestinggoat.com/source
[book-example-staging.obeythetestinggoat.com] run: cd /home/harry/sites/book-example-staging.obeythetestinggoat.com/source && git reset --hard
[book-example-staging.obeythetestinggoat.com] out: 
[book-example-staging.obeythetestinggoat.com] run: cd /home/harry/sites/book-example-staging.obeythetestinggoat.com/source && git pull
[book-example-staging.obeythetestinggoat.com] out: remote: Counting objects: 28, done.
[book-example-staging.obeythetestinggoat.com] out: remote: Compressing objects: 100% (16/16), done.
[book-example-staging.obeythetestinggoat.com] out: remote: Total 26 (delta 12), reused 24 (delta 10)
[book-example-staging.obeythetestinggoat.com] out: Unpacking objects: 100% (26/26), done.
[book-example-staging.obeythetestinggoat.com] out: From https://github.com/hjwp/book-example
[book-example-staging.obeythetestinggoat.com] out:    cd86199..2f776ca  master     -> origin/master
[book-example-staging.obeythetestinggoat.com] out: Updating 8203253..f6b7c73
[book-example-staging.obeythetestinggoat.com] out: Fast-forward
[book-example-staging.obeythetestinggoat.com] out:  deploy_tools/fabfile.py                     |   51 +++++++++++++++++++++++++++
[book-example-staging.obeythetestinggoat.com] out:  deploy_tools/gunicorn-upstart.template.conf |    9 +++++
[book-example-staging.obeythetestinggoat.com] out:  deploy_tools/nginx.template.conf            |   12 +++++++
[book-example-staging.obeythetestinggoat.com] out:  deploy_tools/provisioning_notes.md          |   36 +++++++++++++++++++
[book-example-staging.obeythetestinggoat.com] out:  4 files changed, 108 insertions(+)
[book-example-staging.obeythetestinggoat.com] out:  create mode 100644 deploy_tools/fabfile.py
[book-example-staging.obeythetestinggoat.com] out:  create mode 100644 deploy_tools/gunicorn-upstart.template.conf
[book-example-staging.obeythetestinggoat.com] out:  create mode 100644 deploy_tools/nginx.template.conf
[book-example-staging.obeythetestinggoat.com] out:  create mode 100644 deploy_tools/provisioning_notes.md
[book-example-staging.obeythetestinggoat.com] out: HEAD is now at f6b7c73 tweaks to fabfile
[book-example-staging.obeythetestinggoat.com] out: 
[book-example-staging.obeythetestinggoat.com] run: /home/harry/sites/book-example-staging.obeythetestinggoat.com/source/../virtualenv/bin/pip install -r /home/harry/sites/book-example-staging.obeythetestinggoat.com/source/requirements.txt
[book-example-staging.obeythetestinggoat.com] out: Requirement already satisfied (use --upgrade to upgrade): Django==1.5.1 in ./sites/book-example-staging.obeythetestinggoat.com/virtualenv/lib/python2.7/site-packages (from -r /home/harry/sites/book-example-staging.obeythetestinggoat.com/source/requirements.txt (line 1))
[book-example-staging.obeythetestinggoat.com] out: Requirement already satisfied (use --upgrade to upgrade): argparse==1.2.1 in /usr/lib/python2.7 (from -r /home/harry/sites/book-example-staging.obeythetestinggoat.com/source/requirements.txt (line 2))
[book-example-staging.obeythetestinggoat.com] out: Requirement already satisfied (use --upgrade to upgrade): wsgiref==0.1.2 in /usr/lib/python2.7 (from -r /home/harry/sites/book-example-staging.obeythetestinggoat.com/source/requirements.txt (line 3))
[book-example-staging.obeythetestinggoat.com] out: Cleaning up...
[book-example-staging.obeythetestinggoat.com] out: 
[book-example-staging.obeythetestinggoat.com] run: cd /home/harry/sites/book-example-staging.obeythetestinggoat.com/source && ../virtualenv/bin/python manage.py collectstatic --noinput
[book-example-staging.obeythetestinggoat.com] out: 
[book-example-staging.obeythetestinggoat.com] out: 0 static files copied, 9 unmodified.
[book-example-staging.obeythetestinggoat.com] out: 
[book-example-staging.obeythetestinggoat.com] run: cd /home/harry/sites/book-example-staging.obeythetestinggoat.com/source && ../virtualenv/bin/python manage.py syncdb --noinput
[book-example-staging.obeythetestinggoat.com] out: Creating tables ...
[book-example-staging.obeythetestinggoat.com] out: Installing custom SQL ...
[book-example-staging.obeythetestinggoat.com] out: Installing indexes ...
[book-example-staging.obeythetestinggoat.com] out: Installed 0 object(s) from 0 fixture(s)
[book-example-staging.obeythetestinggoat.com] out: 

Done.
Disconnecting from book-example-staging.obeythetestinggoat.com... done.
----

If you look through that, you can see the `mkdir -p` commands going through
happily, even though the directories already exist.  Next we do the `git pull`,
which pulls down the couple of commits we just made.  Then we see the 
`pip install -r requirements.txt`, which completes happily, noting that the 
existing virtualenv already has all the packages we need.  The `collectstatic`
also notices that the static files are already there, and the `syncdb` also
completes without a hitch.

So, let's try using it for our live site!

[subs="specialcharacters,macros"]
----
$ pass:quotes[*fab deploy:host=book-example.obeythetestinggoat.com*]
[book-example.obeythetestinggoat.com] Executing task 'deploy'
[book-example.obeythetestinggoat.com] run: mkdir -p /home/harry/sites/book-example.obeythetestinggoat.com
[book-example.obeythetestinggoat.com] Login password for 'harry':  <1>
[book-example.obeythetestinggoat.com] run: mkdir -p /home/harry/sites/book-example.obeythetestinggoat.com/database
[book-example.obeythetestinggoat.com] run: mkdir -p /home/harry/sites/book-example.obeythetestinggoat.com/static
[book-example.obeythetestinggoat.com] run: mkdir -p /home/harry/sites/book-example.obeythetestinggoat.com/virtualenv
[book-example.obeythetestinggoat.com] run: mkdir -p /home/harry/sites/book-example.obeythetestinggoat.com/source
[book-example.obeythetestinggoat.com] run: git clone https://github.com/hjwp/book-example.git /home/harry/sites/book-example.obeythetestinggoat.com/source
[book-example.obeythetestinggoat.com] out: Cloning into '/home/harry/sites/book-example.obeythetestinggoat.com/source'...
[book-example.obeythetestinggoat.com] out: remote: Counting objects: 461, done.
[book-example.obeythetestinggoat.com] out: remote: Compressing objects: 100% (262/262), done.
[book-example.obeythetestinggoat.com] out: Receiving objects: 100% (461/461), 137.86 KiB, done.
[book-example.obeythetestinggoat.com] out: Resolving deltas: 100% (208/208), done.
[book-example.obeythetestinggoat.com] out: 
[book-example.obeythetestinggoat.com] run: virtualenv /home/harry/sites/book-example.obeythetestinggoat.com/source/../virtualenv
[book-example.obeythetestinggoat.com] out: New python executable in /home/harry/sites/book-example.obeythetestinggoat.com/source/../virtualenv/bin/python
[book-example.obeythetestinggoat.com] out: Installing setuptools............done.
[book-example.obeythetestinggoat.com] out: Installing pip...............done.
[book-example.obeythetestinggoat.com] out: 
[book-example.obeythetestinggoat.com] run: /home/harry/sites/book-example.obeythetestinggoat.com/source/../virtualenv/bin/pip install -r /home/harry/sites/book-example.obeythetestinggoat.com/source/requirements.txt
[book-example.obeythetestinggoat.com] out: Downloading/unpacking Django==1.5.1 (from -r /home/harry/sites/book-example.obeythetestinggoat.com/source/requirements.txt (line 1))
[book-example.obeythetestinggoat.com] out:   Downloading Django-1.5.1.tar.gz (8.0MB): 8.0MB downloaded
[book-example.obeythetestinggoat.com] out:   Running setup.py egg_info for package Django
[...]
[book-example.obeythetestinggoat.com] out: Successfully installed Django
[book-example.obeythetestinggoat.com] out: Cleaning up...
[book-example.obeythetestinggoat.com] out: 
[book-example.obeythetestinggoat.com] out: Copying '/home/harry/sites/book-example.obeythetestinggoat.com/source/lists/static/base.css'
[...]
[book-example.obeythetestinggoat.com] out: Copying '/home/harry/sites/book-example.obeythetestinggoat.com/source/lists/static/bootstrap/img/glyphicons-halflings-white.png'
[book-example.obeythetestinggoat.com] out: 
[book-example.obeythetestinggoat.com] out: 9 static files copied.
[book-example.obeythetestinggoat.com] out: 
[book-example.obeythetestinggoat.com] run: cd /home/harry/sites/book-example.obeythetestinggoat.com/source && ../virtualenv/bin/python manage.py syncdb --noinput
[book-example.obeythetestinggoat.com] out: Creating tables ...
[book-example.obeythetestinggoat.com] out: Creating table auth_permission
[...]
[book-example.obeythetestinggoat.com] out: Installing indexes ...
[book-example.obeythetestinggoat.com] out: Installed 0 object(s) from 0 fixture(s)
[book-example.obeythetestinggoat.com] out: 

Done.
Disconnecting from book-example.obeythetestinggoat.com... done.
----

You can see the script follows a slightly different path, doing a `git clone`
to bring down a brand new repo instead of the `git pull`.  It also needs to set
up a new virtuaelnv from scratch, including a fresh install of pip and Django.
The `collectstatic` actually creates new files this time, and the `syncdb` seems
to have worked too.

What else do we need to do to get our live site into production? We refer to
our provisioning notes, which tell us to use the template files to create our
nginx virtual host and the upstart script.  How about a little Unix
command-line magic?

----
sed "s/SITENAME/book-example.obeythetestinggoat.com/g" deploy_tools/nginx.template.conf | sudo tee /etc/nginx/sites-enabled/book-example.obeythetestinggoat.com
----

`sed` ("stream editor" takes a stream of text and performs edits on it.  In
this case we ask it to substitute the string 'SITENAME' for the address of
our site, with the `s/replaceme/withthis/g` syntax.  We pipe (`|`) the output
of that to a root-user process (sudo) which uses `tee` to write what's piped
to it to a file, in this case the nginx sites-available virtualhost config
file.

We can now activate that file:

----
$ sudo ln -s ../sites-available/book-example.obeythetestinggoat.com /etc/nginx/sites-enabled/book-example.obeythetestinggoat.com
----

Now we write the upstart script:

----
sed "s/SITENAME/book-example.obeythetestinggoat.com/g" deploy_tools/nginx.template.conf | sudo tee /etc/init/gunicorn-book-example.obeythetestinggoat.com.conf
----

And now we start both services:

----
service nginx reload
service gunicorn-book-example.obeythetestinggoat.com start
----

And we take a look at our site.  It works, hooray! 

You now have a live website!  Tell all your friends!  Tell your mum, if no-one
else is interested! And, in the next chapter, it's back to coding again...

Recap:
~~~~~

Lots of this, particularly on the provisioning side, was very specific to the
setup I happened to have.  When you deploy sites, you might use apache instead
of nginx, uwsgi instead of gunicorn, supervisor instead of upstart, and so on.
If you use a PaaS, some of these problems will be solved for you, others won't.
But I really wanted to take you through a practical example, so we could see
some of the concerns involved in deployment.

There are some elements that will be common to all situations though:

* You need to choose a place for your static files
* You'll need specific config for your database
* You need to run some kind of webserver, set it to listen on some port
or domain socket, and set it up so that it starts up automatically

On the deployment side, you should find that much of what we've done is
transferable to any situation:

* During a deploy, you need a way to 'update your source code'.  We're using
`git pull`.
* You need a way to update your 'static files' (`collectstatic`)
* You need to update your 'database' (`syncdb` for now, we'll look at 
South and schema migrations later)
* You need to manage your dependencies, and make sure any packages you need
are available on the server. We use a 'virtualenv' to isolate our various
sites from each other.
* You'll want to 'test' that these things work, by doing your deployment to a
staging site first
* You should be able to run your functional test suite against a 'staging site'.
* You'll want to 'automate' all of the steps involved in a deploy, to give
yourself confidence that when you deploy to live, things will go just as
smoothly as when you deployed to staging.

Further reading:
~~~~~~~~~~~~~~~~

I'm no grizzled expert on deployment.  I've tried to set you off on a
reasonably sane path, but there's lots of things you could do differently,
and lots, lots more to learn besides.  Here are some articles I used for
inspiration:

* <<python-deployments,Solid Python Deployments for Everybody, by Hynek Schlawack>>
* <<gitric,Git-based fabric deployments are awesome, by Dan Bravender>>




Todos
~~~~~~

(If you're reading this it means you've got a hold of an early draft of the
chapter.  Thanks for bearing with me, feedback and suggestions appreciated via
obeythetestinggoat@gmail.com)

Objectives:

- as simple as possible
- but no simpler
- try and make it similar to the environment you'd get in a PaaS

Possible changes:

- talk about logging?
- the switch to domain sockets makes things feel complicated?  But, on a PaaS
you wouldn't have to worry about this...  Also, if I go for domain sockets from 
the word go, then I can't start off using the dev server, so we also have to
bite the virtualenv/gunicorn bullets at the same time.
- am getting annoyed at using the full domain name in every single config file.
Particularly for the upstart scripts, it sucks because they won't tab complete...
- maybe use a shorter domain?  I could register obeyttg.com or similar... Also,
maybe get the name "superlists" in there...




