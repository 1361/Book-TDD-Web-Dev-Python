Saving user input
-----------------

We want to take the To-Do item input from the user and send it to the server,
so that we can save it and display it back to them later.  For now, we'll use a
fairly standard HTML form and POST request.  A little boring, but also nice and
easy to deliver - we can use all sorts of sexy HTML5 and JavaScript later in
the book.

As I started writing this chapter, I immediately skipped to what I thought was
the right answer -- building multiple models for lists and list items, and then
building a couple of new views for dealing with POST requests -- and started
writing that. But I stopped myself, and decided to present things in a much
more iterative fashion instead, taking one step at a time, even if I suspected
that the step wouldn't quite solve the whole problem. I decided to be
deliberately short-sighted.

One reason is that it makes for a more gradual learning curve -- it introduces
one concept at a time, rather than all of them at once. More importantly, it
also demonstrates how TDD can save you from having to be smart all the time.
Instead of needing to think several steps ahead, it is always possible to just
let the tests drive development, and iterate towards the right answer. It may
not be the most direct route, but each step is at least partially in the right
direction, and even if we end up re-writing most of my code, we get there in
the end.

That's not to say you shouldn't try and think ahead, and be clever.  In the
next chapter we'll use a bit more design and up-front thinking, and show how
that fits in with TDD. But for now, let's plough on mindlessly, like a goat,
and see if TDD will save us.



Wiring up our form to send a POST request
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To get our browser to send a POST request, we can wrap the `<input>` element in
a `<form>` tag with `method="POST"`, and the browser will take care of sending
the POST request for us.

[source,html]
----
    <h1>Your To-Do list</h1>
    <form method="POST">
        <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
    </form>

    <table id="id_list_table">
----

We also had to add the `name="item_text"` attribute on the input element. Now,
running our FTs gives us a slightly cryptic, unexpected error:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python functional_tests.py*]
[...]
Traceback (most recent call last):
  File "functional_tests.py", line 38, in test_can_start_a_list_and_retrieve_it_later
    table = self.browser.find_element_by_id('id_list_table')
[...]
NoSuchElementException: Message: u'Unable to locate element:
{"method":"id","selector":"id_list_table"}' ;
----

When a functional test fails with an unexpected failure, there are several
things we can do to debug them:

* Add `print` statements, to show, eg, what the current page text is
* Improve the error message to show more info about the current state
* Manually visit the site yourself
* Use `time.sleep` to pause the test during execution


We'll look at all of these over the course of this book, but the `time.sleep` 
option is one I find myself using very often.  Let's try it now.  We add
the sleep just before the error occurs:


[source,python]
----
    # When she hits enter, the page updates, and now the page lists
    # "1: Buy peacock feathers" as an item in a to-do list table
    inputbox.send_keys(Keys.ENTER)

    import time
    time.sleep(10)
    table = self.browser.find_element_by_id('id_list_table')
----

When we run the functional tests again, we've got time to see what's going on -
you should see a page that looks like <<csrf_error_screenshot>>, with lots of
Django debug information:


[[csrf_error_screenshot]]
.Django DEBUG page showing CSRF error
image::images/csrf_protection_error.png[Django DEBUG page showing CSRF error]

If you've never heard of a ``Cross-Site Request Forgery'' exploit, why not look
it up now? Like all security exploits, it's entertaining to read about, being
an ingenious use of a system in unexpected ways...

.Security: surprisingly fun!
*******************************************************************************
When I took my Computer Science degree (I almost didn't!), I signed up for
the Security module out of a sense of duty:  ``Oh well, it'll probably be 
very dry and boring, but I suppose I'd better take it''.  It turned out to 
be one of the most fascinating modules of the whole course -- absolutely
full of the joy of hacking, of the particular mindset it takes to think
about how systems can be used in unintended ways.  I want to recommend the 
textbook for my course, Ross Anderson's <<seceng,Security Engineering>>. It's 
quite light on pure crypto, but it's absolutely full of interesting discussions
of unexpected topics like lock-picking, forging bank notes, inkjet printer 
cartridge economics, and spoofing South African Air Force jets with replay 
attacks.  It's a huge tome, about 3 inches thick, and I promise you it's 
an absolute page-turner.
*******************************************************************************

Django's CSRF protection involves placing a little auto-generated token into
each generated form, to be able to identify POST requests as having come from
the original site.  So far our template has been pure HTML, and in this step we
make the first use of Django's template magic.  We can add the CSRF token by
using Django's special syntax for templates.  In this case we add what's called
a template tag using the special curly-bracket / percent syntax, `{% ... %}` 
(famous for being the world's most annoying two-key touch-typing combination.
Go on, try it: right pinky shift, left pinky curly, left pinky shift, right
index fumble for the 5 key... impossible!)


[source,html]
----
    <form method="POST" >
        <input id="id_new_item" name="item_text" placeholder="Enter a to-do item" />
        {% csrf_token %}
    </form>
----

The Django template system will substitute that during rendering with a special
`<input type="hidden"`. Re-running the functional test will now give us an
expected failure:

----
AssertionError: New to-do item did not appear in table
----

The test will also pause on the final screen, showing you that the new item
text disappears after the form is submitted, and the page refreshes to show an
empty form again.  That's because we haven't wired up our server to deal with
the POST request yet - it just ignores it and displays the normal home page.

We can remove the time.sleeps for now though.

[source,python]
----
    # "1: Buy peacock feathers" as an item in a to-do list table
    inputbox.send_keys(Keys.ENTER)

    table = self.browser.find_element_by_id('id_list_table')
----


Processing a POST request on the server
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Currently our form is just submitting back to the same URL it was rendered
from. Let's adapt the view for our home page to be able to deal with a POST
request.

Open up 'lists/tests.py', and add a new method to `HomePageTest` - I copy &
pasted the previous method, and then adapted it to add our POST request, and
then check that the returned HTML will have the new item text in it:

[source,python]
----
    [...]
    def test_home_page_returns_correct_html(self):
        request = HttpRequest()
        response = home_page(request)
        expected_html = render_to_string('home.html')
        self.assertEqual(response.content, expected_html)


    def test_home_page_can_save_a_POST_request(self):
        request = HttpRequest()
        request.method = 'POST'
        request.POST['item_text'] = 'A new list item'

        response = home_page(request)

        self.assertIn('A new list item', response.content)
----

You can see that we're using a couple of special attributes of the
`HttpRequest`, `.method` and `.POST`.  They're fairly self-explanatory,
although now might be a good time for a peek at the Django
https://docs.djangoproject.com/en/1.5/ref/request-response/[Request and
Response documentation]. The unit test goes on to check that the new item text
from our POST request ends up in our rendered template -- that gives us our 
expected fail:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test lists*]
[...]
AssertionError: 'A new list item' not found in '<html> [...]
----

We can get the test to pass by providing a different code path for POST
requests:

[source,python]
----
def home_page(request):
    if request.method == 'POST':
        return HttpResponse(request.POST['item_text'])
    return render(request, 'home.html')
----

That gets our unit tests passing, but it's not really what we want.  What we 
really want to do is add the POST submission to the table in the home page
template.

We've already had a hint of it, it's time to start to get to know the real
power of the Django template syntax, which is to pass variables from our Python
view code, into our HTML templates.  

Let's adjust our unit test to check that the response is a template which has
been rendered with the new item text passed in as a variable:


[source,python]
----
    self.assertIn('A new list item', response.content)
    expected_html = render_to_string(
        'home.html',
        {'new_item_text':  'A new list item'}
    )
    self.assertEqual(response.content, expected_html)
----

As you can see, the `render_to_string` function takes, as its second parameter,
a mapping of variable names to values.  

Now we adjust our template to actually use the variable we're passing in. The
syntax is `{{ ... }}`, which displays a variable as a string.

[source,html]
----
    <body>
        <h1>Your To-Do list</h1>
        <form method="POST" >
            <input id="id_new_item" name="item_text" placeholder="Enter a to-do item" />
            {% csrf_token %}
        </form>

        <table id="id_list_table">
            <tr><td>{{ new_item_text }}</td></tr>
        </table>

    </body>
----

Our unit tests will now fail at 

----
    self.assertEqual(response.content, expected_html)
AssertionError: 'A new list item' != u'<html>\n    <head>\n [...]
----

And we can now re-write our view, and tell it to pass the POST parameter to the
template:


[source,python]
----
def home_page(request):
    return render(request, 'home.html', {
        'new_item_text': request.POST['item_text'],
    })
----

Re-run the unit tests:

----
ERROR: test_home_page_returns_correct_html (lists.tests.HomePageTest)
[...]
    'new_item_text': request.POST['item_text'],
KeyError: 'item_text'
----

An unexpected failure! The unit tests have picked up a regression: although our
new test for handling POST requests is now passing, we broke the old test for
the code path where there is no POST request.  Here's one way to fix that:


[source,python]
----
def home_page(request):
    return render(request, 'home.html', {
        'new_item_text': request.POST.get('item_text', ''),
    })
----

The unit tests should now pass.  Let's see what the functional tests say:

----
AssertionError: New to-do item did not appear in table
----

Hm, not a wonderfully helfpul error.  Let's use another of our FT debugging
techniques: improving the error message.  This is probably the most
constructive, because those improved error messages stay around to help debug
any future errors:

[source,python]
----
    self.assertTrue(
        any(row.text == '1: Buy peacock feathers' for row in rows),
        "New to-do item did not appear in table -- its text was:\n%s" % (
            table.text,
        )
    )
----

That gives us a more helpful error message:

----
AssertionError: New to-do item did not appear in table -- its text was:
Buy peacock feathers
----

Aha.  We forgot that our FT wants us to enumerate list items with a ``1:'' at
the beginning of the first list item. The fastest way to get that to pass is
with a quick change to the template:


[source,html]
----
    <tr><td>1: {{ new_item_text }}</td></tr>
----

.Red / Green / Refactor and Triangulation
*******************************************************************************
The unit test / code cycle is sometimes taught as ``Red, Green, Refactor'':

* Start by writing a unit test which fails (*``Red''*)
* Write the simplest possible code to get it to pass (*``Green''*), even if
that means cheating
* *Refactor* to get to better code that makes more sense.

So what do we do during the Refactor stage?  One methodology is *eliminate 
duplication*: if your test uses a magic constant (like the 1: in front 
of our list item), and your application code also uses it, that counts as
duplication, so it justifies refactoring. Removing the magic constant from
the application code usually means you have to stop cheating.

I find that sometimes leaves things a little too vague, so I often like to
use a second technique, which is called *triangulation*: if your
tests let you get away with writing ``cheating'' code that you're not happy
with, like returning a magic constant, *write another test* that forces you to
write some better code.  That's what we're doing when we extend the FT to 
check that inputting a 'second' list item gives us a ``2:''

*******************************************************************************

Now we get to the `self.fail('Finish the test!')`.  If we extend our FT to 
check for adding a second item to the table (copy & paste is our friend), we
begin to see that our first cut solution really isn't going to, um, cut it.

[source,python]
----
    # There is still a text box inviting her to add another item. She
    # enters "Use peacock feathers to make a fly" (Edith is very
    # methodical)
    inputbox = self.browser.find_element_by_id('id_new_item')
    inputbox.send_keys('Use peacock feathers to make a fly')
    inputbox.send_keys(Keys.ENTER)

    # The page updates again, and now shows both items on her list
    table = self.browser.find_element_by_id('id_list_table')
    rows = table.find_elements_by_tag_name('tr')
    self.assertTrue(
        any(row.text == '2: Use peacock feathers to make a fly' for row in rows),
        "New to-do item did not appear in table -- its text was:\n%s" % (
            table.text,
        )
    )
    self.assertTrue(
        any(row.text == '1: Buy peacock feathers' for row in rows),
        "New to-do item did not appear in table -- its text was:\n%s" % (
            table.text,
        )
    )

    # Edith wonders whether the site will remember her list. Then she sees
    # that the site has generate a unique URL for her -- there is some
    # explanatory text to that effect.
    self.fail('Finish the test!')
----

TODO: three strikes and refactor - make fn to assert re tables

Sure enough, the functional tests error with:

----
AssertionError: New to-do item did not appear in table -- its text was:
1: Use peacock feathers to make a fly
----

Our naive solution was never going to be able to handle more than one 
list item. To persist multiple items in a list, we're going to have to
use some kind of database.

Still, it's a good idea to save our progress at this point.  Perhaps we're
about to throw away most of the work we've just done, but perhaps not.

[subs="specialcharacters,quotes"]
----
$ *git diff*
# should show changes to functional_test.py, home.html,
# tests.py and views.py
$ *git commit -a*
----


The Django ORM & our first model
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

An Object-Relational-Mapper (ORM) is a layer of abstraction for data stored in 
a database with tables, rows and columns. It lets us work with databases using
familiar Object-Oriented metaphors which work well with code.  Classes map to 
database tables, attributes map to columns, and an individual instance of the
class represent a row of data in the database.

Writing a unit test for our ORM is actually an excellent way of learning it, 
since it exercises code by specifying how we want it to work.  

Let's create a new class in 'polls/tests.py'

[source,python]
----
[...]
from lists.models import Item
from lists.views import home_page
[...]

class ItemModelTest(TestCase):

    def test_saving_and_retrieving_items(self):
        first_item = Item()
        first_item.text = 'The first (ever) list item'
        first_item.save()

        second_item = Item()
        second_item.text = 'Item the second'
        second_item.save()

        saved_items = Item.objects.all()
        self.assertEqual(saved_items.count(), 2)

        first_saved_item = saved_items[0]
        second_saved_item = saved_items[1]
        self.assertEqual(first_saved_item.text, 'The first (ever) list item')
        self.assertEqual(second_saved_item.text, 'Item the second')
----


You can see that creating a new record in the database is a relatively simple
matter of creating an object, assigning some attributes, and calling a
`.save()` function.  Django also gives us an API for querying the database via
a class method, `.objects`, and we use the simplest possible query, `.all()`,
which retrieves all the records for that table.  The results are returned as a
list-like object called a QuerySet, which we can call further functions on,
like `.count()`, and also extract individual objects. We then check the objects
as saved to the database, to check whether the right information was saved

Django's ORM has many other helpful and intuitive features, this might be a
good time to skim through the
https://docs.djangoproject.com/en/1.4/intro/tutorial01/#playing-with-the-api[Django
Tutorial] which has an excellent intro to them. 

Let's try running the unit test. Here comes another unit test/code cycle

----
ImportError: cannot import name Item
----

Let's give it something to import from 'lists/models.py'.  We're feeling
confident so let's skip the `Item = None` step, and go straight to creating a
class:

[source,python]
----
from django.db import models

class Item(object):
    pass
----

That gets our test as far as: 

----
    first_item.save()
AttributeError: 'Item' object has no attribute 'save'
----

To give our `Item` class a `save` method, we make it inherit from the Django
`Model` class:


[source,python]
----
from django.db import models

class Item(models.Model):
    pass
----

Now the test actually gets surprisingly far:

----
    self.assertEqual(first_saved_item.text, 'The first (ever) list item')
AttributeError: 'Item' object has no attribute 'text'
----

That's a full 8 lines later than the last failure -- we've been all the way
through saving the two Items, we've checked they're saved in the database, but
Django just doesn't seem to have remembered the `.text` attribute.

Classes that inherit from `models.Model` map to tables in the database.  By
default they get an auto-generated `id` attribute which will be a primary key
column in the database, but you have to define any other columns you want
explicitly. Here's how we set up a text field:


[source,python]
----
class Item(models.Model):
    text = models.TextField()
----

Django has many other field types, like `IntegerField`, `CharField`,
`DateField` and so on.  I've chosen `TextField` rather than `CharField` because
the latter requires a length restriction which seems arbitrary at this point.
You can read more on field types in the Django
https://docs.djangoproject.com/en/1.5/intro/tutorial01/#creating-models[tutorial]
and in the
https://docs.djangoproject.com/en/1.5/ref/models/fields/[documentation].

Let's do a commit for our first ever model!

[subs="specialcharacters,quotes"]
----
$ *git status*
$ *git diff* # see changes to tests.py and models.py
$ *git commit -am"Created model for list Items"*
----


Saving the POST to the database
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's adjust the test for our home page POST request, and say we want the view
to save a new item to the database:


[source,python]
----
def test_home_page_can_save_a_POST_request(self):
    request = HttpRequest()
    request.method = 'POST'
    request.POST['item_text'] = 'A new list item'

    response = home_page(request)

    self.assertEqual(Item.objects.all().count(), 1)
    new_item = Item.objects.all()[0]
    self.assertEqual(new_item.text, 'A new list item')

    self.assertIn('A new list item', response.content)
    expected_html = render_to_string(
        'home.html',
        {'new_item_text':  'A new list item'}
    )
    self.assertEqual(response.content, expected_html)
----

This test is getting a little long-winded.  It seems to be testing lots of
different things.  That's a 'code smell' -- a long unit test either needs to be
broken into two, or it may be an indication that the thing you're testing is
too complicated.  Let's add that to a mental to-do list, and run the test in
the meantime.  We get an expected failure:

TODO: explain what a code smell is?

----
    self.assertEqual(Item.objects.all().count(), 1)
AssertionError: 0 != 1
----

Let's adjust our view:

[source,python]
----
def home_page(request):
    item = Item()
    item.text = request.POST.get('item_text', '')
    item.save()

    return render(request, 'home.html', {
        'new_item_text': request.POST.get('item_text', ''),
    })
----

I've done so very naively, you can probably spot a very obvious problem,
which is that we're going to be saving empty items with every request to
the home page.  Let's add that to our list of things to fix later.  You know,
along with the painfully obvious fact that we currently have no way at all of
having different lists for different people.  That we'll keep ignoring for now.
La la la la...

Let's see how the tests get on... They pass!  Good.  We can do a bit of
refactoring:

----
    return render(request, 'home.html', {
        'new_item_text': item.text
    })
----

So, on our to-do list:

* Don't save blank items for every request
* Code smell: POST test is too long?
* Display multiple items in the table
* Support more than one list!

Let's start with the first one.  We could tack on an assertion to an existing
test, but it's best to keep tests to testing fewer things each, so let's add a
new one:

[source,python]
----
    def test_home_page_only_saves_items_when_necessary(self):
        request = HttpRequest()
        home_page(request)
        self.assertEqual(Item.objects.all().count(), 0)
----

That gives us a `1 != 0` failure.  Let's fix it:

[source,python]
----
def home_page(request):
    if request.method == 'POST':
        new_item_text = request.POST['item_text']
        Item.objects.create(text=new_item_text)
    else:
        new_item_text = ''

    return render(request, 'home.html', {
        'new_item_text': new_item_text,
    })
----

Redirect after a POST
~~~~~~~~~~~~~~~~~~~~~

`.objects.create` is a neat shorthand for creating a new `Item`, without
needing to call `.save()`. But, yuck, that whole `new_item_text = ''` dance is
making me pretty unhappy. Thankfully the next item on the list gives us a
chance to fix it. https://en.wikipedia.org/wiki/Post/Redirect/Get[Always
redirect after a POST], they say, so let's do that:

[source,python]
----
    def test_home_page_can_save_a_POST_request(self):
        request = HttpRequest()
        request.method = 'POST'
        request.POST['item_text'] = 'A new list item'

        response = home_page(request)

        self.assertEqual(Item.objects.all().count(), 1)
        new_item = Item.objects.all()[0]
        self.assertEqual(new_item.text, 'A new list item')

        self.assertEqual(resonse.status_code, 302)
        self.assertEqual(response['location'], '/')
----

That gives us `200 != 302`.  Let's tidy up our view:

[source,python]
----
from django.shortcuts import redirect, render
from lists.models import Item

def home_page(request):
    if request.method == 'POST':
        Item.objects.create(text=request.POST['item_text'])
        return redirect('/')

    return render(request, 'home.html')
----


Rendering items in the template
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Much better!  Back to our to-do list:

* [line-through]#Don't save blank items for every request#
* [line-through]#Code smell: POST test is too long?#
* Display multiple items in the table
* Support more than one list!

Let's have a new unit test that checks that the template can also display multiple
list items:

[source,python]
----
    def test_home_page_displays_all_list_items(self):
        Item.objects.create(text='itemey 1')
        Item.objects.create(text='itemey 2')

        request = HttpRequest()
        response = home_page(request)

        self.assertIn('itemey 1', response.content)
        self.assertIn('itemey 2', response.content)
----

That fails as expected:

----
AssertionError: 'itemey 1' not found in '<html>\n    <head>\n [...]
----

The Django template syntax has a tag for iterating through lists,
 `{% for .. in .. %}`, we can use it like this:


[source,html]
----
<table id="id_list_table">
    {% for item in items%}
        <tr><td>1: {{ item.text }}</td></tr>
    {% endfor %}
</table>
----

Pretty neat! If you haven't already, you should read up on the rest of the
https://docs.djangoproject.com/en/1.5/topics/templates/[Django template
language magic]

And now we pass the items to the template in our home page view:

[source,python]
----
def home_page(request):
    if request.method == 'POST':
        Item.objects.create(text=request.POST['item_text'])
        return redirect('/')

    items = Item.objects.all()
    return render(request, 'home.html', {'items': items})
----

Which gets our unit tests to pass... Moment of truth, will the functional test
pass?

    AssertionError: 'To-Do' not found in u'ImproperlyConfigured at /'

Oops, apparently not.  Let's use another functional test debugging technique,
and it's one of the most straightforward: manually visiting the site!  Open
up 'http://localhost:8000' in your web browser, and you'll see a Django debug
page saying:

----
Please fill out the database NAME in the settings module before using the
database.
----

Creating our production database with syncdb
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Another helpful error message from Django, which is basically complaining that
we haven't set up the database properly.  How come everything worked fine
in the unit tests, I hear you ask?  Because Django creates a special 'test
database' for unit tests, it's one of the magical things that Django's 
`TestCase` does.  

To set up our real database, we need to tell Django where it is -- sqlite
databases are a single file on disk.  We'll then need to create a table to 
hold our Items. Django will do that for us, using the definitions we provided
in 'models.py', with a command called `syncdb`:

First we edit 'superlists/settings.py':

[source,python]
----
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', 
        'NAME': 'database.sqlite',
[...]
----

You can try reloading the page on localhost at this point, and it will tell you
that there is a DatabaseError, ``no such table: lists_item''.  `syncdb`, one
of Django's Swiss army knife `manage.py` commands , will fix this:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py syncdb*]
Creating tables ...
Creating table auth_permission
Creating table auth_group_permissions
Creating table auth_group
Creating table auth_user_user_permissions
Creating table auth_user_groups
Creating table auth_user
Creating table django_content_type
Creating table django_session
Creating table django_site
Creating table lists_item

You just installed Django's auth system, which means you don't have any
superusers defined.
Would you like to create one now? (yes/no): pass:quotes[*no*]
Installing custom SQL ...
Installing indexes ...
Installed 0 object(s) from 0 fixture(s)
----

I said "no" to the question about superusers - we'll look at that in a later 
chapter.  For now we can refresh the page on localhost, see that our error is
gone, and try running the functional tests again.

----
AssertionError: New to-do item did not appear in table -- its text was:
1: Buy peacock feathers
1: Use peacock feathers to make a fly
----

Oooh, so close!  We just need to get our list numbering right.  Another awesome
Django template tag will help here: `forloop.counter`:

[source,html]
----
    {% for item in items%}
        <tr><td>{{ forloop.counter }}: {{ item.text }}</td></tr>
    {% endfor %}
----


Now what happens if we run the FT again?

----
AssertionError: New to-do item did not appear in table -- its text was:
1: Buy peacock feathers
2: Buy peacock feathers
3: Use peacock feathers to make a fly
----

Oh dear. It looks like previous runs of the test are leaving stuff lying around
in our database.  In fact, if you run the tests again, you should see:

----
1: Buy peacock feathers
2: Buy peacock feathers
3: Use peacock feathers to make a fly
4: Buy peacock feathers
5: Use peacock feathers to make a fly
----

We're going to have to tidy up after ourselves, but that's a topic for the next
chapter.

Apart from that little bug in our functional testing, we've got some code
that's more or less working.  Let's do a commit.  Start by doing a *`git
status`* and a *`git diff`*, and you should see changes to 'home.html',
'tests.py', 'views.py' and 'settings.py'.  Of those, the first three belong
together, whereas adding the database name to settings.py probably belongs
separately.  We'll also want to add the database file to our list of ignored 
files:

[subs="specialcharacters,quotes"]
----
$ *git add lists*
$ *git commit -m"Redirect after POST, and show all items in template"*
$ *git add superlists/settings.py*
$ *echo "database.sqlte" >> .gitignore*
$ *git add .gitignore*
$ *git commit -m"Name database in settings.py, add it to .gitignore"*
----

Where are we?  

* We've got a form set up to add new items to the list using POST.
* We've set up a simple model in the database to save list items.
* We've used at least 3 different FT debugging techniques.

But we've got a couple of items on our own to-do list, namely getting the FT to
clean up after itself, and perhaps more critically, adding support for more
than one list.  

I mean, I suppose we could ship the site as it is, but people might find it
strange that the entire human population has to share a single to-do list.  I
mean, it might get people to stop and think about how connected we all are to
one another, how we all share a common destiny here on spaceship Earth, and how
we must all work together to solve the global problems that we face.  But, in
practical terms, the site wouldn't be very useful...

Ah well.

