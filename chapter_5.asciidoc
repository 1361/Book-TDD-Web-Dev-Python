Chapter 5 - Saving user form submissions
--------------------------------------

We want to take the To-Do item input from the user and send it to the server,
so that we can save it and display it back to them later.  For now, we'll 
use a fairly standard HTML form and POST request.  A little boring, but also
nice and easy to deliver - we can use all sorts of sexy HTML5 and JavaScript
later in the book.




Wiring up our form to send a POST request
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To get our browser to send a POST request, we can wrap the `<input>` element in
a `<form>` tag with `method="POST"`, and the browser will take care of sending
the POST request for us.

One option is to have the same view that rendered our home page also deal with 
POST requests.  I think it keeps things simpler and clearer to separate the job
out to a separate view, with a separate URL, say '/lists/new'.  That would make
our form (in 'polls/templates/home.html') look like this:


[source,html]
----
    <h1>Your To-Do list</h1>
    <form method="POST">
        <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
    </form>

    <table id="id_list_table">
----

We also had to add the `name="item_text"` attribute on the input element. Now,
running our FTs gives us a slightly cryptic, unexpected error:

----
Traceback (most recent call last):
  File "functional_tests.py", line 38, in test_can_start_a_list_and_retrieve_it_later
    table = self.browser.find_element_by_id('id_list_table')
[...]
NoSuchElementException: Message: u'Unable to locate element:
{"method":"id","selector":"id_list_table"}' ;
----

When a functional test fails with an unexpected failure, there are several
things we can do to debug them:

* add `print` statements, to show, eg, what the current page text is
* improve the error message to show more info about the current state
* manually visit the site yourself
* use `time.sleep` to pause the test during execution


We'll look at all of these over the course of this book, but the `time.sleep` 
option is the one I find myself using the most.  Let's try it now.  We add
the sleep just before the error occurs:


[source,python]
----
    # When she hits enter, the page updates, and now the page lists
    # "1: Buy peacock feathers" as an item in a to-do list table
    inputbox.send_keys(Keys.ENTER)

    import time
    time.sleep(10)
    table = self.browser.find_element_by_id('id_list_table')
----

When we run the functional tests again, we've got time to see what's going on -
you should see a page that looks like <<csrf_error_screenshot>>, with lots of
Django debug information:


[[csrf_error_screenshot]]
.Django DEBUG page showing CSRF error
image::images/csrf_protection_error.png[Django DEBUG page showing CSRF error]

If you've never heard of a ``Cross-Site Request Forgery'' exploit, why not look
it up now? Like all security exploits, it's entertaining to read about, being
an ingenious use of a system in unexpected ways...

Django's CSRF protection involves placing a little auto-generated token into
each generated form, to be able to identify POST requests as having come from
the original site.  So far our template has been pure HTML, and in this step we
make the first use of Django's template magic.  We can add the CSRF token by
using Django's special syntax for templates.  In this case we add what's called
a template tag using the special curly-bracket / percent syntax, `{% ... %}` 
(famous for being the world's most annoying two-key touch-typing combination.
Go on, try it: right pinky shift, left pinky curly, left pinky shift, right
index fumble for the 5 key... impossible!)


[source,html]
----
    <form method="POST" >
        <input id="id_new_item" name="item_text" placeholder="Enter a to-do item" />
        {% csrf_token %}
    </form>
----

The Django template system will substitute that during rendering with a special
`<input type="hidden"`. Re-running the functional test will now give us an
expected failure:

----
AssertionError: New to-do item did not appear in table
----

The test will also pause on the final screen, showing you that the new item
text disappears after the form is submitted, and the page refreshes to show an
empty form again.  That's because we haven't wired up our server to deal with
the POST request yet - it just ignores it and displays the normal home page.

We can remove the time.sleeps for now though.


Processing a POST request on the server
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Currently our form is just submitting back to the same URL it was rendered
from. Let's adapt the view for our home page to be able to deal with a POST
request.

Open up 'lists/tests.py', and add a new method to `HomePageTest` - I copy &
pasted the previous method, and then adapted it to add our POST request, and
then check that the returned HTML will have the new item text in it:

[source,python]
----
    [...]
    def test_home_page_returns_correct_html(self):
        request = HttpRequest()
        response = home_page(request)
        expected_html = render_to_string('home.html')
        self.assertEqual(response.content, expected_html)


    def test_home_page_can_save_a_POST_request(self):
        request = HttpRequest()
        request.method = 'POST'
        request.POST['item_text'] = 'A new list item'

        response = home_page(request)

        self.assertIn(response.content, 'A new list item')

----

You can see that we're using a couple of special attributes of the
`HttpRequest`, `.method` and `.POST`.  They're fairly self-explanatory,
although now might be a good time for a peek at the Django
https://docs.djangoproject.com/en/1.5/ref/request-response/[Request and
Response documentation] . The unit test goes on to check that the new item text
from our POST request ends up in our rendered template -- that gives us our 
expected fail:

----
AssertionError: 'A new list item' not found in '<html> [...]
----

We can get the test to pass by providing a different code path for POST
requests:

[source,python]
----
def home_page(request):
    if request.method == 'POST':
        return HttpResponse(request.POST['item_text'])
    return render(request, 'home.html')
----

That gets our unit tests passing, but it's not really what we want.  What we 
really want to do is add the POST submission to the table in the home page
template.

We've already had a hint of it, it's time to start to get to know the real
power of the Django template syntax, which is to pass variables from our Python
view code, into our HTML templates.  

Let's adjust our unit test to check that the response is a template which has
been rendered with the new item text passed in as a variable:


[source,python]
----
    self.assertIn('A new list item', response.content)
    expected_html = render_to_string(
        'home.html',
        {'new_item_text':  'A new list item'}
    )
    self.assertEqual(response.content, expected_html)
----

As you can see, the render_to_string function takes, as its second parameter, a
mapping of variable names to values.  

Now we adjust our template to actually use the variable we're passing in. The
syntax is `{{ ... }}`, which displays a variable as a string.

[source,html]
----
    <body>
        <h1>Your To-Do list</h1>
        <form method="POST" >
            <input id="id_new_item" name="item_text" placeholder="Enter a to-do item" />
            {% csrf_token %}
        </form>

        <table id="id_list_table">
            <tr><td>{{ new_item_text }}</td></tr>
        </table>

    </body>
----

Our unit tests will now fail at 

----
    self.assertEqual(response.content, expected_html)
AssertionError: 'A new list item' != u'<html>\n    <head>\n [...]
----

And we can now re-write our view, and tell it to pass the POST parameter to the
template:


[source,python]
----
def home_page(request):
    return render(request, 'home.html', {
        'new_item_text': request.POST['item_text'],
    })
----

Re-run the unit tests:

----
ERROR: test_home_page_returns_correct_html (lists.tests.HomePageTest)
[...]
    'new_item_text': request.POST['item_text'],
KeyError: 'item_text'
----

An unexpected failure! The unit tests have picked up a regression: although our
new test for handling POST requests is now passing, we broke the old test for
the code path where there is no POST request.  Here's one way to fix that:


[source,python]
----
def home_page(request):
    return render(request, 'home.html', {
        'new_item_text': request.POST.get('item_text', ''),
    })
----

The unit tests should now pass.  Let's see what the functional tests say:

----
AssertionError: New to-do item did not appear in table
----

Hm, not a wonderfully helfpul error.  Let's use another of our FT ebugging 
techniques: improving the error message.  This is probably the most constructive,
because you can leave improved error messages to help debug any future errors:

[source,python]
----
    self.assertTrue(
        any(row.text == '1: Buy peacock feathers' for row in rows),
        "New to-do item did not appear in table -- its text was:\n%s" % (
            table.text,
        )
    )
----

That gives us a more helpful error message:

----
AssertionError: New to-do item did not appear in table -- its text was:
Buy peacock feathers
----

Aha.  We forgot that our FT wants us to enumerate list items with a ``1:'' at
the beginning of the first list item. The fastest way to get that to pass is
with a quick change to the template:


[source,html]
----
    <tr><td>1: {{ new_item_text }}</td></tr>
----

Now we get to the `self.fail('Finish the test!')`.  If we extend our FT to 
check for adding a second item to the table, we begin to see that our first
cut solution really isn't going to cut it.

[source,python]
----
    # There is still a text box inviting her to add another item. She
    # enters "Use peacock feathers to make a fly" (Edith is very
    # methodical)
    inputbox = self.browser.find_element_by_id('id_new_item')
    inputbox.send_keys('Use peacock feathers to make a fly')
    inputbox.send_keys(Keys.ENTER)
    table = self.browser.find_element_by_id('id_list_table')
    rows = table.find_elements_by_tag_name('tr')
    self.assertTrue(
        any(row.text == '2: Use peacock feathers to make a fly' for row in rows),
        "New to-do item did not appear in table -- its text was:\n%s" % (
            table.text,
        )
    self.fail('Finish the test!')
----

Sure enough, the functional tests error with:

AssertionError: New to-do item did not appear in table -- its text was:
1: Use peacock feathers to make a fly

Our naive solution was never going to be able to handle more than one 
list item. To persist multipe items in a list, we're going to have to
use some kind of database.





