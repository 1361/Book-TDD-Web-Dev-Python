Saving user input
-----------------

We want to take the To-Do item input from the user and send it to the server,
so that we can save it somehow and display it back to them later.

As I started writing this chapter, I immediately skipped to what I thought was
the right design: multiple models for lists and list items, a bunch of
different URLs for adding new lists and items, 3 new view functions, and about
half a dozen new unit tests for all of the above. But I stopped myself --
although I was pretty sure I was smart enough to handle all those problems at
once, the point of TDD is to allow you to do one thing at a time, when you
need to.  So I decided to be deliberately short-sighted, and at any given
moment only do what was necessary to get the functional tests a little further

It's a demonstration of how TDD can support an iterative style of development
-- it may not be the quickest route, but you do get there in the end.  There's
a neat side benefit, which is that it allows me to introduce new concepts like
models, dealing with POST requests, Django template tags and so on 'one at a
time' rather than having to dump them on you all at once.

None of this says that you 'shouldn't' try and think ahead, and be clever.  In
the next chapter we'll use a bit more design and up-front thinking, and show
how that fits in with TDD. But for now let's plough on mindlessly and just do
what the tests tell us to.



Wiring up our form to send a POST request
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

At the end of the last chapter, the tests were telling us we weren't able to
save the user's input. For now, we'll use a standard HTML POST request.  A
little boring, but also nice and easy to deliver - we can use all sorts of sexy
HTML5 and JavaScript later in the book.

To get our browser to send a POST request, we give the `<input>` element a 
`name=` attribute, wrap it in a `<form>` tag with `method="POST"`, and the
browser will take care of sending the POST request to the server for us. Let's
adjust our template at 'lists/templates/home.html':

[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
<h1>Your To-Do list</h1>
<form method="POST">
    <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
</form>

<table id="id_list_table">
----


Now, running our FTs gives us a slightly cryptic, unexpected error:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 functional_tests.py*]
[...]
Traceback (most recent call last):
  File "functional_tests.py", line 39, in
test_can_start_a_list_and_retrieve_it_later
    table = self.browser.find_element_by_id('id_list_table')
[...]
NoSuchElementException: Message: u'Unable to locate element:
{"method":"id","selector":"id_list_table"}' ; Stacktrace [...]
----

When a functional test fails with an unexpected failure, there are several
things we can do to debug them:

* Add `print` statements, to show, eg, what the current page text is
* Improve the 'error message' to show more info about the current state
* Manually visit the site yourself
* Use `time.sleep` to pause the test during execution


We'll look at all of these over the course of this book, but the `time.sleep` 
option is one I find myself using very often.  Let's try it now.  We add
the sleep just before the error occurs:


[role="sourcecode"]
.functional_tests.py
[source,python]
----
    # When she hits enter, the page updates, and now the page lists
    # "1: Buy peacock feathers" as an item in a to-do list table
    inputbox.send_keys(Keys.ENTER)

    import time
    time.sleep(10)
    table = self.browser.find_element_by_id('id_list_table')
----

Depending on how fast Selenium runs on your PC, you may have caught a glimpse
of this already, but when we run the functional tests again, we've got time to
see what's going on:  you should see a page that looks like
<<csrf_error_screenshot>>, with lots of Django debug information:


[[csrf_error_screenshot]]
.Django DEBUG page showing CSRF error
image::images/csrf_protection_error.png[Django DEBUG page showing CSRF error]

.Security: surprisingly fun!
*******************************************************************************
If you've never heard of a ``Cross-Site Request Forgery'' exploit, why not look
it up now? Like all security exploits, it's entertaining to read about, being
an ingenious use of a system in unexpected ways...

When I went back to University to take my Computer Science degree, I signed up
for the Security module out of a sense of duty:  ``Oh well, it'll probably be
very dry and boring, but I suppose I'd better take it''.  It turned out to be
one of the most fascinating modules of the whole course -- absolutely full of
the joy of hacking, of the particular mindset it takes to think about how
systems can be used in unintended ways.  I want to recommend the textbook for
my course, Ross Anderson's <<seceng,Security Engineering>>. It's quite light on
pure crypto, but it's absolutely full of interesting discussions of unexpected
topics like lock-picking, forging bank notes, inkjet printer cartridge
economics, and spoofing South African Air Force jets with replay attacks.  It's
a huge tome, about 3 inches thick, and I promise you it's an absolute
page-turner.
*******************************************************************************

Django's CSRF protection involves placing a little auto-generated token into
each generated form, to be able to identify POST requests as having come from
the original site.  So far our template has been pure HTML, and in this step we
make the first use of Django's template magic. To add the CSRF token we
use a ``template tag'' which has the curly-bracket / percent syntax, 
`{% ... %}` -- famous for being the world's most annoying two-key touch-typing
combination.


[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
<form method="POST">
    <input id="id_new_item" name="item_text" placeholder="Enter a to-do item" />
    {% csrf_token %}
</form>
----

Django will substitute that during rendering with an `<input type="hidden"`
containing the CSRF token. Re-running the functional test will now give us an
expected failure:

----
AssertionError: New to-do item did not appear in table
----

Since our `time.sleep` is still there, the test will pause on the final
screen, showing us that the new item text disappears after the form is
submitted, and the page refreshes to show an empty form again.  That's because
we haven't wired up our server to deal with the POST request yet -- it just
ignores it and displays the normal home page.

We can remove the `time.sleep` now though.

[role="sourcecode"]
.functional_tests.py
[source,python]
----
    # "1: Buy peacock feathers" as an item in a to-do list table
    inputbox.send_keys(Keys.ENTER)

    table = self.browser.find_element_by_id('id_list_table')
----


Processing a POST request on the server
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Because we haven't specified an `action=` attribute in the form, it is
submitting back to the same URL it was rendered from by default, i.e. `/`,
which is dealt with by our `home_page` function. Let's adapt the view to be
able to deal with a POST request.

That means a new unit test for the `home_page` view. Open up 'lists/tests.py',
and add a new method to `HomePageTest` - I copied the previous method,
and then adapted it to add our POST request, then check that the returned
HTML will have the new item text in it:

[role="sourcecode"]
.lists/tests.py
[source,python]
----
    def test_home_page_returns_correct_html(self):
        request = HttpRequest()
        response = home_page(request)
        expected_html = render_to_string('home.html')
        self.assertEqual(response.content, expected_html)


    def test_home_page_can_save_a_POST_request(self):
        request = HttpRequest()
        request.method = 'POST'
        request.POST['item_text'] = 'A new list item'

        response = home_page(request)

        self.assertIn('A new list item', response.content)
----

NOTE: Are you wondering about the line spacing in the test? I'm grouping
together 3 lines at the beginning which set up the test, 1 line in the middle
which actually calls the function under test, and the assertions at the end...
This isn't obligatory, but it does help see the structure of the unit test, 
which in this case is the typical one.

You can see that we're using a couple of special attributes of the
`HttpRequest`, `.method` and `.POST` (they're fairly self-explanatory,
although now might be a good time for a peek at the Django
https://docs.djangoproject.com/en/1.5/ref/request-response/[Request and
Response documentation]). Then we check that the text from our POST request
ends up in the rendered HTML. That gives us our expected fail:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
[...]
AssertionError: 'A new list item' not found in '<html> [...]
----

We can get the test to pass by adding an `if` and providing a different code
path for POST requests. In typical TDD style, we start with a deliberately
silly return value:

[role="sourcecode"]
.lists/views.py
[source,python]
----
from django.http import HttpResponse
from django.shortcuts import render

def home_page(request):
    if request.method == 'POST':
        return HttpResponse(request.POST['item_text'])
    return render(request, 'home.html')
----

That gets our unit tests passing, but it's not really what we want.  What we 
really want to do is add the POST submission to the table in the home page
template.

We've already had a hint of it, it's time to start to get to know the real
power of the Django template syntax, which is to pass variables from our Python
view code, into HTML templates.  

How do we pass a variable to a template?  We can find out by actually doing it
in the unit test -- we've already used the `render_to_string` function in a 
previous unit test to manually render a template and compare it with the HTML
the view returns.  Now let's add the variable we want to pass in:


[role="sourcecode"]
.lists/tests.py
[source,python]
----
    self.assertIn('A new list item', response.content)
    expected_html = render_to_string(
        'home.html',
        {'new_item_text':  'A new list item'}
    )
    self.assertEqual(response.content, expected_html)
----

As you can see, the `render_to_string` function takes, as its second parameter,
a mapping of variable names to values. We're giving the template a variable
named `new_item_text`, whose value is the expected item text from our
POST request.

How do we then use it in the actual template? The syntax is `{{ ... }}`, which
displays a variable as a string.

[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
<body>
    <h1>Your To-Do list</h1>
    <form method="POST" >
        <input id="id_new_item" name="item_text" placeholder="Enter a to-do item" />
        {% csrf_token %}
    </form>

    <table id="id_list_table">
        <tr><td>{{ new_item_text }}</td></tr>
    </table>
</body>
----

Now, when we run the unit test, `render_to_string` will substitute 
`{{ new_item_text }}` for ``A new list item'' inside the `<td>`. That's
something the actual view isn't doing yet, so we should see a test failure:

----
    self.assertEqual(response.content, expected_html)
AssertionError: 'A new list item' != u'<html>\n    <head>\n [...]
----

Good, our deliberately silly return value is now no longer fooling our tests,
so we are allowed to re-write our view, and tell it to pass the POST
parameter to the template:


[role="sourcecode"]
.lists/views.py
[source,python]
----
def home_page(request):
    return render(request, 'home.html', {
        'new_item_text': request.POST['item_text'],
    })
----

Running the unit tests again:

----
ERROR: test_home_page_returns_correct_html (lists.tests.HomePageTest)
[...]
    'new_item_text': request.POST['item_text'],
KeyError: 'item_text'
----

An 'unexpected failure'...  in a different test! We've got the actual test we
were working on to pass, but the unit tests have picked up an unexpected 
consequence, a regression: we broke the code path where there is no POST
request.  

This is the whole point of having tests.  Of course we could have predicted
this would happen, but imagine if we'd been having a bad day or weren't paying
attention: our tests have just saved us from accidentally breaking our
application, and, because we're using TDD, we found out immediately.  We didn't
have to wait for a QA team, or switch to a web browser and click through our
site manually, and we can get on with fixing it straight away.  Here's how:


[role="sourcecode"]
.lists/views.py
[source,python]
----
def home_page(request):
    return render(request, 'home.html', {
        'new_item_text': request.POST.get('item_text', ''),
    })
----

The unit tests should now pass.  Let's see what the functional tests say:

----
AssertionError: New to-do item did not appear in table
----

Hm, not a wonderfully helpful error.  Let's use another of our FT debugging
techniques: improving the error message.  This is probably the most
constructive, because those improved error messages stay around to help debug
any future errors:

[role="sourcecode"]
.functional_tests.py
[source,python]
----
    self.assertTrue(
        any(row.text == '1: Buy peacock feathers' for row in rows),
        "New to-do item did not appear in table -- its text was:\n%s" % (
            table.text,
        )
    )
----

That gives us a more helpful error message:

----
AssertionError: New to-do item did not appear in table -- its text was:
Buy peacock feathers
----

You know what could be even better than that?  Making that assertion a bit
less clever.  As you may remember, I was very pleased with myself for using the
`any` function, but one of my early release readers (thanks Jason!) suggested
a much simpler implementation.  We can replace the six lines of `assertTrue`
with a single `assertIn`:

[role="sourcecode"]
.functional_tests.py
[source,python]
----
    self.assertIn('1: Buy peacock feathers', [row.text for row in rows])
----

Much better.  You should always be very worried whenever you think you're being
clever, because what you're probably being is 'overcomplicated'. And we get
the error message for free:

----
    self.assertIn('1: Buy peacock feathers', [row.text for row in rows])
AssertionError: '1: Buy peacock feathers' not found in [u'Buy peacock
feathers']
----


Consider me suitably chastened.  The point is that the FT wants us to enumerate
list items with a ``1:'' at the beginning of the first list item. The fastest
way to get that to pass is with a quick ``cheating'' change to the template:


[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
    <tr><td>1: {{ new_item_text }}</td></tr>
----


.Red / Green / Refactor and Triangulation
*******************************************************************************
The unit test / code cycle is sometimes taught as ``Red, Green, Refactor'':

* Start by writing a unit test which fails (*``Red''*)
* Write the simplest possible code to get it to pass (*``Green''*), 'even if
that means cheating'
* *Refactor* to get to better code that makes more sense.

So what do we do during the Refactor stage?  What justifies moving from
an implementation where we ``cheat'' to one we're happy with?

One methodology is *eliminate duplication*: if your test uses a magic constant
(like the 1: in front of our list item), and your application code also uses
it, that counts as duplication, so it justifies refactoring. Removing the magic
constant from the application code usually means you have to stop cheating.

I find that leaves things a little too vague, so I usually like to
use a second technique, which is called *triangulation*: if your
tests let you get away with writing ``cheating'' code that you're not happy
with, like returning a magic constant, *write another test* that forces you to
write some better code.  That's what we're doing when we extend the FT to 
check that inputting a 'second' list item gives us a ``2:''

*******************************************************************************

Now we get to the `self.fail('Finish the test!')`.  If we extend our FT to 
check for adding a second item to the table (copy & paste is our friend), we
begin to see that our first cut solution really isn't going to, um, cut it.

[role="sourcecode"]
.functional_tests.py
[source,python]
----
    # There is still a text box inviting her to add another item. She
    # enters "Use peacock feathers to make a fly" (Edith is very
    # methodical)
    inputbox = self.browser.find_element_by_id('id_new_item')
    inputbox.send_keys('Use peacock feathers to make a fly')
    inputbox.send_keys(Keys.ENTER)

    # The page updates again, and now shows both items on her list
    table = self.browser.find_element_by_id('id_list_table')
    rows = table.find_elements_by_tag_name('tr')
    self.assertIn('1: Buy peacock feathers', [row.text for row in rows])
    self.assertIn(
        '2: Use peacock feathers to make a fly' ,
         [row.text for row in rows]
    )

    # Edith wonders whether the site will remember her list. Then she sees
    # that the site has generate a unique URL for her -- there is some
    # explanatory text to that effect.
    self.fail('Finish the test!')
----

Sure enough, the functional tests error with:

----
AssertionError: '1: Buy peacock feathers' not found in [u'1: Use peacock
feathers to make a fly']
----

3 strikes and refactor
~~~~~~~~~~~~~~~~~~~~~~

Before we go further -- we've got a bad ``code smell'' in this FT. We've got 3
almost identical code blocks checking for new items in the list table. There's
a principle called ``Don't repeat yourself'' (DRY), which we like to apply by
following the mantra ``3 strikes and refactor''. You can copy & paste code
once, and it may be premature to try and remove the duplication it causes, but
once you get 3 occurrences, it's time to remove duplication.

NOTE: A ``code smell'' is something about a piece of code that makes you
want to re-write it. Jeff Atwood has http://www.codinghorror.com/blog/2006/05/code-smells.html[a compilation on his blog] ``Coding Horror''. The more
experience you gain as a programmer, the more fine-tuned your nose becomes
to code smells...

We start by committing what we have so far. Even though we know our site
has a major flaw - it can only handle 1 list item - it's still further ahead
than it was. We may have to rewrite it all, and we may not, but the rule
is -- before you do any refactoring, always do a commit.

[subs="specialcharacters,quotes"]
----
$ *git diff*
# should show changes to functional_tests.py, home.html,
# tests.py and views.py
$ *git commit -a*
----

Back to our functional test refactor: we could use an inline function, but that
upsets the flow of the test slightly. Let's use a helper method -- remember,
only methods that begin with `test_` will get run as tests, so you can use
other methods for your own purposes.

[role="sourcecode"]
.functional_tests.py
[source,python]
----
    def tearDown(self):
        self.browser.quit()


    def check_for_row_in_list_table(self, row_text):
        table = self.browser.find_element_by_id('id_list_table')
        rows = table.find_elements_by_tag_name('tr')
        self.assertIn(row_text, [row.text for row in rows])


    def test_can_start_a_list_and_retrieve_it_later(self):
        [...]
----

I like to put helper methods near the top of the class, between the `tearDown`
and the first test. Let's use it in the FT:

[role="sourcecode"]
.functional_tests.py
[source,python]
----
    # When she hits enter, the page updates, and now the page lists
    # "1: Buy peacock feathers" as an item in a to-do list table
    inputbox.send_keys(Keys.ENTER)
    self.check_for_row_in_list_table('1: Buy peacock feathers')

    # There is still a text box inviting her to add another item. She
    # enters "Use peacock feathers to make a fly" (Edith is very
    # methodical)
    inputbox = self.browser.find_element_by_id('id_new_item')
    inputbox.send_keys('Use peacock feathers to make a fly')
    inputbox.send_keys(Keys.ENTER)

    # The page updates again, and now shows both items on her list
    self.check_for_row_in_list_table('2: Use peacock feathers to make a fly')
    self.check_for_row_in_list_table('1: Buy peacock feathers')

    # Edith wonders whether the site will remember her list. Then she sees
    [...]
----

We run the FT again to check that it still behaves in the same way... Good.
Now we can commit the FT refactor as its own small, atomic change:


[subs="specialcharacters,quotes"]
----
$ *git diff* # check the changes to functional_tests.py
$ *git commit -a*
----

And back to work.  If we're going to handle more than one list item ever,
we're going to need some kind of persistence, and databases are a stalwart
solution in this area.



The Django ORM & our first model
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

An Object-Relational-Mapper (ORM) is a layer of abstraction for data stored in 
a database with tables, rows and columns. It lets us work with databases using
familiar Object-Oriented metaphors which work well with code.  Classes map to 
database tables, attributes map to columns, and an individual instance of the
class represents a row of data in the database.

Django comes with an excellent ORM, and writing a unit test that uses it is
actually an excellent way of learning it, since it exercises code by specifying
how we want it to work.  

Let's create a new class in 'lists/tests.py'

[role="sourcecode"]
.lists/tests.py
[source,python]
----
from lists.models import Item
[...]

class ItemModelTest(TestCase):

    def test_saving_and_retrieving_items(self):
        first_item = Item()
        first_item.text = 'The first (ever) list item'
        first_item.save()

        second_item = Item()
        second_item.text = 'Item the second'
        second_item.save()

        saved_items = Item.objects.all()
        self.assertEqual(saved_items.count(), 2)

        first_saved_item = saved_items[0]
        second_saved_item = saved_items[1]
        self.assertEqual(first_saved_item.text, 'The first (ever) list item')
        self.assertEqual(second_saved_item.text, 'Item the second')
----


You can see that creating a new record in the database is a relatively simple
matter of creating an object, assigning some attributes, and calling a
`.save()` function.  Django also gives us an API for querying the database via
a class method, `.objects`, and we use the simplest possible query, `.all()`,
which retrieves all the records for that table.  The results are returned as a
list-like object called a QuerySet, which we can call further functions on,
like `.count()`, and also extract individual objects. We then check the objects
as saved to the database, to check whether the right information was saved

Django's ORM has many other helpful and intuitive features, this might be a
good time to skim through the
https://docs.djangoproject.com/en/1.5/intro/tutorial01/#playing-with-the-api[Django
Tutorial] which has an excellent intro to them. 

Let's try running the unit test. Here comes another unit test/code cycle

----
ImportError: cannot import name Item
----

OK then, let's give it something to import from 'lists/models.py'.  We're
feeling confident so we'll skip the `Item = None` step, and go straight to
creating a class:

[role="sourcecode"]
.lists/models.py
[source,python]
----
from django.db import models

class Item(object):
    pass
----

That gets our test as far as: 

----
    first_item.save()
AttributeError: 'Item' object has no attribute 'save'
----

To give our `Item` class a `save` method, we make it inherit from the Django
`Model` class:


[role="sourcecode"]
.lists/models.py
[source,python]
----
from django.db import models

class Item(models.Model):
    pass
----

Now the test actually gets surprisingly far:

----
    self.assertEqual(first_saved_item.text, 'The first (ever) list item')
AttributeError: 'Item' object has no attribute 'text'
----

That's a full 8 lines later than the last failure -- we've been all the way
through saving the two Items, we've checked they're saved in the database, but
Django just doesn't seem to have remembered the `.text` attribute.

Classes that inherit from `models.Model` map to tables in the database.  By
default they get an auto-generated `id` attribute which will be a primary key
column in the database, but you have to define any other columns you want
explicitly. Here's how we set up a text field:


[role="sourcecode"]
.lists/models.py
[source,python]
----
class Item(models.Model):
    text = models.TextField()
----

Django has many other field types, like `IntegerField`, `CharField`,
`DateField` and so on.  I've chosen `TextField` rather than `CharField` because
the latter requires a length restriction which seems arbitrary at this point.
You can read more on field types in the Django
https://docs.djangoproject.com/en/1.5/intro/tutorial01/#creating-models[tutorial]
and in the
https://docs.djangoproject.com/en/1.5/ref/models/fields/[documentation].

In any case, the unit tests now pass, so let's do a commit for our first ever
model!

[subs="specialcharacters,quotes"]
----
$ *git status* # see tests.py and models.py have changed
$ *git diff* # see actual changes to tests.py and models.py
$ *git commit -am"Created model for list Items"*
----


Saving the POST to the database
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's adjust the test for our home page POST request, and say we want the view
to save a new item to the database. We can do that by adding 3 new lines (%1%)
to the existing test called `test_home_page_can_save_a_POST_request`


[role="sourcecode"]
.lists/tests.py
[source,python]
----
def test_home_page_can_save_a_POST_request(self):
    request = HttpRequest()
    request.method = 'POST'
    request.POST['item_text'] = 'A new list item'

    response = home_page(request)

    self.assertEqual(Item.objects.all().count(), 1) #<1>
    new_item = Item.objects.all()[0]
    self.assertEqual(new_item.text, 'A new list item')

    self.assertIn('A new list item', response.content)
    expected_html = render_to_string(
        'home.html',
        {'new_item_text':  'A new list item'}
    )
    self.assertEqual(response.content, expected_html)
----


This test is getting a little long-winded.  It seems to be testing lots of
different things.  That's another 'code smell' -- a long unit test either needs
to be broken into two, or it may be an indication that the thing you're testing
is too complicated.  Let's add that to a little to-do list of our own, perhaps
on a piece of scrap paper:

* Don't save blank items for every request

Writing it down reassures us that we won't forget, so we are comfortable
getting back to what we were working on.  We re-run the tests and see
an expected failure:

----
    self.assertEqual(Item.objects.all().count(), 1)
AssertionError: 0 != 1
----

Let's adjust our view:

[role="sourcecode"]
.lists/views.py
[source,python]
----
from django.shortcuts import render
from lists.models import Item

def home_page(request):
    item = Item()
    item.text = request.POST.get('item_text', '')
    item.save()

    return render(request, 'home.html', {
        'new_item_text': request.POST.get('item_text', ''),
    })
----

I've coded a very naive solution and you can probably spot a very obvious
problem, which is that we're going to be saving empty items with every request
to the home page.  Let's add that to our list of things to fix later.  You
know, along with the painfully obvious fact that we currently have no way at
all of having different lists for different people.  That we'll keep ignoring
for now. La la la la...

Remember, I'm not saying you should always ignore glaring problems like this in
``real life''. Whenever we spot problems in advance, there's a judgement call
to make over whether to stop what you're doing and start again, or leave them
until later.  Sometimes finishing off what you're doing is still worth it, and
sometimes the problem may be so major as to warrant a stop and re-think.

But the point is that we 'don't' always spot problems in advance, and sometimes
the implications aren't obvious.  What I'm demonstrating here is the way that
TDD can help guide you to the right answer, even when you don't catch
problems in advance.

Let's see how the unit tests get on... They pass!  Good.  We can do a bit of
refactoring:

[role="sourcecode"]
.lists/views.py
[source,python]
----
    return render(request, 'home.html', {
        'new_item_text': item.text
    })
----

Let's have a little look at our own to-do list. I've added a couple of the 
other things that are on our mind:

* Don't save blank items for every request
* Code smell: POST test is too long?
* Display multiple items in the table
* Support more than one list!

Let's start with the first one.  We could tack on an assertion to an existing
test, but it's best to keep unit tests to testing one thing at a time, so let's
add a new one:

[role="sourcecode"]
.lists/tests.py
[source,python]
----
class HomePageTest(TestCase):
    [...]

    def test_home_page_only_saves_items_when_necessary(self):
        request = HttpRequest()
        home_page(request)
        self.assertEqual(Item.objects.all().count(), 0)
----

That gives us a `1 != 0` failure.  Let's fix it.  Watch out, although it's
quite a small change to the logic of the view, there are quite a few little
tweaks to the implementation in code:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def home_page(request):
    if request.method == 'POST':
        new_item_text = request.POST['item_text'] # <1>
        Item.objects.create(text=new_item_text) # <2>
    else:
        new_item_text = '' <1>

    return render(request, 'home.html', {
        'new_item_text': new_item_text, <1>
    })
----

<1> we use a variable called `new_item_text`, which will either
hold the POST contents, or the empty string
<2> `.objects.create` is a neat shorthand for creating a new `Item`, without
needing to call `.save()`. 

And that gets the test passing.

Redirect after a POST
~~~~~~~~~~~~~~~~~~~~~

But, yuck, that whole `new_item_text = ''` dance is making me pretty unhappy.
Thankfully the next item on the list gives us a chance to fix it.
https://en.wikipedia.org/wiki/Post/Redirect/Get[Always redirect after a POST],
they say, so let's do that:

[role="sourcecode"]
.lists/tests.py
[source,python]
----
    def test_home_page_can_save_a_POST_request(self):
        request = HttpRequest()
        request.method = 'POST'
        request.POST['item_text'] = 'A new list item'

        response = home_page(request)

        self.assertEqual(Item.objects.all().count(), 1)
        new_item = Item.objects.all()[0]
        self.assertEqual(new_item.text, 'A new list item')

        self.assertEqual(response.status_code, 302)
        self.assertEqual(response['location'], '/')
----

We no longer expect a response with a `.content` rendered by a template, so we
lose the assertions that look at that.  Instead, the response will represent
an HTTP 'redirect', which should have status code 302, and points the browser
towards a new location.

That gives us the error `200 != 302`.  We can now tidy up our view
substantially:

[role="sourcecode"]
.lists/views.py
[source,python]
----
from django.shortcuts import redirect, render
from lists.models import Item

def home_page(request):
    if request.method == 'POST':
        Item.objects.create(text=request.POST['item_text'])
        return redirect('/')

    return render(request, 'home.html')
----

And the tests should now pass.

Rendering items in the template
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Much better!  Back to our to-do list:

* ¬Don't save blank items for every request¬
* ¬Code smell: POST test is too long?¬
* Display multiple items in the table
* Support more than one list!

Crossing things off the list is almost as satisfying as seeing tests pass!

The third item is the last of the ``easy'' ones. Let's have a new unit test
that checks that the template can also display multiple list items:

[role="sourcecode"]
.lists/tests.py
[source,python]
----
class HomePageTest(TestCase):
    [...]

    def test_home_page_displays_all_list_items(self):
        Item.objects.create(text='itemey 1')
        Item.objects.create(text='itemey 2')

        request = HttpRequest()
        response = home_page(request)

        self.assertIn('itemey 1', response.content)
        self.assertIn('itemey 2', response.content)
----

That fails as expected:

----
AssertionError: 'itemey 1' not found in '<html>\n    <head>\n [...]
----

The Django template syntax has a tag for iterating through lists,
 `{% for .. in .. %}`, we can use it like this:


[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
<table id="id_list_table">
    {% for item in items %}
        <tr><td>1: {{ item.text }}</td></tr>
    {% endfor %}
</table>
----

This is one of the major strengths of the templating system. Now the template
will render with multiple `<tr>` rows, one for each item in the variable
`items`.  Pretty neat!  I'll introduce a few more bits of Django template
magic as we go, but at some point you'll want to go and read up on the rest of
them in the https://docs.djangoproject.com/en/1.5/topics/templates/[Django
Docs]

Just changing the template doesn't get our tests to pass, we need to actually
pass the items to it from our home page view:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def home_page(request):
    if request.method == 'POST':
        Item.objects.create(text=request.POST['item_text'])
        return redirect('/')

    items = Item.objects.all()
    return render(request, 'home.html', {'items': items})
----

That does get the unit tests to pass... Moment of truth, will the functional
test pass?

----
[...] (lots of traceback!
AssertionError: 'To-Do' not found in u'ImproperlyConfigured at /'
----

Oops, apparently not.  Let's use another functional test debugging technique,
and it's one of the most straightforward: manually visiting the site!  Open
up 'http://localhost:8000' in your web browser, and you'll see a Django debug
page saying:

----
Please fill out the database NAME in the settings module before using the
database.
----

Creating our production database with syncdb
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Another helpful error message from Django, which is basically complaining that
we haven't set up the database properly.  How come everything worked fine
in the unit tests, I hear you ask?  Because Django creates a special 'test
database' for unit tests, it's one of the magical things that Django's 
`TestCase` does.  

To set up our ``real'' database, we need to tell Django where it is -- sqlite
databases are a single file on disk. We tell Django where we want that file
to be in 'superlists/settings.py':

[role="sourcecode"]
.superlists/settings.py
[source,python]
----
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', 
        'NAME': 'database.sqlite',
[...]
----

If we try reloading the page on localhost at this point, it will tell us
that there is a `DatabaseError`, `no such table: lists_item`.  We have a 
database, but no tables in it yet. We've told Django everything it needs 
to know how to create them in 'models.py' though, so we just need to tell
it to make it using another Django Swiss army knife `manage.py`
commands ,`syncdb`:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py syncdb*]
Creating tables ...
Creating table auth_permission
Creating table auth_group_permissions
Creating table auth_group
Creating table auth_user_user_permissions
Creating table auth_user_groups
Creating table auth_user
Creating table django_content_type
Creating table django_session
Creating table django_site
Creating table lists_item

You just installed Django's auth system, which means you don't have any
superusers defined.
Would you like to create one now? (yes/no):
pass:quotes[*no*]
Installing custom SQL ...
Installing indexes ...
Installed 0 object(s) from 0 fixture(s)
----

I said "no" to the question about superusers -- we don't need one yet, but we
will look at it in a later chapter. For now we can refresh the page on
'localhost', see that our error is gone, and try running the functional tests
again.

----
AssertionError: '2: Use peacock feathers to make a fly' not found in [u'1: Buy
peacock feathers', u'1: Use peacock feathers to make a fly']
----

Oooh, so close!  We just need to get our list numbering right.  Another awesome
Django template tag will help here: `forloop.counter`:

[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
    {% for item in items %}
        <tr><td>{{ forloop.counter }}: {{ item.text }}</td></tr>
    {% endfor %}
----


If you try it again, you should now see the FT get to the end:

----
    self.fail('Finish the test!')
AssertionError: Finish the test!
----

But, as it's running, you may notice something is amiss, like in
<<items_left_over_from_previous_run>>:


[[items_left_over_from_previous_run]]
.There are list items left over from the last run of the test
image::images/need_some_test_isolation.png[There are list items left over from the last run of the test]


Oh dear. It looks like previous runs of the test are leaving stuff lying around
in our database.  In fact, if you run the tests again, you'll see it gets
worse: 

----
1: Buy peacock feathers
2: Use peacock feathers to make a fly
3: Buy peacock feathers
4: Use peacock feathers to make a fly
5: Buy peacock feathers
6: Use peacock feathers to make a fly
----

Grrr.  We're so close! We're going to need some kind of automated way of
tidying up after ourselves. For now, if you feel like it, you can do it
manually, by deleting the database and re-creating it fresh with `syncdb`:

[subs="specialcharacters,quotes"]
----
$ *rm database.sqlite*
$ *python3 manage.py syncdb --noinput*
----

And then reassure yourself that the FT still passes.

Apart from that little bug in our functional testing, we've got some code
that's more or less working.  Let's do a commit.  Start by doing a *`git
status`* and a *`git diff`*, and you should see changes to 'home.html',
'tests.py', 'views.py' and 'settings.py'.  Of those, the first three belong
together, whereas adding the database name to settings.py probably belongs
separately.  We'll also want to add the database file to our list of ignored 
files:

[subs="specialcharacters,quotes"]
----
$ *git add lists*
$ *git commit -m"Redirect after POST, and show all items in template"*
$ *git add superlists/settings.py*
$ *echo "database.sqlite" >> .gitignore*
$ *git add .gitignore*
$ *git commit -m"Name database in settings.py, add it to .gitignore"*
----

Where are we?  

* We've got a form set up to add new items to the list using POST.
* We've set up a simple model in the database to save list items.
* We've used at least 3 different FT debugging techniques.

But we've got a couple of items on our own to-do list, namely getting the FT to
clean up after itself, and perhaps more critically, adding support for more
than one list.  

I mean, we 'could' ship the site as it is, but people might find it
strange that the entire human population has to share a single to-do list.  I
suppose it might get people to stop and think about how connected we all are to
one another, how we all share a common destiny here on spaceship Earth, and how
we must all work together to solve the global problems that we face.  

But, in practical terms, the site wouldn't be very useful...

Ah well.

.Useful TDD concepts
*******************************************************************************

Regression::
    When new code breaks some aspect of the application which used to work.

Unexpected failure::
    When a test fails in a way we weren't expecting.  This either means that
    we've made a mistake in our tests, or that the tests have helped us find
    a regression, and we need to fix something in our code.

Red / Green / Refactor::
    Another way of describing the TDD process. Write a test and see it fail
    (Red), write some code to get it to pass (Green), then Refactor to improve
    the implementation.

Triangulation::
    The act of writing extra test code in order to make sure that our 
    implementation is correct.

3 strikes and refactor::
    A rule of thumb for when to remove duplication from code.

The scratchpad to-do list::
    A place to write down things that occur to us as we're coding, so that
    we can finish up what we're doing and come back to them later.

*******************************************************************************

