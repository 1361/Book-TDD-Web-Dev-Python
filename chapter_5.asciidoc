Chapter 5 - Saving user form submissions
--------------------------------------

We want to take the To-Do item input from the user and send it to the server,
so that we can save it and display it back to them later.  That forces us to 
start to think about exactly how we might want to do that.  For now, we'll 
use a fairly standard HTML form and POST request, and save the data using a
database.  A little boring, but also nice and easy to deliver - we can use all
sorts of sexy HTML5 and JavaScript later in the book.


Small Design When Necessary
~~~~~~~~~~~~~~~~~~~~~~~~~~~

TDD grew out of the agile movement in software, which in part included a strong
reaction against ``Big Design Up-Front'' -- the traditional software
development step where, after a lengthy requirements gathering exercise, there
was an equally lengthy design stage where the software was planned out on
paper. Instead, agile methodologies suggest that we spend minimal time on
up-front design, and instead let the design evolve gradually based on feedback
from real users.  To get that feedback, we try and put a minimum viable
application in front of them as soon as possible.

But that doesn't mean no thinking about design at all!  So, let's think about
our minimum viable lists app, and what kind of design we'll need to deliver it.

* We want each user to be able to store their own list - at least one, for now.
* A list is made up of several items, whose primary attribute is a bit of 
descriptive text
* We need to save lists from one visit to the next.  For now, we can give 
each user a unique URL for their list.  Later on we may want some way of
automatically recognising users and showing them their lists.

To deliver the ``for now'' items then, it sounds like we're going to store
lists and their items in a database.  Each list will have a unique URL,
and each list item will be a bit of descriptive text, associated with a
particular list.

All sorts of other thoughts are occurring to us as well -- we might want to
give each lists a name or title, we might want to recognise users using
usernames and passwords, we might want to add a longer notes field as well as
short descriptions to our list, we might want to store some kind of ordering, 
and so on.  


Form input
~~~~~~~~~~

To get our browser to send a POST request, we can wrap the `<input>` element in
a `<form>` tag with `method="POST"`, and the browser will take care of sending
the POST request for us.  But it does mean we have to decide what URL the POST
request should go to, and what view should deal with it.

One option is to have the same view that rendered our home page also deal with 
POST requests.  I think it keeps things simpler and clearer to separate the job
out to a separate view, with a separate URL, say '/lists/new'.  That would make
our form (in 'polls/templates/home.html') look like this:


[source,html]
----
    <h1>Your To-Do list</h1>
    <form method="POST" action="/lists/new">
        <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
    </form>

    <table id="id_list_table">
----

Notice the other thing we had to add, which was the `name="item_text"`
attribute on the input element. Now, running our FTs gives us a slightly
cryptic, unexpected error:

----
Traceback (most recent call last):
  File "functional_tests.py", line 38, in test_can_start_a_list_and_retrieve_it_later
    table = self.browser.find_element_by_id('id_list_table')
[...]
NoSuchElementException: Message: u'Unable to locate element:
{"method":"id","selector":"id_list_table"}' ;
----

When a functional test fails with an unexpected failure, there are several
things we can do to debug them:

* add `print` statements, to show, eg, what the current page text is
* improve the error message to show more info about the current state
* manually visit the site yourself
* use `time.sleep` to pause the test during execution


We'll look at all of these over the course of this book, but the `time.sleep` 
option is the one I find myself using the most.  Let's try it now.  We add
the sleep just before the error occurs:


[source,python]
----
    # When she hits enter, the page updates, and now the page lists
    # "1: Buy peacock feathers" as an item in a to-do list table
    inputbox.send_keys(Keys.ENTER)

    import time
    time.sleep(10)
    table = self.browser.find_element_by_id('id_list_table')
----

When we run the functional tests again, we've got time to see what's going on -
you should see a page that looks like <<404_screenshot>>, with lots of Django
debug information:


[[404_screenshot]]
.A 404 error with Django DEBUG=True
image::images/404_on_lists_new.png[A 404 error with Django DEBUG=True]

Now we can figure out what happened -- our form is now wired up to send data
to '/lists/new', but there's no such page yet!  Let's build a new URL and view
for it.


A new URL and view, using the Django Test Client
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

I've shown you how to write separate unit tests for URLs and views.  Django
also provides you with a tool that can do both at once, called the 'Django
Test Client'.  You can choose which approach you prefer - the Django Test 
client does have some helpful attributes, but it sometimes feels a bit too 
much like magic, and I thought it would be best to start with the low-level
tools first.

Open up a new class in 'polls/tests.py':



