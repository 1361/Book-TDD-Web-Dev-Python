Getting to the minimum viable site
----------------------------------

We ended the last chapter with a classic testing problem:  how to ensure
'isolation' between tests.  When we run unit tests, the Django test runner
automatically creates a brand new test database (separate from the production
one), and resets it before each individual test is run.  But our functional
tests currently run against the ``real'' database. 

Ensuring test isolation in functional tests
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are two ways we could tackle this.  One is to `roll our own'' solution:
we use the `setUp` and `tearDown` methods from `unittest` to create a fresh
database and reset it between each test.  In an old tutorial I wrote, I managed
it using a combination of:

* creating a 'settings_for_fts.py' which imports everything from 'settings.py',
but changes the `DATABASES` entry to have a different `NAME`
* in `setUp`, use `subprocess.Popen` to spin up the Django `manage.py
runserver`, passing in `settings=settings_for_fts`.
* use `django.core.management.setup_environ` with `settings_for_fts` to load
Django for our test database
* Then we can do things like `django.core.management.call_command("syncdb")`,
as well as add any test data to the database.
* `tearDown` would kill the server and delete the database file after each
test.

You can explore the implementation at my Github page for the
Test-Driven-Django-Tutorial, on a tag called https://github.com/hjwp/Test-Driven-Django-Tutorial/blob/old-ft-runner/mysite/functional_tests.py[old-ft-runner]

Since Django 1.4 though, there's a new class called `LiveServerTestCase` which
does a lot of this work for you, automatically, essentially just like the unit
tests runs.  Although it has some limitations and we'll probably need to move
off it later, it's a useful tool at this stage, so let's check it out.

`LiveServerTestCase` expects to be run by the Django test runner, so the
first step is to create a new Django app to hold our functional tests.

[subs="specialcharacters,quotes"]
----
$ *python manage.py startapp fts*
----

NOTE: You could mix your functional tests into the tests for the 'lists' app.
I tend to prefer to keep them separate, because functional tests usually have
cross-cutting concerns that run across different apps.

Then we move our functional tests, from being a standalone file, to being
the tests of the `fts` app.  We use *`git mv`* so that git
notices that we've moved the file:

[subs="specialcharacters,quotes"]
----
$ *git mv -f functional_tests.py fts/tests.py*
$ git status # should show the "rename"
----

At this point your directory tree should look like this:

----
├── database.sqlite
├── fts
│   ├── __init__.py
│   ├── models.py
│   ├── tests.py
│   └── views.py
├── lists
│   ├── __init__.py
│   ├── __init__.pyc
│   ├── models.py
│   ├── templates
│   │   └── home.html
│   ├── tests.py
│   └── views.py
├── manage.py
└── superlists
    ├── __init__.py
    ├── settings.py
    ├── urls.py
    └── wsgi.py
----


Now let's edit 'fts/tests.py' to make it use LiveServerTestCase:

[source,python]
----
from django.test import LiveServerTestCase <1>
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

class NewVisitorTest(LiveServerTestCase): <2>

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.browser.implicitly_wait(3)

    def tearDown(self):
        self.browser.quit()

    def test_can_start_a_list_and_retrieve_it_later(self):
        # Edith has heard about a cool new online to-do app. She goes
        # to check out its homepage
        self.browser.get(self.live_server_url) <3>

        [...]
# also remove the if __name__ == '__main__' from the end <4>
----

We've changed the `import` <1> at the top, the `class` <2>, and the 
`self.browser.get`, which now uses `self.live_server_url` <3>, an attribute that
`LiveServerTestCase` will populate for us when it starts up the server.  We also
remove the runner from the end -- 'manage.py' will take care of that for us.

And finally, we add `fts` as a new app in 'settings.py':

[source,python]
----
INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Uncomment the next line to enable the admin:
    # 'django.contrib.admin',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
    'lists',
    'fts',
)
----

Now we should be able to run our functional tests using the Django 
test runner, by telling it to run just the tests for our new `fts` app:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test fts*]
Creating test database for alias 'default'...
Traceback (most recent call last):
  [...]
  File "/usr/lib/python2.7/wsgiref/handlers.py", line 85, in run
    template, origin = find_template(template_name)
  File "/usr/local/lib/python2.7/dist-packages/django/template/loader.py", line 138, in find_template
    raise TemplateDoesNotExist(name)
TemplateDoesNotExist: 500.html
F
======================================================================
FAIL: test_can_start_a_list_and_retrieve_it_later (fts.tests.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/media/SHARED/Dropbox/book/source/chapter_6/superlists/fts/tests.py", line 74, in test_can_start_a_list_and_retrieve_it_later
    self.fail('Finish the test!')
AssertionError: Finish the test!

 ---------------------------------------------------------------------
Ran 1 test in 6.378s

FAILED (failures=1)
Destroying test database for alias 'default'...
----

Well, despite that ugly `TemplateDoesNotExist: 500` traceback, which we'll look
at in a moment,  the FT actually got through to its expected `self.fail`.
That's worthy of a commit:

[subs="specialcharacters,quotes"]
----
$ *git status* # see rename, modified fts/tests.py, settings.py, and new files
$ *git add fts*
$ *git add superlists/settings.py*
$ *git diff --staged -M*
$ *git commit*  # msg eg "move functional_tests to fts app, use LiveServerTestCase"
----

The `-M` flag on the `git diff` is a useful one. It means "detect moves", so it
will notice that `functional_tests.py` and `fts/tests.py` are the same file,
and show you a more sensible diff...

Now let's move on to thinking about how we want support for multiple lists to
work.  Currently the FT (which is the closest we have to a design document)
says this:

[source,python]
----
    # Edith wonders whether the site will remember her list. Then she sees
    # that the site has generate a unique URL for her -- there is some
    # explanatory text to that effect.
    self.fail('Finish the test!')

    # She visits that URL - her to-do list is still there.

    # Satisfied, she goes back to sleep
----

But really we want to expand on this, by saying that different users
don't see each other's lists, and each get their own URLs as a way of
going back to their saved lists.


Small Design When Necessary
~~~~~~~~~~~~~~~~~~~~~~~~~~~

TDD is closely associated with the agile movement in software development,
which includes a strong reaction against ``Big Design Up-Front'': the
traditional software engineering practice whereby, after a lengthy requirements
gathering exercise, there was an equally lengthy design stage where the
software was planned out on paper. The philosophy is that you learn more from
solving problems in practice than in theory, especially when you confront your
application with real-world uses as soon as possible. Agile methodologies
suggest that we spend minimal time on up-front design, and instead let the
design evolve gradually based on feedback from real users.  To get that
feedback, we try and put a minimum viable application in front of them as soon
as possible.

But that doesn't mean that thinking about design is outright banned! In the
last chapter we saw how just blundering ahead without thinking can 'eventually'
get us to the right answer, but often a 'little' thinking about design can help
us get there faster. So, let's think about our minimum viable lists app, and
what kind of design we'll need to deliver it.

* We want each user to be able to store their own list - at least one, for now.
* A list is made up of several items, whose primary attribute is a bit of 
descriptive text
* We need to save lists from one visit to the next.  For now, we can give 
each user a unique URL for their list.  Later on we may want some way of
automatically recognising users and showing them their lists.

To deliver the ``for now'' items then, it sounds like we're going to store
lists and their items in a database.  Each list will have a unique URL,
and each list item will be a bit of descriptive text, associated with a
particular list.

YAGNI
^^^^^

All sorts of other thoughts are occurring to us as well -- we might want to
give each lists a name or title, we might want to recognise users using
usernames and passwords, we might want to add a longer notes field as well as
short descriptions to our list, we might want to store some kind of ordering,
and so on.  But we obey another tenet of the agile gospel:  ``YAGNI''
(pronounced yag-knee), which stands for ``You ain't gonna need it''.  As 
software developers, we have an urge to create things, and sometimes it's
hard to resist the urge to build things just because an idea occurred to us
and we 'might' need it.  The trouble is that 9 times out of 10, no matter how
cool the idea was, you won't end up using it, and you've ended up with a load
of unused code, adding to the complexity of your application. YAGNI is the 
mantra we use to resist our overenthusiastic creative urges.

So we have an idea of the data structure we want (the ``Model'' part of 
Model-View-Controller (MVC).  What about the view and controller part? 
How should the user interact with Lists and their Items using a web browser?


REST
^^^^

Representational State Transfer (REST) is an approach to web design that's 
usually used to guide the design of web-based APIs, but it's often a 
helpful guide to how to structure your site in general (although trying to
stick to the REST rules too strictly is probably a mistake, when designing
a user-facing site rather than an API).

REST suggests that we have a URL structure that matches our data structure,
in this case, lists and list items.  Each list can have its own URL, like

`/lists/<list identifier>/`

That will fulfil the requirement we've specified in our FT. To view a list, we
use a GET request (a normal browser visit to the page)

To create a brand new list, we'll have a special URL that accepts POST
requests:

`/lists/new`

To add a new item to an existing list, we'll have a separate URL, to which
we can send POST requests.

`/lists/<list identifier>/add_item`

In summary, our to-do list looks something like this:

* Adjust model so that items are associated with different lists
* Add unique URLs for each list
* Add a URL for creating a new list via POST
* Add URLs for adding a new item to an existing list via POST

Let's translate this thinking to our functional test.  As soon as Edith
submits a first list item, we'll want to create a new list, adding one
item to it, and take her to the URL for her list.  That's around line 35:


[source,python]
----
    # When she hits enter, she is taken to a new URL,
    # and now the page lists "1: Buy peacock feathers" as an item in a
    # to-do list table
    inputbox.send_keys(Keys.ENTER)
    edith_list_url = self.browser.current_url
    self.assertRegexpMatches(edith_list_url, '/lists/.+')

    table = self.browser.find_element_by_id('id_list_table')
    [...]
----


Now let's change the end of the test and imagine a new user coming along.
We want to check that they don't see any of Edith's items when they visit
the home page, and that they get their own unique URL for their list.

Delete everything from the comment at line 74 ("Edith wonders..."), and 
replace it with:


[source,python]
----
    # Now a new user, Francis, comes along to the site.
    self.browser.quit()
    ## We use a new browser session to make sure that no information
    ## of Edith's is coming through from cookies etc
    self.browser = webdriver.Firefox()

    # Francis visits the home page.  There is no sign of Edith's
    # list
    self.browser.get(self.live_server_url)
    page_text = self.browser.find_element_by_tag_name('body').text
    self.assertNotIn('Buy peacock feathers', page_text)
    self.assertNotIn('make a fly', page_text)

    # Francis starts a new list by entering a new item. He 
    # is less interesting than Edith...
    inputbox = self.browser.find_element_by_id('id_new_item')
    inputbox.send_keys('Buy milk')
    inputbox.send_keys(Keys.ENTER)

    # Francis gets his own unique URL
    francis_list_url = self.browser.current_url
    self.assertRegexpMatches(francis_list_url, '/lists/.+')
    self.assertNotEqual(francis_list_url, edith_list_url)

    # Again, there is no trace of Edith's list
    page_text = self.browser.find_element_by_tag_name('body').text
    self.assertNotIn('Buy peacock feathers', page_text)
    self.assertIn('Buy milk', page_text)
----

`assertRegexpMatches` is a new function, we use it to check our new REST design
has been implemented.  Other than that, our changes are fairly straightforward.
Let's see how they do when we run our FTs:

----
AssertionError: Regexp didn't match: '/lists/.+' not found in
u'http://localhost:8081/'
----


As expected.  Let's do a commit, and then go and build some new models
and views.

[subs="specialcharacters,quotes"]
----
$ *git commit -a* 
----

NOTE: I found the FTs hung when I tried to run them today.  It turns out I
needed to upgrade Selenium, with a `pip install --upgrade selenium`. It's
only been a couple of months since I last upgraded, and Selenium had gone up
by 6 point versions.  There's no standing still!


Iterating towards the new design
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Being all excited about our new design, I had an overwhelming urge to dive in
at this point and start changing 'models.py', which would have broken half the
unit tests, and then pile in and change almost every single line of code, all
in one go.  Obey the Testing Goat, not Refactoring Cat!  We don't need to
implement our new, shiny design in a single big bang. Let's make small changes
that take us from a working state to a working state, with our design guiding
us gently at each stage.

We'll start by adjusting our URLs to be more in line with our design, since
that's what the FT is currently stuck on: it's complaining that the URL you get
taken to after starting a list isn't a list URL.  So let's start by fixing that
-- it's the redirect after POST.  In 'lists/tests.py', find
`test_home_page_can_save_a_POST_request`, and change the expected redirect 
location:

[source,python]
----
    self.assertEqual(response.status_code, 302)
    self.assertEqual(response['location'], '/lists/the-only-list-in-the-world/')
----

That gets us an expected fail

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test lists*]
[...]
AssertionError: '/' != '/lists/the-only-list-in-the-world/'
----

Now we can go adjust our `home_page` view in 'lists/views.py':

[source,python]
----
def home_page(request):
    if request.method == 'POST':
        Item.objects.create(text=request.POST['item_text'])
        return redirect('/lists/the-only-list-in-the-world/')
----

Of course that will now break the functional test, because there is no such
URL on our site yet.  Sure enough, if you run them, you'll find they fail
just after trying to submit the first item.

TODO: mention fact that fts now run with DEBUG=False?

So, let's build a special URL for our one and only list (it's a problem-solving
technique: you need something that works for N objects, you currently have
nothing (ie something that works for 0 objects). Solving for 1 object is a good
step forwards)


Testing views, templates and URLs together with the Django Test Client
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


In previous chapters I've shown how you can test your URL resolution 
explicitly, and how to test view functions by actually calling them, and 
checking that they render your templates correctly too.  Django actually
provides us with a little tool that can do all three, which we'll use now.

I wanted to show you how to "roll your own" first, partially because it's
a better introduction to how Django works, but also because those techniques
are portable -- you may not always use Django, but you'll almost always have
view functions, templates and URL mappings, and you now know how to test them.

So let's use the Django Test Client.  Open up 'lists/tests.py', add `Client` to
the list of things we import from `django.test`, and then add a new test class
called `ListViewTest`.  Then, lets copy the method called
`test_home_page_displays_all_list_items` across from `HomePageTest`, and adapt
it slightly:

[source,python]
----
from django.test import Client, TestCase
[...]


class ListViewTest(TestCase):

    def test_list_view_displays_all_items(self):
        Item.objects.create(text='itemey 1')
        Item.objects.create(text='itemey 2')

        client = Client()
        client.get('/lists/the-only-list-in-the-world/')

        self.assertIn('itemey 1', response.content)
        self.assertIn('itemey 2', response.content)

----

Instead of calling the view function directly, we instantiate a test client
with `Client()`, and then we call `.get` with the URL we're testing -- it's 
actually a very similar API to the one that Selenium uses. Let's try running
the test now:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test lists*]
[...]
======================================================================
ERROR: test_list_view_displays_all_items (lists.tests.ListViewTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/media/SHARED/Dropbox/book/source/chapter_6/superlists/lists/tests.py", line 63, in test_list_view_displays_all_items
    response = client.get('/lists/the-only-list-in-the-world/')
  File "/usr/local/lib/python2.7/dist-packages/django/test/client.py", line 439, in get
  [...]
  File "/usr/local/lib/python2.7/dist-packages/django/views/defaults.py", line 20, in page_not_found <1>
    t = loader.get_template(template_name) # You need to create a 404.html template.<2>
  File "/usr/local/lib/python2.7/dist-packages/django/template/loader.py", line 145, in get_template
    template, origin = find_template(template_name)
  File "/usr/local/lib/python2.7/dist-packages/django/template/loader.py", line 138, in find_template
    raise TemplateDoesNotExist(name)
TemplateDoesNotExist: 404.html

 ---------------------------------------------------------------------
Ran 7 tests in 0.058s

FAILED (errors=1)

----

You can see that the Django Test Client goes through much more of the Django
stack than our other unit tests do -- it's gone through the URL resolution
part of the stack (which we used to call separately via `resolve`), and
come to the conclusion that the URL doesn't exist when it gets to the 
view in 'defaults.py' called `page_not_found` <1>.  Following on the rest of
the traceback, you can see it then tries to load a 404 template, but it can't
find one and so raises a `TemplateDoesNotExist` error.  There's even one of
Django's classic helpful comments telling us that we need to create one at <2>


Creating 404 and 500 templates
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Although we could skip this step, maybe we should take advantage of this
gentle prompt from the tests to create some minimal 404 and 500 templates. 
You'll remember the functional tests were complaining about not having a
500 template too, and it was creating a lot of messy output on the
command-line. Here is how to create some extremely simple ones:

[subs="specialcharacters,quotes"]
----
$ *echo "500 Server Error.  This shouldn't happen :-/" > lists/templates/500.html*
$ *echo "404 Page not found. Try another URL." > lists/templates/404.html*
----

Let's try re-running our unit tests now?

    AssertionError: 'itemey 1' not found in '404 Page not found. Try another URL.\n'

And if you try running the functional tests, you'll still see the same error,
but at least all the ugly traceback complaining about a missing 500 page will
be gone.

Let's add those two templates, on their own, as a commit:


[subs="specialcharacters,quotes"]
----
$ *git status*  # should show 2 changed and 2 new files
$ *git add lists/templates* 
$ *git status*  # should show 2 changed and 2 new files
$ *git commit -m"Minimal 404 and 500 templates"*
----

Back to our unit test fail, which is currently showing a 404 for our singleton
list URL.  Let's fix that in 'superlists/urls.py'

[source,python]
----
urlpatterns = patterns('',
    url(r'^$', 'lists.views.home_page', name='home'),
    url(r'^lists/the-only-list-in-the-world/$', 'lists.views.view_list',
        name='view_list'
    ),
    # url(r'^superlists/', include('superlists.foo.urls')),
    [...]
----

Running the tests again, we get:

----
ViewDoesNotExist: Could not import lists.views.view_list. View does not exist
in module lists.views.
----

Nicely self-explanatory.  Let's create a dummy view function in 'lists/views.py'

[source,python]
----
def view_list(request):
    pass
----

Now we get

----
ValueError: The view lists.views.view_list didn't return an HttpResponse object.
----

Let's copy the two last lines from the `home_page` view and see if they'll do
the trick:

[source,python]
----
def view_list(request):
    items = Item.objects.all()
    return render(request, 'home.html', {'items': items})
----

Re-run the tests and they should pass:

----
Ran 7 tests in 0.052s
OK
----

And the FTs should get a little further on:

----
AssertionError: New to-do item did not appear in table -- its text was:
1: Buy peacock feathers
----

Now it's time for a little tidying up.  In the Red/Green/Refactor dance, we've
got to green, it's time to refactor.  We now have two views, one for the home
page, and one for an individual list.  Both are currently using the same 
template, and passing it the current list items in the database.  If we 
look through our unit test methods, we can see some stuff we probably want
to change:

----
$ egrep "class|def" lists/tests.py
class HomePageTest(TestCase):
    def test_root_url_resolves_to_home_page_view(self):
    def test_home_page_returns_correct_html(self):
    def test_home_page_displays_all_list_items(self):
    def test_home_page_only_saves_items_when_necessary(self):
    def test_home_page_can_save_a_POST_request(self):
class ListViewTest(TestCase):
    def test_list_view_displays_all_items(self):
class ItemModelTest(TestCase):
    def test_saving_and_retrieving_items(self):
----

We don't actually need the home page to display all list items any more, it
should just show a single input box inviting you to start a new list. We also
don't want the home page and the list view using the same template.

We can start by deleting the `test_home_page_displays_all_list_items` method,
it's no longer needed.  If you run `manage.py test lists` now, it should say
it ran 6 tests instead of 7.

Next let's adapt our list view test to check that it's using a different
template:

[source,python]
----
class ListViewTest(TestCase):

    def test_list_view_displays_all_items(self):
        Item.objects.create(text='itemey 1')
        Item.objects.create(text='itemey 2')

        client = Client()
        response = client.get('/lists/the-only-list-in-the-world/')

        self.assertIn('itemey 1', response.content)
        self.assertIn('itemey 2', response.content)
        self.assertTemplateUsed(response, 'list.html')
----

`assertTemplateUsed` is one of the more useful functions that the test client
gives us.  Let's see what it says:

----
AssertionError: Template 'list.html' was not a template used to render the
response. Actual template(s) used: home.html
----


Great!  Let's change the view:

[source,python]
----
def view_list(request):
    items = Item.objects.all()
    return render(request, 'list.html', {'items': items})
----

But, obviously, that template doesn't exist yet. If we run the unit tests, we
get:

----
TemplateDoesNotExist: list.html
----

Let's create a new file at 'lists/templates/list.html'.  

[subs="specialcharacters,quotes"]
----
$ *touch lists/templates/list.html*
----

A blank template, which gives us this error -- good to know the tests are
there to remind us!  

----
AssertionError: 'itemey 1' not found in ''
----

The template for an individual list will re-use quite a lot of the stuff
we currently have in 'home.html', so we could just copy that:

[subs="specialcharacters,quotes"]
----
$ *cp lists/templates/home.html lists/templates/list.html*
----

Well, that gets the unit tests back to passing.  Now let's do a little 
more tidying up.  The home page doesn't need to list items, it only
needs the new list input field, so we can remove some lines from
'lists/templates/home.html', and maybe slightly tweak the `h1` to
say "Start a new list":

[source,html]
----
<html>
    <head>
        <title>To-Do lists</title>
    </head>
    <body>
        <h1>Start a To-Do list</h1>
        <form method="POST" >
            <input id="id_new_item" name="item_text" placeholder="Enter a to-do item" />
            {% csrf_token %}
        </form>
    </body>
</html>
----

We re-run the unit tests to check that hasn't broken anything... Good...

Now there's actually no need to pass all the items to the 'home.html'
template in our `home_page` view, so we can simplify that:

[source,python]
----
def home_page(request):
    if request.method == 'POST':
        Item.objects.create(text=request.POST['item_text'])
        return redirect('/lists/the-only-list-in-the-world/')
    return render(request, 'home.html')
----

Re run the unit tests, they still pass. And, taking a look at
'list.html', it looks about right. 

Let's run the functional tests:

----
  File "/media/SHARED/Dropbox/book/source/chapter_6/superlists/fts/
  tests.py", line 64, in test_can_start_a_list_and_retrieve_it_later
    table.text,
AssertionError: New to-do item did not appear in table -- its text was:
1: Buy peacock feathers
----

We're failing to input the second item.  What's going on here? Well,
the problem is that our new item forms are both missing an `action=`
attribute, which means that, by default, they submit to the same URL
they were rendered from. That works for the home page, because it's
the only one that knows how to deal with POST requests currently,
but it won't work for our 'view_list' function, which is just ignoring
the POST.

Let's fix that, in 'lists/templates/list.html'

[source,html]
----
    <form method="POST" action="/" >
----

And try running the FT again:

----
    self.assertNotEqual(francis_list_url, edith_list_url)
AssertionError: u'http://localhost:8081/lists/the-only-list-in-the-world/' == u'http://localhost:8081/lists/the-only-list-in-the-world/'
----

Hooray! We're back to where we were earlier, which means our refactoring is
complete -- we now have a unique URL for our one list.  It may feel like we
haven't made any progress since, functionally, the site still behaves almost
exactly like it did when we started the chapter, but this really is progress.
We've started on the road to our new design, and we've implemented a number of
things without making anything worse than it was before.  Let's commit our
progress so far:

[subs="specialcharacters,quotes"]
----
$ *git status* # should show 4 changed files and 1 new file, list.html
$ *git add lists/templates/list.html*
$ *git diff* # should show we've simplified home.html,
             # moved one test to a new class in lists/tests.py
             # added a new view in views.py, and simplified home_page
             # and made one addition to urls.py
$ *git commit -a* # add a message summarising the above, maybe something
                  # like "new URL, view and template to display lists"
----


Adding another URL
~~~~~~~~~~~~~~~~~~

Let's take a look at our to-do list:

* Adjust model so that items are associated with different lists
* Add unique URLs for each list
* Add a URL for creating a new list via POST
* Add URLs for adding a new item to an existing list via POST

Hm, well, we've sort of made progress on no. 2, even if there's only
1 list in the world. Item 1 is a bit scary.  Can we do something about
items 3 and 4?  Let's have a new URL for adding new list items.  If 
nothing else, it'll simplify the home page view. Open up 'lists/tests.py',
and 'move' the `test_home_page_can_save_a_POST_request` method into a new
class, then change its name:


[source,python]
----
        self.assertEqual(Item.objects.all().count(), 0)



class NewListTest(TestCase):

    def test_saving_a_POST_request(self):
        request = HttpRequest()
        request.method = 'POST'
        [...]
----

Now let's use the Django test client:

[source,python]
----
class NewListTest(TestCase):

    def test_saving_a_POST_request(self):
        client = Client()
        response = client.post(
                '/lists/new',
                data={'item_text': 'A new list item'}
        )

        self.assertEqual(Item.objects.all().count(), 1)
        new_item = Item.objects.all()[0]
        self.assertEqual(new_item.text, 'A new list item')

        self.assertEqual(response.status_code, 302)
        self.assertEqual(response['location'], '/lists/the-only-list-in-the-world/')
----

Let's try running that:


    self.assertEqual(Item.objects.all().count(), 1)
AssertionError: 0 != 1


Hmm, a little baffling.  I think I know why.  Let's move the
response.status_code check a little higher up:

[source,python]
----
    def test_saving_a_POST_request(self):
        client = Client()
        response = client.post(
                '/lists/new',
                data={'item_text': 'A new list item'}
        )
        self.assertEqual(response.status_code, 302)

        self.assertEqual(Item.objects.all().count(), 1)
        new_item = Item.objects.all()[0]
        self.assertEqual(new_item.text, 'A new list item')

        self.assertEqual(response['location'], '/lists/the-only-list-in-the-world/')
----

Sure enough:

----
    self.assertEqual(response.status_code, 302)
AssertionError: 404 != 302
----

There's no such URL, so let's add one:

[source,python]
----
urlpatterns = patterns('',
    url(r'^$', 'lists.views.home_page', name='home'),
    url(r'^lists/the-only-list-in-the-world/$', 'lists.views.view_list',
        name='view_list'
    ),
    url(r'^lists/new$', 'lists.views.new_list', name='new_list'
    ),
----

Next we get a `ViewDoesNotExist`, so let's fix that, in 'lists/views.py':

[source,python]
----
def new_list(request):
    pass
----

Then we get ``The view lists.views.new_list didn't return an HttpResponse object.''  (this is getting rather familiar!).  Let's borrow a line from 
`home_page`

[source,python]
----
def new_list(request):
    return redirect('/lists/the-only-list-in-the-world/')
----

----
    self.assertEqual(Item.objects.all().count(), 1)
AssertionError: 0 != 1
----

And another line from home_page:

[source,python]
----
def new_list(request):
    Item.objects.create(text=request.POST['item_text'])
    return redirect('/lists/the-only-list-in-the-world/')
----

Oops, an unexpected fail:

----
    self.assertEqual(response['location'], '/lists/the-only-list-in-the-world/')
AssertionError: 'http://testserver/lists/the-only-list-in-the-world/' != '/lists/the-only-list-in-the-world/'
----

That's because the Django test client behaves slightly differently to our
pure view function, it's using the full Django stack which adds the 
domain to our relative URL.  Let's use a helper function instead
of our two-step check for the redirect:

[source,python]
----
    def test_saving_a_POST_request(self):
        client = Client()
        response = client.post(
                '/lists/new',
                data={'item_text': 'A new list item'}
        )

        self.assertEqual(Item.objects.all().count(), 1)
        new_item = Item.objects.all()[0]
        self.assertEqual(new_item.text, 'A new list item')

        self.assertRedirects(response, '/lists/the-only-list-in-the-world/')
----

Looking good.  Can we remove the old code from `home_page`?

[source,html]
----
def home_page(request):
    return render(request, 'home.html')
----

We re-run the tests to make sure... Yes, 6 tests OK. 

Finally, let's wire up our two forms to use this new URL.  In **both** 
'home.html' and 'lists.html':

[source,html]
----
    <form method="POST" action="/lists/new" >
----

And we re-run our FTs to make sure everything still works...

----
AssertionError: u'http://localhost:8081/lists/the-only-list-in-the-world/' ==
u'http://localhost:8081/lists/the-only-list-in-the-world/'
----

Yup.  That's a nicely self-contained commit, and our 'views.py' is looking
much neater and tidier.  We're getting good at this refactoring malarkey!

$ *git status* # 5 changed files
$ *git diff* # URLs for forms x2, moved code in views + tests, new URL
$ *git commit -a* 


Adjusting our models
~~~~~~~~~~~~~~~~~~~~

OK, enough housekeeping with our URLs. It's time to bite the bullet and
change our models.  Let's adjust our unit tests. Perhaps showing you a 
diff output might be the best way to show the changes?

----
-from lists.models import Item
+from lists.models import Item, List
 from lists.views import home_page
 
 
@@ -62,14 +62,21 @@ class ListViewTest(TestCase):
-class ItemModelTest(TestCase):
+class ListAndItemModelsTest(TestCase):
 
     def test_saving_and_retrieving_items(self):
+        list = List()
+        list.save()
 
         first_item = Item()
         first_item.text = 'The first (ever) list item'
+        first_item.list = list
         first_item.save()
 
         second_item = Item()
         second_item.text = 'Item the second'
+        second_item.list = list
         second_item.save()
 
+        saved_lists = List.objects.all()
+        self.assertEqual(saved_lists.count(), 1)
+        self.assertEqual(saved_lists[0], list)
         saved_items = Item.objects.all()
         self.assertEqual(saved_items.count(), 2)

         first_saved_item = saved_items[0]
         second_saved_item = saved_items[1]
         self.assertEqual(first_saved_item.text, 'The first (ever) list item')
+        self.assertEqual(first_saved_item.list, list)
         self.assertEqual(second_saved_item.text, 'Item the second')
+        self.assertEqual(second_saved_item.list, list)

----

We create a new `List` object, and then we assign each item to it
by assigning it as its `.list` property.  We check the list is properly
saved, and we check that the two items have also saved their relationship
to the list.

Let's unit-test/code cycle this in.  I'm just going to show the test errors
for the first couple, and let you figure out for yourself what the code
should be:

----
ImportError: cannot import name List
----

----
AttributeError: 'List' object has no attribute 'save'
----

----
    self.assertEqual(first_saved_item.list, list)
AttributeError: 'Item' object has no attribute 'list'
----

How do we give our Item a list attribute?  Let's just try making it
like the text attribute:


[source,html]
----
class Item(models.Model):
    text = models.TextField()
    list = models.TextField()
----

That give us:

    AssertionError: u'List object' != <List: List object>

Not quite -- the string representation of an object isn't the same 
as the object itself.  To get Django to see that we want to create
a relationship between the two classes, we use a `ForeignKey`:

[source,html]
----
class Item(models.Model):
    text = models.TextField()
    list = models.ForeignKey(List)
----

(`List` will need to be defined above `Item` in your source for that to
work).

Now what happens?

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test fts*]
 Creating test database for alias 'default'...
 ....EE
 ======================================================================
 ERROR: test_list_view_displays_all_items (lists.tests.ListViewTest)
 ----------------------------------------------------------------------
 Traceback (most recent call last):
   File "/media/SHARED/Dropbox/book/source/chapter_6/superlists/lists/tests.py", line 50, in test_list_view_displays_all_items
     Item.objects.create(text='itemey 1')
     [...]
     return Database.Cursor.execute(self, query, params)
 IntegrityError: lists_item.list_id may not be NULL
 
 ======================================================================
 ERROR: test_saving_a_POST_request (lists.tests.NewListTest)
 ----------------------------------------------------------------------
 Traceback (most recent call last):
   File "/media/SHARED/Dropbox/book/source/chapter_6/superlists/lists/tests.py", line 36, in test_saving_a_POST_request
     data={'item_text': 'A new list item'}
     [...]
     return Database.Cursor.execute(self, query, params)
 IntegrityError: lists_item.list_id may not be NULL
 
 ----------------------------------------------------------------------
 Ran 6 tests in 0.017s
----

Oh gawd!  Well, our model tests are passing but two of our view tests are
failing, because Items have to be associated with a list now. Let's get them
working again.  The easiest is the `ListViewTest`, we just create a parent
list for our two test items:

[source,python]
----
class ListViewTest(TestCase):

    def test_list_view_displays_all_items(self):
        list = List.objects.create()
        Item.objects.create(text='itemey 1', list=list)
        Item.objects.create(text='itemey 2', list=list)
----

That gets us down to 1 failing test.  Decoding its traceback, it fails
in the view:

----
  File "/media/SHARED/Dropbox/book/source/chapter_6/superlists/lists/views.py",
     line 9, in new_list
    Item.objects.create(text=request.POST['item_text'])
----

So we make a similar change in the view:

[source,python]
----
from lists.models import Item, List
[...]
def new_list(request):
    list = List.objects.create()
    Item.objects.create(text=request.POST['item_text'], list=list)
    return redirect('/lists/the-only-list-in-the-world/')
----

Are you cringing internally at this point?  ``Arg! This feels so wrong, we
create a new list for every single new item submission, and we're still just
displaying all items as if they belong to the same list!  Yuck yuck yuck!''.
I know, I feel the same.  The step-by-step approach, in which you go
from working code to working code, is counterintuitive, it does feel weird,
you do always feel like you should dive in and fix everything all in one go,
instead of going from one weird half-finished state to another.  But remember
the testing goat!  When you're up a mountain, you want to think very carefully
about where you put each foot, and take one step at a time, checking at each
stage that the place you've put it hasn't caused you to fall off a cliff.

Just to reassure ourselves, we can re-run the FT.  Sure enough, it gets
all the way through to where we were before.  We haven't broken anything,
and we've made a change to the database.  That's something to be pleased
with! Let's commit:

$ *git status* # 3 changed files
$ *git diff* 
$ *git commit -a* 


The final stage:  each list should have its own URL
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

What shall we use as the unique ID for our lists?  Let's just use the 
primary key for now.  Let's change `ListViewTest`, make it use the
URL for a particular list, and check that no other list items appear:

[source,python]
----
class ListViewTest(TestCase):

    def test_list_view_displays_items_for_that_list(self):
        list = List.objects.create()
        Item.objects.create(text='itemey 1', list=list)
        Item.objects.create(text='itemey 2', list=list)

        other_list = List.objects.create()
        Item.objects.create(text='other list item 1', list=other_list)
        Item.objects.create(text='other list item 2', list=other_list)

        client = Client()
        response = client.get('/lists/%d/' % (list.id,))

        self.assertIn('itemey 1', response.content)
        self.assertIn('itemey 2', response.content)
        self.assertNotIn('other list item 1', response.content)
        self.assertNotIn('other list item 2', response.content)
        self.assertTemplateUsed(response, 'list.html')
----

(if you're not familiar with Python string substitutions, that `%d` may
be a little confusing?  It may be worth going to look them up quickly now)

Running the unit tests gives us:

----
AssertionError: 'itemey 1' not found in '404 Page not found. Try another
URL.\n'
----

It's time to learn how we can pass parameters from URLs to views:


TODO:  would this be better explained with the old way of testing views?


Things to be dragged in:

* 404 and 500 error templates... including putting them in the right place?
* urls.py, and including them from lists.

(Under construction)


