Getting to the minimum viable site
----------------------------------

We ended the last chapter with a classic testing problem:  how to ensure
'isolation' between tests.  When we run unit tests, the Django test runner
automatically creates a brand new test database (separate from the production
one), and resets it before each individual test is run.  But our functional
tests currently run against the ``real'' database. 

Ensuring test isolation in functional tests
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are two ways we could tackle this.  One is to `roll our own'' solution:
we use the `setUp` and `tearDown` methods from `unittest` to create a fresh
database and reset it between each test.  In an old tutorial I wrote, I managed
it using a combination of:

* creating a 'settings_for_fts.py' which imports everything from 'settings.py',
but changes the `DATABASES` entry to have a different `NAME`
* in `setUp`, use `subprocess.Popen` to spin up the Django `manage.py
runserver`, passing in `settings=settings_for_fts`.
* use `django.core.management.setup_environ` with `settings_for_fts` to load
Django for our test database
* Then we can do things like `django.core.management.call_command("syncdb")`,
as well as add any test data to the database.
* `tearDown` would kill the server and delete the database file after each
test.

You can explore the implementation at my Github page for the
Test-Driven-Django-Tutorial, on a tag called https://github.com/hjwp/Test-Driven-Django-Tutorial/blob/old-ft-runner/mysite/functional_tests.py[old-ft-runner]

Since Django 1.4 though, there's a new class called `LiveServerTestCase` which
does a lot of this work for you, automatically, essentially just like the unit
tests runs.  Although it has some limitations and we'll probably need to move
off it later, it's a useful tool at this stage, so let's check it out.

`LiveServerTestCase` expects to be run by the Django test runner, so the
first step is to create a new Django app to hold our functional tests.

[subs="specialcharacters,quotes"]
----
$ *python manage.py startapp fts*
----

Then we move our functional tests, from being a standalone file, to being
the tests of the `functional_tests` app.  We use *`git mv`* so that git
notices that we've moved the file:

[subs="specialcharacters,quotes"]
----
$ *git mv -f functional_tests.py fts/tests.py*
$ git status # at this point should show the "rename"
----

At this point your directory tree should look like this:

----
├── database.sqlite
├── fts
│   ├── __init__.py
│   ├── models.py
│   ├── tests.py
│   └── views.py
├── lists
│   ├── __init__.py
│   ├── __init__.pyc
│   ├── models.py
│   ├── templates
│   │   └── home.html
│   ├── tests.py
│   └── views.py
├── manage.py
└── superlists
    ├── __init__.py
    ├── settings.py
    ├── urls.py
    └── wsgi.py
----


Now let's edit 'fts/tests.py' to make it use LiveServerTestCase:

[source,python]
----
from django.test import LiveServerTestCase <1>
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

class NewVisitorTest(LiveServerTestCase): <2>

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.browser.implicitly_wait(3)

    def tearDown(self):
        self.browser.quit()

    def test_can_start_a_list_and_retrieve_it_later(self):
        # Edith has heard about a cool new online to-do app. She goes
        # to check out its homepage
        self.browser.get(self.live_server_url) <3>

        [...]
# we can also remove the if __name__ == '__main__' from the end <4>
----

We've changed the `import` <1> at the top, the `class` <2>, and the 
`self.browser.get`, which now uses `self.live_server_url` <3>, an attribute that
`LiveServerTestCase` will populate for us when it starts up the server.

And finally, we add `fts` as a new app in 'settings.py':

[source,python]
----
INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Uncomment the next line to enable the admin:
    # 'django.contrib.admin',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
    'lists',
    'fts',
)
----

Now we should be able to run our functional tests using the Django 
test runner, by telling it to run just the tests for our new `fts` app:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test fts*]
$ python manage.py test fts 
Creating test database for alias 'default'...
Traceback (most recent call last):
  [...]
  File "/usr/lib/python2.7/wsgiref/handlers.py", line 85, in run
    template, origin = find_template(template_name)
  File "/usr/local/lib/python2.7/dist-packages/django/template/loader.py", line 138, in find_template
    raise TemplateDoesNotExist(name)
TemplateDoesNotExist: 500.html
F
======================================================================
FAIL: test_can_start_a_list_and_retrieve_it_later (fts.tests.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/media/SHARED/Dropbox/book/source/chapter_6/superlists/fts/tests.py", line 74, in test_can_start_a_list_and_retrieve_it_later
    self.fail('Finish the test!')
AssertionError: Finish the test!

 ---------------------------------------------------------------------
Ran 1 test in 6.378s

FAILED (failures=1)
Destroying test database for alias 'default'...
----

Well, despite that ugly `TemplateDoesNotExist: 500` traceback, which we'll look
at in a moment,  the FT actually got through to its expected `self.fail`.

That's worthy of a commit:

[subs="specialcharacters,quotes"]
----
$ *git status* # see rename, modified fts/tests.py, settings.py, and new files
$ *git add fts*
$ *git add superlists/settings.py*
$ *git diff --staged -M*
$ *git commit*  # msg eg "move functional_tests to fts app, use LiveServerTestCase"
----

The `-M` flag on the `git diff` is a useful one. It means "detect moves", so it
will notice that `functional_tests.py` and `fts/tests.py` are the same file,
and show you a more sensible diff...

Now let's move on to thinking about how we want support for multiple lists to
work.  Currently the FT (which is the closest we have to a design document)
says this:

[source,python]
----
    # Edith wonders whether the site will remember her list. Then she sees
    # that the site has generate a unique URL for her -- there is some
    # explanatory text to that effect.
    self.fail('Finish the test!')

    # She visits that URL - her to-do list is still there.

    # Satisfied, she goes back to sleep
----

But really we want to expand on this, by saying that different users
don't see each other's lists, and each get their own URLs as a way of
going back to their saved lists.


Small Design When Necessary
~~~~~~~~~~~~~~~~~~~~~~~~~~~

TDD grew out of the agile movement in software, which includes a strong
reaction against ``Big Design Up-Front'': the traditional software
practice whereby, after a lengthy requirements gathering exercise, there
was an equally lengthy design stage where the software was planned out on
paper. The philosophy is that you learn more from solving problems in 
practice than in theory, especially when you confront your application with
real-world uses as soon as possible. Agile methodologies suggest that we spend
minimal time on up-front design, and instead let the design evolve gradually
based on feedback from real users.  To get that feedback, we try and put a
minimum viable application in front of them as soon as possible.

But that doesn't mean no thinking about design at all!  So, let's think about
our minimum viable lists app, and what kind of design we'll need to deliver it.

* We want each user to be able to store their own list - at least one, for now.
* A list is made up of several items, whose primary attribute is a bit of 
descriptive text
* We need to save lists from one visit to the next.  For now, we can give 
each user a unique URL for their list.  Later on we may want some way of
automatically recognising users and showing them their lists.

To deliver the ``for now'' items then, it sounds like we're going to store
lists and their items in a database.  Each list will have a unique URL,
and each list item will be a bit of descriptive text, associated with a
particular list.

YAGNI
^^^^^

All sorts of other thoughts are occurring to us as well -- we might want to
give each lists a name or title, we might want to recognise users using
usernames and passwords, we might want to add a longer notes field as well as
short descriptions to our list, we might want to store some kind of ordering,
and so on.  But we obey another tenet of the agile gospel:  ``YAGNI''
(pronounced yag-knee), which stands for ``You ain't gonna need it''.  As 
software developers, we have an urge to create things, and sometimes it's
hard to resist the urge to build things just because an idea occured to us
and we 'might' need it.  The trouble is that 9 times out of 10, no matter how
cool the idea was, you won't end up using it, and you've ended up with a load
of unused code, adding to the complexity of your application. YAGNI is the 
mantra we use to resist our overenthusiastic creative urges.

So we have an idea of the data structure we want (the ``Model'' part of 
Model-View-Controller (MVC).  What about the view and controller part? 
How should the user interact with Lists and their Items using a web browser?


REST
^^^^

Representational State Transfer (REST) is an approach to web design that's 
usually used to guide the design of web-based APIs, but it's often a 
helpful guide to how to structure your site in general (although trying to
stick to the REST rules too strictly is probably a mistake, when designing
a user-facing site rather than an API).

REST suggests that we have a URL structure that matches our data structure,
in this case, lists and list items.  Each list can have its own URL, like

`/lists/<list id>/`

That will fulfil the requirement we've specified in our FT. To view a list, we
use a GET request (a normal browser visit to the page)

To create a brand new list, we'll have a special URL that accepts POST
requests:

`/lists/new`

To add a new item to an existing list, we'll have a separate URL, to which
we can send POST requests.

`/lists/<list id>/add_item`

Let's update our FT to reflect this new design.

(Under construction)

* change FT to show a second user?
* specify each list should have its own url
* use django test client

