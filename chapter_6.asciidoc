Getting to the minimum viable site
----------------------------------

In this chapter we're going to address the problems we discovered at the end
of the last chapter. In the immediate, the problem of cleaning up after 
functional test runs, and later the more general problem, which is that
our design only allows for one global list.  I'll demonstrate a critical
TDD technique:  how to adapt existing code using an incremental, step-by-step
process which takes you from working code to working code. Testing Goat, not
Refactoring Cat.


Ensuring test isolation in functional tests
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We ended the last chapter with a classic testing problem:  how to ensure
'isolation' between tests.  Each run of our functional tests was leaving list
items lying around in the database, and that would interfere with the test
results when you next ran the tests.

When we run 'unit' tests, the Django test runner automatically creates a brand
new test database (separate from the real one), which it can safely reset 
before each individual test is run, and then throw away at the end.  But our
functional tests currently run against the ``real'' database, 'database.sqlite'

One way to tackle this would be to ``roll our own'' solution, and add some code
to 'functional_tests.py' which would do the cleaning up. The `setUp` and
`tearDown` methods are perfect for this sort of thing.

Since Django 1.4 though, there's a new class called `LiveServerTestCase` which
can do this work for you. It will automatically create a test database (just
like in a unit test run), and start up a development server for the functional
tests to run again. Although as a tool it has some limitations and we'll
probably need to move off it later, it's dead useful at this stage, so let's
check it out.

.A hand-rolled implementation of test database cleanup
*******************************************************************************
You may not always have the luxury of a tool like `LiveServerTestCase`, for
example if you decide to use a framework other than Django. If you want to see
an example of how to manage functional test isolation manually, I once wrote
some code for an old version of a tutorial, using a combination of: 

* switching to a test database by overriding 'settings.py', using a file called
'settings_for_fts.py' which imports everything from 'settings.py', but changes
the `DATABASES` entry to have a different `NAME`
* Then run `manage.py' with a 'settings=settings_for_fts' flag at the
command line.
* in `setUp`, use `subprocess.Popen` to do a `syncdb` against the test database
* and while we're at it, `setUp` can also do a `manage.py runserver`, again
using `settings_for_fts`, to start up the test server automatically.
* `tearDown` would kill the server and delete the database file after each
test.

You can explore the implementation at my Github page for the
Test-Driven-Django-Tutorial, on a tag called
https://github.com/hjwp/Test-Driven-Django-Tutorial/blob/old-ft-runner/mysite/functional_tests.py[old-ft-runner]
*******************************************************************************

`LiveServerTestCase` expects to be run by the Django test runner using
'manage.py', so the first step is to create a new Django app to hold our
functional tests.  Last time, to create an app, we used the `manage.py startapp` 
command, but this time we'll do it manually:  all Django needs for an app is
a folder which is a valid Python module (ie one with a '__init__.py' in). The only
other requirement is that it should contain a 'models.py', even if it's just an 
empty one:

[subs="specialcharacters,quotes"]
----
$ *mkdir functional_tests*
$ *touch functional_tests/__init__.py* 
$ *touch functional_tests/models.py* 
----

Then we 'move' our functional tests, from being a standalone file called
'functional_tests.py', to being the 'tests.py' of the `functional_tests` app.  We
use *`git mv`* so that git notices that we've moved the file:

[subs="specialcharacters,quotes"]
----
$ *git mv -f functional_tests.py functional_tests/tests.py*
$ *git status* # should show the "rename" and two untracked files
----

At this point your directory tree should look like this:

----
├── database.sqlite
├── functional_tests
│   ├── __init__.py
│   ├── models.py
│   └── tests.py
├── lists
│   ├── __init__.py
│   ├── models.py
│   ├── templates
│   │   └── home.html
│   ├── tests.py
│   └── views.py
├── manage.py
└── superlists
    ├── __init__.py
    ├── settings.py
    ├── urls.py
    └── wsgi.py
----

'functional_tests.py' is gone, and has turned into 'functional_tests/tests.py'.
Now, whenever we want to run our functional tests, instead of running `python
functional_tests.py`, we will use `python manage.py test functional_tests`.

NOTE: You could mix your functional tests into the tests for the 'lists' app.
I tend to prefer to keep them separate, because functional tests usually have
cross-cutting concerns that run across different apps.

First let's edit 'functional_tests/tests.py' to make it use
`LiveServerTestCase`:

[source,python]
----
from django.test import LiveServerTestCase #<1>
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

class NewVisitorTest(LiveServerTestCase): #<2>

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.browser.implicitly_wait(3)

    def tearDown(self):
        self.browser.quit()

    def check_for_row_in_list_table(self, row_text):
        [...]

    def test_can_start_a_list_and_retrieve_it_later(self):
        # Edith has heard about a cool new online to-do app. She goes
        # to check out its homepage
        self.browser.get(self.live_server_url) #<3>

        [...]
# also remove the if __name__ == '__main__' from the end <4>
----
[role="caption"]
functional_tests/tests.py

<1> Instead of `unittest`, we import `LiveServerTestCase from `django.test`
<2> We make our test class inherit from it
<3> Because LiveServerTestCase is now in charge of starting up the dev server
for us, we can't be sure what address it will be served at. Instead of using a
hard-code 'localhost' address, we use `self.live_server_url`, which
LiveServerTestCase will fill in for us.
<4> We also remove the `__main__` runner from the end -- 'manage.py' will run
the tests for us, just like it does for the unit tests.

Finally, we add `functional_tests` as a new app in 'superlists/settings.py':

[source,python]
----
INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Uncomment the next line to enable the admin:
    # 'django.contrib.admin',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
    'lists',
    'functional_tests',
)
----
[role="caption"]
superlists/settings.py

Now we are able to run our Functional tests using the Django test runner, by
telling it to run just the tests for our new `functional_tests` app:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test functional_tests*]
Creating test database for alias 'default'...
F
======================================================================
FAIL: test_can_start_a_list_and_retrieve_it_later (functional_tests.tests.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/media/SHARED/Dropbox/book/source/chapter_6/superlists/functional_tests/tests.py", line 74, in test_can_start_a_list_and_retrieve_it_later
    self.fail('Finish the test!')
AssertionError: Finish the test!

 ---------------------------------------------------------------------
Ran 1 test in 6.378s

FAILED (failures=1)
Destroying test database for alias 'default'...
----

NOTE: If, before the FAIL, you see some traceback ending in a
`TemplateDoesNotExist: 500`, it's because you're running Django 1.4 instead of
1.5. You should upgrade, because although not much has changed between the two
versions, a few subtle things like this have.  It's not too late to upgrade at
this stage.

The FT gets through to the `self.fail`, just like it did before the refactor.
You'll also notice that if you run the tests a second time, there aren't any
old list items lying around from the previous test - it has cleaned up after
itself.  Success! We should commit it as an atomic change:

[subs="specialcharacters,quotes"]
----
$ *git status* # should show renamed functional_tests.py,
               # modified functional_tests/tests.py & settings.py
               # and 2 new files, __init__.py and models.py
$ *git add functional_tests*
$ *git add superlists/settings.py*
$ *git diff --staged -M*
$ *git commit*  # msg eg "move functional_tests to functional_tests app, use LiveServerTestCase"
----

The `-M` flag on the `git diff` is a useful one. It means "detect moves", so it
will notice that `functional_tests.py` and `functional_tests/tests.py` are the
same file, and show you a more sensible diff...

.Useful commands updated
*******************************************************************************
Running the functional tests::
    *`python manage.py tests functional_tests`*

Running the unit tests::
    *`python manage.py test lists`*
*******************************************************************************

Now let's move on to thinking about how we want support for multiple lists to
work.  Currently the FT (which is the closest we have to a design document)
says this:

[source,python]
----
    # Edith wonders whether the site will remember her list. Then she sees
    # that the site has generate a unique URL for her -- there is some
    # explanatory text to that effect.
    self.fail('Finish the test!')

    # She visits that URL - her to-do list is still there.

    # Satisfied, she goes back to sleep
----
[role="caption"]
functional_tests/tests.py

But really we want to expand on this, by saying that different users
don't see each other's lists, and each get their own URLs as a way of
going back to their saved lists.


Small Design When Necessary
~~~~~~~~~~~~~~~~~~~~~~~~~~~

TDD is closely associated with the agile movement in software development,
which includes a strong reaction against ``Big Design Up-Front'': the
traditional software engineering practice whereby, after a lengthy requirements
gathering exercise, there was an equally lengthy design stage where the
software was planned out on paper. The philosophy is that you learn more from
solving problems in practice than in theory, especially when you confront your
application with real-world uses as soon as possible. Agile methodologies
suggest that we spend minimal time on up-front design, and instead let the
design evolve gradually based on feedback from real users.  To get that
feedback, we try and put a minimum viable application in front of them as soon
as possible.

But that doesn't mean that thinking about design is outright banned! In the
last chapter we saw how just blundering ahead without thinking can 'eventually'
get us to the right answer, but often a 'little' thinking about design can help
us get there faster. So, let's think about our minimum viable lists app, and
what kind of design we'll need to deliver it.

* We want each user to be able to store their own list - at least one, for now.
* A list is made up of several items, whose primary attribute is a bit of 
descriptive text
* We need to save lists from one visit to the next.  For now, we can give 
each user a unique URL for their list.  Later on we may want some way of
automatically recognising users and showing them their lists.

To deliver the ``for now'' items then, it sounds like we're going to store
lists and their items in a database.  Each list will have a unique URL,
and each list item will be a bit of descriptive text, associated with a
particular list.

YAGNI
^^^^^

Once you start thinking about design, it can be hard to stop. All sorts of
other thoughts are occurring to us -- we might want to give each list
a name or title, we might want to recognise users using usernames and
passwords, we might want to add a longer notes field as well as short
descriptions to our list, we might want to store some kind of ordering, and so
on.  But we obey another tenet of the agile gospel:  ``YAGNI'' (pronounced
yag-knee), which stands for ``You ain't gonna need it''.  As software
developers, we have fun creating things, and sometimes it's hard to resist
the urge to build things just because an idea occurred to us and we 'might'
need it.  The trouble is that 9 times out of 10, no matter how cool the idea
was, you won't end up using it, and you'll end up with a load of unused code,
adding to the complexity of your application. YAGNI is the mantra we use to
resist our overenthusiastic creative urges.

So we have an idea of the data structure we want (the ``Model'' part of 
Model-View-Controller (MVC).  What about the view and controller part? 
How should the user interact with Lists and their Items using a web browser?


REST
^^^^

Representational State Transfer (REST) is an approach to web design that's 
usually used to guide the design of web-based APIs, but it's often a 
helpful guide to how to structure your site in general (although trying to
stick to the REST rules too strictly is probably a mistake, when designing
a user-facing site rather than an API).

REST suggests that we have a URL structure that matches our data structure,
in this case, lists and list items.  Each list can have its own URL, like

`/lists/<list identifier>/`

That will fulfil the requirement we've specified in our FT. To view a list, we
use a GET request (a normal browser visit to the page)

To create a brand new list, we'll have a special URL that accepts POST
requests:

`/lists/new`

To add a new item to an existing list, we'll have a separate URL, to which
we can send POST requests.

`/lists/<list identifier>/add_item`

In summary, our to-do list for this chapter looks something like this:

* Adjust model so that items are associated with different lists
* Add unique URLs for each list
* Add a URL for creating a new list via POST
* Add URLs for adding a new item to an existing list via POST

Let's translate this thinking to our functional test.  As soon as Edith
submits a first list item, we'll want to create a new list, adding one
item to it, and take her to the URL for her list.  That's around line 35:


[source,python]
----
    # When she hits enter, she is taken to a new URL,
    # and now the page lists "1: Buy peacock feathers" as an item in a
    # to-do list table
    inputbox.send_keys(Keys.ENTER)
    edith_list_url = self.browser.current_url
    self.assertRegexpMatches(edith_list_url, '/lists/.+')
    self.assertIn('1: Buy peacock feathers', [row.text for row in rows])
    [...]
----
[role="caption"]
functional_tests/tests.py

Now let's change the end of the test and imagine a new user coming along.
We want to check that they don't see any of Edith's items when they visit
the home page, and that they get their own unique URL for their list.

Delete everything from the comment at line 74 ("Edith wonders..."), and 
replace it with:


[source,python]
----
    # Now a new user, Francis, comes along to the site.
    self.browser.quit()
    ## We use a new browser session to make sure that no information
    ## of Edith's is coming through from cookies etc #<1>
    self.browser = webdriver.Firefox()

    # Francis visits the home page.  There is no sign of Edith's
    # list
    self.browser.get(self.live_server_url)
    page_text = self.browser.find_element_by_tag_name('body').text
    self.assertNotIn('Buy peacock feathers', page_text)
    self.assertNotIn('make a fly', page_text)

    # Francis starts a new list by entering a new item. He 
    # is less interesting than Edith...
    inputbox = self.browser.find_element_by_id('id_new_item')
    inputbox.send_keys('Buy milk')
    inputbox.send_keys(Keys.ENTER)

    # Francis gets his own unique URL
    francis_list_url = self.browser.current_url
    self.assertRegexpMatches(francis_list_url, '/lists/.+') #<2>
    self.assertNotEqual(francis_list_url, edith_list_url)

    # Again, there is no trace of Edith's list
    page_text = self.browser.find_element_by_tag_name('body').text
    self.assertNotIn('Buy peacock feathers', page_text)
    self.assertIn('Buy milk', page_text)
----
[role="caption"]
functional_tests/tests.py

<1> At work we use the convention of double-hashes (`##`) to indicate 
"meta-comments", comments about 'how' the test is working working and why,
to distinguish them from regular comments in FTs which explain the User Story.
They're a message to our future selves, which might otherwise be wondering why
the heck we're quitting the browser and starting a new one...

<2> `assertRegexpMatches` is a new function, we use it to check our new REST
design has been implemented.  Other than that, our changes are fairly
straightforward. Let's see how they do when we run our FTs:

----
AssertionError: Regexp didn't match: '/lists/.+' not found in
u'http://localhost:8081/'
----

As expected.  Let's do a commit, and then go and build some new models
and views.

[subs="specialcharacters,quotes"]
----
$ *git commit -a* 
----

NOTE: I found the FTs hung when I tried to run them today.  It turns out I
needed to upgrade Selenium, with a `pip install --upgrade selenium`. It's
only been a couple of months since I last upgraded, and Selenium had gone up
by 6 point versions.  If something weird is happening, always try upgrading
Selenium!


Iterating towards the new design
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Being all excited about our new design, I had an overwhelming urge to dive in
at this point and start changing 'models.py', which would have broken half the
unit tests, and then pile in and change almost every single line of code, all
in one go.  Obey the Testing Goat, not Refactoring Cat!  We don't need to
implement our new, shiny design in a single big bang. Let's make small changes
that take us from a working state to a working state, with our design guiding
us gently at each stage.

We'll start by adjusting our URLs to be more in line with our design, since
that's what the FT is currently stuck on: it's complaining that the URL you get
taken to after starting a list isn't a list URL.  So let's start by fixing that
-- it's the redirect after POST.  In 'lists/tests.py', find
`test_home_page_can_save_a_POST_request`, and change the expected redirect 
location:

[source,python]
----
    self.assertEqual(response.status_code, 302)
    self.assertEqual(response['location'], '/lists/the-only-list-in-the-world/')
----
[role="caption"]
lists/tests.py

That gets us an expected fail

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test lists*]
[...]
AssertionError: '/' != '/lists/the-only-list-in-the-world/'
----

Now we can go adjust our `home_page` view in 'lists/views.py':

[source,python]
----
def home_page(request):
    if request.method == 'POST':
        Item.objects.create(text=request.POST['item_text'])
        return redirect('/lists/the-only-list-in-the-world/')
----
[role="caption"]
lists/views.py

Of course that will now totally break the functional test, because there is no
such URL on our site yet.  Sure enough, if you run them, you'll find they fail
just after trying to submit the first item, saying that they can't find the
list table; it's because URL '/the-only-list-in-the-world/' doesn't exist yet!

TODO: mention fact that fts now run with DEBUG=False?

So, let's build a special URL for our one and only list (it's a problem-solving
technique: you need something that works for N objects, you currently have
nothing, ie something that works for 0 objects. Solving for 1 object is a good
step towards solving for N)


Testing views, templates and URLs together with the Django Test Client
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In previous chapters I've shown how you can test your URL resolution 
explicitly, and how to test view functions by actually calling them, and 
checking that they render your templates correctly too.  Django actually
provides us with a little tool that can do all three, which we'll use now.

I wanted to show you how to "roll your own" first, partially because it's
a better introduction to how Django works, but also because those techniques
are portable -- you may not always use Django, but you'll almost always have
view functions, templates and URL mappings, and you now know how to test them.

So let's use the Django Test Client.  Open up 'lists/tests.py', add `Client` to
the list of things we import from `django.test`, and then add a new test class
called `ListViewTest`.  Then, lets copy the method called
`test_home_page_displays_all_list_items` across from `HomePageTest`, and adapt
it slightly:

[source,python]
----
from django.test import Client, TestCase
[...]


class ListViewTest(TestCase):

    def test_list_view_displays_all_items(self):
        Item.objects.create(text='itemey 1')
        Item.objects.create(text='itemey 2')

        client = Client()
        response = client.get('/lists/the-only-list-in-the-world/')

        self.assertIn('itemey 1', response.content)
        self.assertIn('itemey 2', response.content)

----
[role="caption"]
lists/tests.py

Instead of calling the view function directly, we instantiate a test client
with `Client()`, and then we call `.get` with the URL we're testing -- it's 
actually a very similar API to the one that Selenium uses. 

Let's try running the test now:

----
    self.assertIn('itemey 1', response.content)
AssertionError: 'itemey 1' not found in '<h1>Not Found</h1><p>The requested URL
/lists/the-only-list-in-the-world/ was not found on this server.</p>'
----

Our singleton list URL doesn't exist yet.  We fix that in 'superlists/urls.py'

[source,python]
----
urlpatterns = patterns('',
    url(r'^$', 'lists.views.home_page', name='home'),
    url(r'^lists/the-only-list-in-the-world/$', 'lists.views.view_list',
        name='view_list'
    ),
    # url(r'^superlists/', include('superlists.foo.urls')),
    [...]
----
[role="caption"]
superlists/urls.py

Running the tests again, we get:

----
ViewDoesNotExist: Could not import lists.views.view_list. View does not exist
in module lists.views.
----

Nicely self-explanatory.  Let's create a dummy view function in 'lists/views.py'

[source,python]
----
def view_list(request):
    pass
----
[role="caption"]
lists/views.py

Now we get

----
ValueError: The view lists.views.view_list didn't return an HttpResponse object.
----

Let's copy the two last lines from the `home_page` view and see if they'll do
the trick:

[source,python]
----
def view_list(request):
    items = Item.objects.all()
    return render(request, 'home.html', {'items': items})
----
[role="caption"]
lists/views.py

Re-run the tests and they should pass:

----
Ran 7 tests in 0.052s
OK
----

And the FTs should get a little further on:

----
AssertionError: '2: Use peacock feathers to make a fly' not found in [u'1: Buy
peacock feathers']
----

Now it's time for a little tidying up.  In the Red/Green/Refactor dance, we've
got to green, it's time to refactor.  We now have two views, one for the home
page, and one for an individual list.  Both are currently using the same 
template, and passing it the current list items in the database.  If we 
look through our unit test methods, we can see some stuff we probably want
to change:

----
$ egrep "class|def" lists/tests.py
class HomePageTest(TestCase):
    def test_root_url_resolves_to_home_page_view(self):
    def test_home_page_returns_correct_html(self):
    def test_home_page_displays_all_list_items(self):
    def test_home_page_only_saves_items_when_necessary(self):
    def test_home_page_can_save_a_POST_request(self):
class ListViewTest(TestCase):
    def test_list_view_displays_all_items(self):
class ItemModelTest(TestCase):
    def test_saving_and_retrieving_items(self):
----

We don't actually need the home page to display all list items any more, it
should just show a single input box inviting you to start a new list. We also
don't want the home page and the list view using the same template.

We can start by deleting the `test_home_page_displays_all_list_items` method,
it's no longer needed.  If you run `manage.py test lists` now, it should say
it ran 6 tests instead of 7.

Next let's adapt our list view test to check that it's using a different
template:

[source,python]
----
class ListViewTest(TestCase):

    def test_list_view_displays_all_items(self):
        Item.objects.create(text='itemey 1')
        Item.objects.create(text='itemey 2')

        client = Client()
        response = client.get('/lists/the-only-list-in-the-world/')

        self.assertIn('itemey 1', response.content)
        self.assertIn('itemey 2', response.content)
        self.assertTemplateUsed(response, 'list.html')
----
[role="caption"]
lists/tests.py

`assertTemplateUsed` is one of the more useful functions that the test client
gives us.  Let's see what it says:

----
AssertionError: Template 'list.html' was not a template used to render the
response. Actual template(s) used: home.html
----


Great!  Let's change the view:

[source,python]
----
def view_list(request):
    items = Item.objects.all()
    return render(request, 'list.html', {'items': items})
----
[role="caption"]
lists/views.py

But, obviously, that template doesn't exist yet. If we run the unit tests, we
get:

----
TemplateDoesNotExist: list.html
----

Let's create a new file at 'lists/templates/list.html'.  

[subs="specialcharacters,quotes"]
----
$ *touch lists/templates/list.html*
----

A blank template, which gives us this error -- good to know the tests are
there to make sure we fill it in:

----
AssertionError: 'itemey 1' not found in ''
----

The template for an individual list will re-use quite a lot of the stuff
we currently have in 'home.html', so we could just copy that:

[subs="specialcharacters,quotes"]
----
$ *cp lists/templates/home.html lists/templates/list.html*
----

That gets the unit tests back to passing.  Now let's do a little more tidying
up.  We said the home page doesn't need to list items, it only needs the new
list input field, so we can remove some lines from 'lists/templates/home.html',
and maybe slightly tweak the `h1` to say "Start a new list":

[source,html]
----
<html>
    <head>
        <title>To-Do lists</title>
    </head>
    <body>
        <h1>Start a To-Do list</h1>
        <form method="POST" >
            <input id="id_new_item" name="item_text" placeholder="Enter a to-do item" />
            {% csrf_token %}
        </form>
    </body>
</html>
----
[role="caption"]
lists/templates/home.html

We re-run the unit tests to check that hasn't broken anything... Good...

Now there's actually no need to pass all the items to the 'home.html'
template in our `home_page` view, so we can simplify that:

[source,python]
----
def home_page(request):
    if request.method == 'POST':
        Item.objects.create(text=request.POST['item_text'])
        return redirect('/lists/the-only-list-in-the-world/')
    return render(request, 'home.html')
----
[role="caption"]
lists/views.py

Re run the unit tests, they still pass. 

Taking a look at 'list.html', it looks about right -- we could just make a
small tweak to the header text, to make it explicit that this is an existing
list, rather than an invitation to create a brand new one:

[source,html]
----
    <h1>Your To-Do list</h1>
----
[role="caption"]
lists/templates/list.html

Let's run the functional tests:

----
AssertionError: '2: Use peacock feathers to make a fly' not found in [u'1: Buy
peacock feathers']
----

We're still failing to input the second item.  What's going on here? Well, the
problem is that our new item forms are both missing an `action=` attribute,
which means that, by default, they submit to the same URL they were rendered
from. That works for the home page, because it's the only one that knows how to
deal with POST requests currently, but it won't work for our 'view_list'
function, which is just ignoring the POST.

Let's fix that, in 'lists/templates/list.html'

[source,html]
----
    <form method="POST" action="/" >
----
[role="caption"]
lists/templates/list.html

And try running the FT again:

----
    self.assertNotEqual(francis_list_url, edith_list_url)
AssertionError: u'http://localhost:8081/lists/the-only-list-in-the-world/' ==
u'http://localhost:8081/lists/the-only-list-in-the-world/'
----

Hooray! We're back to where we were earlier, which means our refactoring is
complete -- we now have a unique URL for our one list.  It may feel like we
haven't made much headway since, functionally, the site still behaves almost
exactly like it did when we started the chapter, but this really is progress.
We've started on the road to our new design, and we've implemented a number of
stepping stones 'without making anything worse than it was before'.  Let's
commit our progress so far:

[subs="specialcharacters,quotes"]
----
$ *git status* # should show 4 changed files and 1 new file, list.html
$ *git add lists/templates/list.html*
$ *git diff* # should show we've simplified home.html,
             # moved one test to a new class in lists/tests.py
             # added a new view in views.py, and simplified home_page
             # and made one addition to urls.py
$ *git commit -a* # add a message summarising the above, maybe something
                  # like "new URL, view and template to display lists"
----


Adding another URL
~~~~~~~~~~~~~~~~~~

Let's take a look at our to-do list:

* Adjust model so that items are associated with different lists
* Add unique URLs for each list
* Add a URL for creating a new list via POST
* Add URLs for adding a new item to an existing list via POST

Hm, well, we've sort of made progress on the second item, even if there's still
only one list in the world. Item 1 is a bit scary.  Can we do something about
items 3 or 4?  Let's have a new URL for adding new list items.  If 
nothing else, it'll simplify the home page view. Open up 'lists/tests.py',
and 'move' the `test_home_page_can_save_a_POST_request` method into a new
class, then change its name:


[source,python]
----
        [...]
        self.assertEqual(Item.objects.all().count(), 0)



class NewListTest(TestCase):

    def test_saving_a_POST_request(self):
        request = HttpRequest()
        request.method = 'POST'
        [...]
----
[role="caption"]
lists/tests.py

Now let's use the Django test client:

[source,python]
----
class NewListTest(TestCase):

    def test_saving_a_POST_request(self):
        client = Client()
        response = client.post(
                '/lists/new',
                data={'item_text': 'A new list item'}
        )

        self.assertEqual(Item.objects.all().count(), 1)
        new_item = Item.objects.all()[0]
        self.assertEqual(new_item.text, 'A new list item')

        self.assertEqual(response.status_code, 302)
        self.assertEqual(response['location'], '/lists/the-only-list-in-the-world/')
----
[role="caption"]
lists/tests.py

Let's try running that:

----
    self.assertEqual(Item.objects.all().count(), 1)
AssertionError: 0 != 1
----


Hmmm, a little baffling.  I think I know why.  Let's move the
`response.status_code` check a little higher up:

[source,python]
----
    def test_saving_a_POST_request(self):
        client = Client()
        response = client.post(
                '/lists/new',
                data={'item_text': 'A new list item'}
        )
        self.assertEqual(response.status_code, 302)

        self.assertEqual(Item.objects.all().count(), 1)
        new_item = Item.objects.all()[0]
        self.assertEqual(new_item.text, 'A new list item')

        self.assertEqual(response['location'], '/lists/the-only-list-in-the-world/')
----
[role="caption"]
lists/tests.py

Sure enough:

----
    self.assertEqual(response.status_code, 302)
AssertionError: 404 != 302
----

There's no such URL, so let's add one:

[source,python]
----
urlpatterns = patterns('',
    url(r'^$', 'lists.views.home_page', name='home'),
    url(r'^lists/the-only-list-in-the-world/$', 'lists.views.view_list',
        name='view_list'
    ),
    url(r'^lists/new$', 'lists.views.new_list', name='new_list'),
----
[role="caption"]
superlists/urls.py

Next we get a `ViewDoesNotExist`, so let's fix that, in 'lists/views.py':

[source,python]
----
def new_list(request):
    pass
----
[role="caption"]
lists/views.py

Then we get ``The view lists.views.new_list didn't return an HttpResponse
object.''  (this is getting rather familiar!).  Let's borrow a line from 
`home_page`

[source,python]
----
def new_list(request):
    return redirect('/lists/the-only-list-in-the-world/')
----
[role="caption"]
lists/views.py

----
    self.assertEqual(Item.objects.all().count(), 1)
AssertionError: 0 != 1
----

And another line from home_page:

[source,python]
----
def new_list(request):
    Item.objects.create(text=request.POST['item_text'])
    return redirect('/lists/the-only-list-in-the-world/')
----
[role="caption"]
lists/views.py

Oops, an unexpected fail:

----
    self.assertEqual(response['location'], '/lists/the-only-list-in-the-world/')
AssertionError: 'http://testserver/lists/the-only-list-in-the-world/' !=
'/lists/the-only-list-in-the-world/'
----

That's because the Django test client behaves slightly differently to our
pure view function, it's using the full Django stack which adds the 
domain to our relative URL.  Let's use another of Django's test helper functions
instead of our two-step check for the redirect:

[source,python]
----
    def test_saving_a_POST_request(self):
        client = Client()
        response = client.post(
                '/lists/new',
                data={'item_text': 'A new list item'}
        )

        self.assertEqual(Item.objects.all().count(), 1)
        new_item = Item.objects.all()[0]
        self.assertEqual(new_item.text, 'A new list item')

        self.assertRedirects(response, '/lists/the-only-list-in-the-world/')
----
[role="caption"]
lists/tests.py

That now passes.  We're looking good. Can we remove the old `if request.method == 'POST'` code from `home_page`?

[source,html]
----
def home_page(request):
    return render(request, 'home.html')
----
[role="caption"]
lists/views.py

Doesn't that feel good?  The view functions are looking much simpler. We re-run
the tests to make sure... Yes, 6 tests OK. 

Finally, let's wire up our two forms to use this new URL.  In 'both'
'home.html' and 'lists.html':

[source,html]
----
    <form method="POST" action="/lists/new" >
----
[role="caption"]
lists/templates/home.html, lists/templates/list.html

And we re-run our FTs to make sure everything still works...

----
AssertionError: u'http://localhost:8081/lists/the-only-list-in-the-world/' ==
u'http://localhost:8081/lists/the-only-list-in-the-world/'
----

Yup, we get to the same point we did before. That's a nicely self-contained
commit, and our 'views.py' is looking much neater and tidier.  We're getting
good at this refactoring malarkey!

[subs="specialcharacters,quotes"]
----
$ *git status* # 5 changed files
$ *git diff* # URLs for forms x2, moved code in views + tests, new URL
$ *git commit -a* 
----


Adjusting our models
~~~~~~~~~~~~~~~~~~~~

OK, enough housekeeping with our URLs. It's time to bite the bullet and
change our models.  Let's adjust our unit tests. Perhaps showing you a 
diff output might be the best way to show the changes?

[source,diff]
----
-from lists.models import Item
+from lists.models import Item, List
 from lists.views import home_page
 
 
@@ -62,14 +62,21 @@ class ListViewTest(TestCase):
-class ItemModelTest(TestCase):
+class ListAndItemModelsTest(TestCase):
 
     def test_saving_and_retrieving_items(self):
+        list = List()
+        list.save()
 
         first_item = Item()
         first_item.text = 'The first (ever) list item'
+        first_item.list = list
         first_item.save()
 
         second_item = Item()
         second_item.text = 'Item the second'
+        second_item.list = list
         second_item.save()
 
+        saved_lists = List.objects.all()
+        self.assertEqual(saved_lists.count(), 1)
+        self.assertEqual(saved_lists[0], list)
         saved_items = Item.objects.all()
         self.assertEqual(saved_items.count(), 2)

         first_saved_item = saved_items[0]
         second_saved_item = saved_items[1]
         self.assertEqual(first_saved_item.text, 'The first (ever) list item')
+        self.assertEqual(first_saved_item.list, list)
         self.assertEqual(second_saved_item.text, 'Item the second')
+        self.assertEqual(second_saved_item.list, list)
----
[role="caption"]
lists/tests.py

We create a new `List` object, and then we assign each item to it
by assigning it as its `.list` property.  We check the list is properly
saved, and we check that the two items have also saved their relationship
to the list.

Let's unit-test/code cycle this in.  I'm just going to show the test errors
for the first couple, and let you figure out for yourself what the code
should be:

----
ImportError: cannot import name List
----

----
AttributeError: 'List' object has no attribute 'save'
----

----
    self.assertEqual(first_saved_item.list, list)
AttributeError: 'Item' object has no attribute 'list'
----

How do we give our Item a list attribute?  Let's just try making it
like the text attribute:


[source,python]
----
class Item(models.Model):
    text = models.TextField()
    list = models.TextField()
----
[role="caption"]
lists/models.py


That give us:

    AssertionError: u'List object' != <List: List object>

Not quite -- Django has only saved the string representation the list object.
To save the relationship to the object itself, we tell Django about the 
relationship between the two classes using a `ForeignKey`:

[source,python]
----
class List(models.Model):
    pass

class Item(models.Model):
    text = models.TextField()
    list = models.ForeignKey(List)
----
[role="caption"]
lists/models.py

Now what happens?

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test functional_tests*]
 Creating test database for alias 'default'...
 ....EE
 ======================================================================
 ERROR: test_list_view_displays_all_items (lists.tests.ListViewTest)
 ----------------------------------------------------------------------
 Traceback (most recent call last):
   File "/media/SHARED/Dropbox/book/source/chapter_6/superlists/lists/tests.py",
 line 50, in test_list_view_displays_all_items
     Item.objects.create(text='itemey 1')
     [...]
     return Database.Cursor.execute(self, query, params)
 IntegrityError: lists_item.list_id may not be NULL
 
 ======================================================================
 ERROR: test_saving_a_POST_request (lists.tests.NewListTest)
 ----------------------------------------------------------------------
 Traceback (most recent call last):
   File "/media/SHARED/Dropbox/book/source/chapter_6/superlists/lists/tests.py",
 line 36, in test_saving_a_POST_request
     data={'item_text': 'A new list item'}
     [...]
     return Database.Cursor.execute(self, query, params)
 IntegrityError: lists_item.list_id may not be NULL
 
 ----------------------------------------------------------------------
 Ran 6 tests in 0.017s
----

Oh gawd!  Well, our model tests are passing but two of our view tests are
failing, because Items have to be associated with a list now. Let's get them
working again.  The easiest is the `ListViewTest`, we just create a parent
list for our two test items:

[source,python]
----
class ListViewTest(TestCase):

    def test_list_view_displays_all_items(self):
        list = List.objects.create()
        Item.objects.create(text='itemey 1', list=list)
        Item.objects.create(text='itemey 2', list=list)
----
[role="caption"]
lists/tests.py

That gets us down to 1 failing test.  Decoding its traceback, it fails
in the view:

----
  File "/media/SHARED/Dropbox/book/source/chapter_6/superlists/lists/views.py",
     line 9, in new_list
    Item.objects.create(text=request.POST['item_text'])
----

So we make a similar change in the view:

[source,python]
----
from lists.models import Item, List
[...]
def new_list(request):
    list = List.objects.create()
    Item.objects.create(text=request.POST['item_text'], list=list)
    return redirect('/lists/the-only-list-in-the-world/')
----
[role="caption"]
lists/views.py

Are you cringing internally at this point?  ``Arg! This feels so wrong, we
create a new list for every single new item submission, and we're still just
displaying all items as if they belong to the same list!  Yuck yuck yuck!''.
I know, I feel the same.  The step-by-step approach, in which you go
from working code to working code, is counterintuitive. I always feel like
just diving in and fix everything all in one go, instead of going from one
weird half-finished state to another.  But remember the Testing Goat!  When
you're up a mountain, you want to think very carefully about where you put each
foot, and take one step at a time, checking at each stage that the place you've
put it hasn't caused you to fall off a cliff.

And, again, you don't have to 'always' code like this.  When things are simple,
you probably 'can' get away with doing several steps at once.  What we're doing
here is practising for the hard cases -- one occasion that pops into my head is
a recent one where we decided to refactor the payment processing system at
work.  You can bet we were extremely careful when we worked through that, but 
thanks to using small steps, we got it right first time.

Anyway, just to reassure ourselves that things have worked, we can re-run the
FT.  Sure enough, it gets all the way through to where we were before.  We
haven't broken anything, and we've made a change to the database.  That's
something to be pleased with! Let's commit:

[subs="specialcharacters,quotes"]
----
$ *git status* # 3 changed files
$ *git diff* 
$ *git commit -a* 
----


The final stage:  each list should have its own URL
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

What shall we use as the unique identifier for our lists?  Probably the
simplest thing, for now, is just to use the auto-generated `id` field
from the database. Let's change `ListViewTest`, make it use the
URL for a particular list, and check that no other list items appear:

[source,python]
----
class ListViewTest(TestCase):

    def test_list_view_displays_items_for_that_list(self):
        list = List.objects.create()
        Item.objects.create(text='itemey 1', list=list)
        Item.objects.create(text='itemey 2', list=list)

        other_list = List.objects.create()
        Item.objects.create(text='other list item 1', list=other_list)
        Item.objects.create(text='other list item 2', list=other_list)

        client = Client()
        response = client.get('/lists/%d/' % (list.id,))

        self.assertIn('itemey 1', response.content)
        self.assertIn('itemey 2', response.content)
        self.assertNotIn('other list item 1', response.content)
        self.assertNotIn('other list item 2', response.content)
        self.assertTemplateUsed(response, 'list.html')
----
[role="caption"]
lists/tests.py

(if you're not familiar with Python string substitutions, that `%d` may
be a little confusing?  It may be worth going to look them up quickly now...
<<dip,Dive into Python>> has a http://www.diveintopython.net/native_data_types/formatting_strings.html[good overview])

Running the unit tests gives us:

----
AssertionError: 'itemey 1' not found in '404 Page not found. Try another
URL.\n'
----

It's time to learn how we can pass parameters from URLs to views:



[source,python]
----
urlpatterns = patterns('',
    url(r'^$', 'lists.views.home_page', name='home'),
    url(r'^lists/(.+)/$', 'lists.views.view_list', name='view_list'),
    url(r'^lists/new$', 'lists.views.new_list', name='new_list'),
----
[role="caption"]
superlists/urls.py

We adjust the regular expression for our URL to include a 'capture group',
`(.+)`, which will match any characters, up to the following `/`. The captured
text will get passed to the view as its first argument. But our view doesn't
expect an argument yet! Sure enough, this causes problems:

////
TODO:  This could be better illustrated with the old way of testing urls...
consider switching back?
////

----
ERROR: test_list_view_displays_all_items (lists.tests.ListViewTest)
[...]
TypeError: view_list() takes exactly 1 argument (2 given)

ERROR: test_saving_a_POST_request (lists.tests.NewListTest)
[...]
TypeError: view_list() takes exactly 1 argument (2 given)
----

We can fix that easily with a dummy parameter in 'views.py'

[source,python]
----
def view_list(request, list_id):
----
[role="caption"]
lists/views.py

Now we're down to our expected failure:

    self.assertNotIn('other list item 1', response.content)
AssertionError: 'other list item 1' unexpectedly found in [...]

Let's make our view discriminate over which items it sends to the 
template:

[source,python]
----
def view_list(request, list_id):
    list = List.objects.get(id=list_id)
    items = Item.objects.filter(list=list)
    return render(request, 'list.html', {'items': items})
----
[role="caption"]
lists/views.py

Now we get an error in another test:

----
ERROR: test_saving_a_POST_request (lists.tests.NewListTest)
    self.assertRedirects(response, '/lists/the-only-list-in-the-world/')
    [...]
    return int(value)
ValueError: invalid literal for int() with base 10: 'the-only-list-in-the-world'
----

Let's take a look at this test then, since it's whining.  Hm, it looks like it
hasn't been adjusted to the new world of Lists and Items. In fact, this brings
to mind the fact that we actually need to treat the creation of 'new' lists
differently from the addition of new items to 'existing' lists.  

Let's adjust the test to the new world, showing that it expects this
view to create a brand new list:

[source,python]
----
    self.assertEqual(List.objects.all().count(), 1)
    new_list = List.objects.all()[0]
    self.assertEqual(Item.objects.all().count(), 1)
    new_item = Item.objects.all()[0]
    self.assertEqual(new_item.text, 'A new list item')
    self.assertEqual(new_item.list, new_list)

    self.assertRedirects(response, '/lists/%d/' % (new_list.id,))
----
[role="caption"]
lists/tests.py

That still gives us the 'invalid literal' error. Let's take a look at the view
itself, and change it so it redirects to a valid place:

[source,python]
----
    return redirect('/lists/%d/' % (list.id,))
----
[role="caption"]
lists/views.py

That gets us back to passing unit tests.  What about the functional 
tests?  We must be almost there?

----
AssertionError: '2: Use peacock feathers to make a fly' not found in 
[u'1: Use peacock feathers to make a fly']
----

A regression -- because we're now creating a new list for every single
POST submission.  We need a URL and view to handle adding a new item
to an existing list.  We're getting pretty good at these now, so let's
knock one together quickly:

[source,python]
----
class NewItemTest(TestCase):

    def test_saving_a_POST_request_to_an_existing_list(self):
        list = List.objects.create()
        other_list = List.objects.create()
        client = Client()
        response = client.post(
            '/lists/%d/new_item' % (list.id,),
            data={'item_text': 'A new item for an existing list'}
        )

        self.assertEqual(Item.objects.all().count(), 1)
        new_item = Item.objects.all()[0]
        self.assertEqual(new_item.text, 'A new item for an existing list')
        self.assertEqual(new_item.list, list)

        self.assertRedirects(response, '/lists/%d/' % (list.id,))
----
[role="caption"]
lists/tests.py

We get 

----
AssertionError: 0 != 1
----

Again, this is because the view is actually giving a 404 (we can check
by moving the `assertRedirects` higher in the test if we like)

Add a new url in urls.py:

[source,python]
----
urlpatterns = patterns('',
    url(r'^$', 'lists.views.home_page', name='home'),
    url(r'^lists/(.+)/$', 'lists.views.view_list', name='view_list'),
    url(r'^lists/(.+)/new_item$', 'lists.views.add_item', name='add_item'),
    url(r'^lists/new$', 'lists.views.new_list', name='new_list'),
----
[role="caption"]
superlists/urls.py

Hm, three very similar-looking URLs there.  Let's make a note on our
to-do list, they look like good candidates for a refactoring.

We now get:

----
ViewDoesNotExist: Could not import lists.views.add_item. View does not exist in module lists.views.
----

Let's try:


[source,python]
----
def add_item(request):
    pass
----
[role="caption"]
lists/views.py

Aha:

    TypeError: add_item() takes exactly 1 argument (2 given)

[source,python]
----
def add_item(request, list_id):
    pass
----
[role="caption"]
lists/views.py

And then:

    ValueError: The view lists.views.add_item didn't return an HttpResponse object.


let's copy the `redirect` from `new_list` and the `List.objects.get` from
`view_list`:

[source,python]
----
def add_item(request, list_id):
    list = List.objects.get(id=list_id)
    return redirect('/lists/%d/' % (list.id,))
----
[role="caption"]
lists/views.py

----
    self.assertEqual(Item.objects.all().count(), 1)
AssertionError: 0 != 1
----

And finally let's make it save our new list item:


[source,python]
----
def add_item(request, list_id):
    list = List.objects.get(id=list_id)
    Item.objects.create(text=request.POST['item_text'], list=list)
    return redirect('/lists/%d/' % (list.id,))
----
[role="caption"]
lists/views.py

Now we just need to use this URL in our 'list.html' template.  Open it
up and adjust the form tag...

[source,html]
----
    <form method="POST" action="what should we put here?" >
----
[role="caption"]
lists/templates/list.html
        

\... oh. To get the URL for adding to the current list, the template needs to
know what list it's rendering, as well as what the items are.  Let's adjust our
unit test `ListViewTest`, and add an extra check at the end:

[source,python]
----
    self.assertNotIn('other list item 2', response.content)
    self.assertTemplateUsed(response, 'list.html')
    self.assertEqual(response.context['list'], list)
----
[role="caption"]
lists/tests.py

That gives us `KeyError: 'list'` because we're not passing list into 
the template.  It actually gives us an opportunity to simplify a little

[source,python]
----
def view_list(request, list_id):
    list = List.objects.get(id=list_id)
    return render(request, 'list.html', {'list': list})
----
[role="caption"]
lists/views.py

That, of course, will break because the template is expecting `items`, 
but we can fix it in 'list.html'

[source,html]
----
    <form method="POST" action="/lists/{{ list.id }}/new_item" >

    [...]

    {% for item in list.item_set.all %}
        <tr><td>{{ forloop.counter }}: {{ item.text }}</td></tr>
    {% endfor %}
----
[role="caption"]
lists/templates/list.html

`.item_set` is called a ``reverse lookup'' -- it's one of Django's
incredibly useful bits of ORM, that lets you look up an object's 
related items...

So that gets the unit tests to pass.  How about the FT?

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test functional_tests*]
 Creating test database for alias 'default'...
 .
 ----------------------------------------------------------------------
 Ran 1 test in 5.824s
 
 OK
----

YES!  And a quick check on our to-do list:

* [line-through]#Adjust model so that items are associated with different
lists#
* [line-through]#Add unique URLs for each list#
* [line-through]#Add a URL for creating a new list via POST#
* [line-through]#Add URLs for adding a new item to an existing list via POST#
* Refactor away some duplication in 'urls.py'

Irritatingly, the Testing Goat is a stickler for tying up loose ends too, so 
we've got to do this one final thing.

Before we start, we'll do a commit - always make sure you've got a commit
of a working state before embarking on a refactor

[subs="specialcharacters,quotes"]
----
$ *git diff* 
$ *git commit -am"new URL + view for adding to existing lists. FT passes!"*
----

A final refactor using URL includes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

'superlists/urls.py', strictly speaking, is meant for URLs that apply to your 
entire site.  For URLs that only apply to the lists app, we can use a 
separate 'lists/urls.py', to make the app more self-contained.  The simplest
thing to do to start is to make a copy of the existing urls.py:

[subs="specialcharacters,quotes"]
----
$ *cp superlists/urls.py lists/*
----

Then we replace 3 lines in 'superlists/urls.py' with an `include`.  Notice
that `include` can take a part of a URL regex as a prefix, which will be
applied to all the included URLs (this is the bit where we reduce duplication,
as well as giving our code a better structure).

[source,python]
----
urlpatterns = patterns('',
    url(r'^$', 'lists.views.home_page', name='home'),
    url(r'^lists/', include('lists.urls')),

    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    # url(r'^admin/', include(admin.site.urls)),
)
----
[role="caption"]
superlists/urls.py

And 'lists/urls.py' we can trim down to only include the latter part
of our 3 URLs, and none of the other stuff from the parent urls.py:



[source,python]
----
from django.conf.urls import patterns, url

urlpatterns = patterns('',
    url(r'^(.+)/$', 'lists.views.view_list', name='view_list'),
    url(r'^(.+)/new_item$', 'lists.views.add_item', name='add_item'),
    url(r'^new$', 'lists.views.new_list', name='new_list'),
)
----
[role="caption"]
lists/urls.py

And re-run the unit tests to check everything worked.  When I did it, I
couldn't quite believe I did it correctly on the first go, so I deliberately
changed one of the URLs slightly, just to check if it broke a test. It did. 
We're covered.

[subs="specialcharacters,quotes"]
----
$ *git status* 
$ *git add lists/urls.py* 
$ *git add superlists/urls.py* 
$ *git diff --staged* 
$ *git commit* 
----

Phew. A marathon chapter. But we covered a number of important topics,
starting with test isolation, we did some thinking about design. We saw how
to adapt an existing site step-by-step, going from working state to working
state, in order to iterate towards our new REST-ish structure.  We covered some
rules of thumb like ``YAGNI'' and ``3 strikes then refactor''

I'd say we're pretty close to being able to ship this site, as the very first
beta of the superlists website that's going to take over the world.  Maybe it
needs a little prettification first... Let's look at what we need to do to
release it in the next chapter.

