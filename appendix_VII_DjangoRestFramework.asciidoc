[[appendix-rest-api-frontend]]
[appendix]
Django-Rest-Framework
---------------------

WARNING: Chapter under construction.  Apologies, it's in pretty telegraphic style for now.

(((REST)))
(((API)))
I can't write a book involving Django and tell you to build a REST API without
telling you to at least investigate
http://www.django-rest-framework.org/[Django-Rest-Framework].


Writing this appendix, one of the main thing I struggled with was getting the
exact same API that I'd just implemented manually to be replicated by DRF. 
Getting the same URL layout and the same JSON data structures I'd defined,
proved to be quite a challenge, and I felt like I was fighting the framework.

That's always a warning sign.  The people who built Django-Rest-Framework
are a lot smarter than I am, and they've seen a lot more REST APIs than I
have, and if they're opinionated about the way that things "should" look,
then maybe my time would be better spent seeing if I can adapt and work
with their view of the world, rather than forcing my own preconceptions
onto it.

"Don't fight the framework" is one of the great pieces of advice I've heard.
Either go with the flow, or perhaps re-assess whether you want to be using
a framework at all.

We'll work from the API we had at the end of the last chapter, 
and see if we can rewrite it to use DRF.


Serializers (well, ModelSerializers really)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The http://www.django-rest-framework.org/#tutorial[Django-Rest-Framework tutorial]
is a pretty good resource to learn DRF.  The first thing you'll come across
is serializers, and specifically in our case, "ModelSerializers". They are
DRF's way of converting from Django database models to JSON (or possibly other
formats) that you can send over the wire.

 

TODO: add an explicit unit test or two for serialization


[role="sourcecode"]
.lists/api.py
[source,python]
----
class ItemSerializer(serializers.ModelSerializer):

    class Meta:
        model = Item
        fields = ('id', 'text')


class ListSerializer(serializers.ModelSerializer):
    items = ItemSerializer(many=True, source='item_set')

    class Meta:
        model = List
        fields = ('id', 'items',)
----


Viewsets (well, ModelViewsets really) and routers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Retrieving all items for a list


[role="sourcecode"]
.lists/api.py
[source,python]
----
class ListViewSet(viewsets.ModelViewSet):
    queryset = List.objects.all()
    serializer_class = ListSerializer

router = routers.SimpleRouter()
router.register(r'lists', ListViewSet)
----


tweak existing test bc of extra "items" key:

[role="sourcecode"]
.lists/tests/test_api.py
[source,python]
----
    self.assertEqual(
        json.loads(response.content.decode('utf8')),
        {'id': our_list.id, 'items': [
            {'id': item1.id, 'text': item1.text},
            {'id': item2.id, 'text': item2.text},
        ]}
    )
----


A different URL for POST item 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This is the point at which I gave up on fighting the framework
and just saw where DRF wanted to take me. You post to an item view, not a list
view:


[role="sourcecode"]
.lists/api.py
[source,python]
----
class ItemViewSet(viewsets.ModelViewSet):
    serializer_class = ItemSerializer
    queryset = Item.objects.all()


router = routers.SimpleRouter()
router.register(r'lists', ListViewSet)
router.register(r'items', ItemViewSet)
----


So that means we change the test slightly

[role="sourcecode"]
.lists/tests/test_api.py
[source,python]
----
class ItemsAPITest(TestCase):
    base_url = reverse('api:item-list')

    def test_POSTing_a_new_item(self):
        list_ = List.objects.create()
        response = self.client.post(
            self.base_url,
            {'list': list_.id, 'text': 'new item'},
        )
        self.assertEqual(response.status_code, 201)
        new_item = list_.item_set.get()
        self.assertEqual(new_item.text, 'new item')
[...]
----

And so on.  Also need to add the list id to our serialization of items,
otherwise we don't know what list it's for:


[role="sourcecode"]
.lists/api.py
[source,python]
----
class ItemSerializer(serializers.ModelSerializer):

    class Meta:
        model = Item
        fields = ('id', 'list', 'text')
----


And that causes a few more associated test changes.


Adapting the client side
~~~~~~~~~~~~~~~~~~~~~~~~

* `response.items`


[role="sourcecode"]
.lists/static/list.js
[source,diff]
----
 window.Superlists.updateItems = function (url) {
   $.get(url).done(function (response) {
+    if (!response.items) {return;}
     var rows = '';
-    for (var i=0; i<response.length; i++) {
-      var item = response[i];
+    for (var i=0; i<response.items.length; i++) {
+      var item = response.items[i];
       rows += '\n<tr><td>' + (i+1) + ': ' + item.text + '</td></tr>';
     }
     $('#id_list_table').html(rows);
   });
 };
----

* `initialize` with 3 params, including different urls
  for retrieving list and posting new items
 
[role="sourcecode"]
.lists/static/list.js
[source,diff]
----
-window.Superlists.initialize = function (url) {
+window.Superlists.initialize = function (params) {
   $('input[name="text"]').on('keypress', function () {
     $('.has-error').hide();
   });
 
-  if (url) {
-    window.Superlists.updateItems(url);
+  if (params) {
+    window.Superlists.updateItems(params.listApiUrl);
 
     var form = $('#id_item_form');
     form.on('submit', function(event) {
       event.preventDefault();
-      $.post(url, {
+      $.post(params.itemsApiUrl, {
+        'list': params.listId,
         'text': form.find('input[name="text"]').val(),
         'csrfmiddlewaretoken': form.find('input[name="csrfmiddlewaretoken"]').val(),
       }).done(function () {
         $('.has-error').hide();
-        window.Superlists.updateItems(url);
+        window.Superlists.updateItems(params.listApiUrl);
       }).fail(function (xhr) {
         $('.has-error').show();
----


And a few more to do with error handling, which you can explore in the
https://github.com/hjwp/book-example/blob/appendix_VII_DjangoRestFramework/lists/api.py[repo for this appendix] if
you're curious.


What Django-Rest-Framework gives you
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You may be wondering what the point of using this framework was.


Configuration instead of code
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Well, the first advantage is that I've transformed my old procedural view
function into a more declarative syntax


[role="sourcecode skipme"]
.lists/api.py (old version)
[source,python]
----
def list(request, list_id):
    list_ = List.objects.get(id=list_id)
    if request.method == 'POST':
        form = ExistingListItemForm(for_list=list_, data=request.POST)
        if form.is_valid():
            form.save()
            return HttpResponse(status=201)
        else:
            return HttpResponse(
                json.dumps({'error': form.errors['text'][0]}),
                content_type='application/json',
                status=400
            )
    item_dicts = [
        {'id': item.id, 'text': item.text}
        for item in list_.item_set.all()
    ]
    return HttpResponse(
        json.dumps(item_dicts),
        content_type='application/json'
    )
----

If you compare this to the final DRF version, you'll notice that it is actually
entirely configuration:


[role="sourcecode skipme"]
.lists/api.py (new version)
[source,python]
----
class ItemSerializer(serializers.ModelSerializer):
    text = serializers.CharField(
        allow_blank=False, error_messages={'blank': EMPTY_ITEM_ERROR}
    )

    class Meta:
        model = Item
        fields = ('id', 'list', 'text')
        validators = [
            UniqueTogetherValidator(
                queryset=Item.objects.all(),
                fields=('list', 'text'),
                message=DUPLICATE_ITEM_ERROR
            )
        ]


class ListSerializer(serializers.ModelSerializer):
    items = ItemSerializer(many=True, source='item_set')

    class Meta:
        model = List
        fields = ('id', 'items',)


class ListViewSet(viewsets.ModelViewSet):
    queryset = List.objects.all()
    serializer_class = ListSerializer


class ItemViewSet(viewsets.ModelViewSet):
    serializer_class = ItemSerializer
    queryset = Item.objects.all()


router = routers.SimpleRouter()
router.register(r'lists', ListViewSet)
router.register(r'items', ItemViewSet)
----


Free functionality
^^^^^^^^^^^^^^^^^^

The second advantage is that, by using DRF's `ModelSerializer`, `ViewSet` and
routers, I've actually ended up with a much more extensive API than the one I'd
rolled by hand.

* GET, POST, OPTIONS methods now work, out of the box, for all list and items URLs.

* And a browsable / self-documenting version is available at
  http://localhost:8000/api/lists/ and http://localhost:8000/api/items. (Try it! You'll
  need to add `rest_framework` to `INSTALLED_APPS`).

.A free browsable API for your users
image::images/drf-screenshot.png["Screenshot of DRF browsable api page at http://localhost:8000/api/items/"]


There's more information in
http://www.django-rest-framework.org/topics/documenting-your-api/#self-describing-apis[the
DRF docs], but those are both seriously neat features to be able to offer the
end-users of your API.


In short, DRF is a great way of generating APIs, almost automatically, based on
your existing models structure.  If you're using Django, definitely check it
out before you start hand-rolling your own API code.


.Django-Rest-Framework tips
*******************************************************************************

Don't fight the framework::
    Going with the flow is often the best way to stay productive.  That, or
    maybe don't use the framework.  Or use it at a lower level.

Routers and Viewsets for the principle of least surprise::
    One of the advantages of DRF is that its generic tools like routers and
    viewsets will give you a very predicatable API, with sensible defaults
    for its endpoints, URL structure, and responses for different HTTP methods.

Check out the self-documenting, browsable version::
    Check out your API endpoints in a browser. DRF responds differently when it
    detects your API is being accessed by a "normal" web browser, and displays
    a very nice, self-documenting version of itself, which you can share with
    your users.

*******************************************************************************

