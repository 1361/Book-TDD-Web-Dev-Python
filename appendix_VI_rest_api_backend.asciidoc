[[appendix-rest-api-backend]]
[appendix]
Building a REST API
-------------------

(((REST)))
(((API)))
Chapter under construction


Plan:

* All assumes an existing list
* new URL structure /api/lists/{id}/
* GET gives you details of a list (including all its items)
* POST lets you add an item


Basic piping
~~~~~~~~~~~~



Start with a unit test that we can return a JSON response, status 200, from a URL

[role="sourcecode"]
.lists/tests.py
[source,python]
----
import json
from django.test import TestCase

from lists.models import List, Item


class APIGetListItemsTest(TestCase):
    base_url = '/api/lists/{}/'  #<1>

    def test_get_returns_json_200(self):
        list_ = List.objects.create()
        response = self.client.get(self.base_url.format(list_.id))
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['content-type'], 'application/json')
----


<1> This is a new pattern we'll introduce for this chapter, it'll help
    us to remove duplication of hard-coded urls in this test.  We could
    even have used a call to `reverse`


And we can get that together in 3 lines


[role="sourcecode"]
.lists/tests.py
[source,python]
----
from django.http import HttpResponse

def list(request, list_id):
    return HttpResponse(content_type='application/json')
----

And wire up a couple of urls files:

[role="sourcecode"]
.lists/tests.py
[source,python]
----
[...]
from lists import api_urls
from lists import urls as list_urls

urlpatterns = [
    url(r'^$', list_views.home_page, name='home'),
    url(r'^lists/', include(list_urls)),
    url(r'^accounts/', include(accounts_urls)),
    url(r'^api/', include(api_urls)),
]
----


[role="sourcecode"]
.lists/api_urls.py
[source,python]
----
from django.conf.urls import url
from lists import api

urlpatterns = [
    url(r'^lists/(\d+)/$', api.list, name='api_list'),
]
----

The tests should pass, and we have the basic piping together.

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
Creating test database for alias 'default'...
..................................................
 ---------------------------------------------------------------------
Ran 50 tests in 0.177s

OK
----


Actually responding something
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


[role="sourcecode"]
.lists/tests.py
[source,python]
----
    def test_get_returns_items_for_correct_list(self):
        other_list = List.objects.create()
        Item.objects.create(list=other_list, text='item 1')
        our_list = List.objects.create()
        item1 = Item.objects.create(list=our_list, text='item 1')
        item2 = Item.objects.create(list=our_list, text='item 2')
        response = self.client.get(self.base_url.format(our_list.id))
        self.assertEqual(
            json.loads(response.content.decode('utf8')),  #<1>
            [
                {'id': item1.id, 'text': item1.text},
                {'id': item2.id, 'text': item2.text},
            ]
        )
----

<1> This is the main thing to notice about this test -- we expect our
    response to be in JSON format.  We use `json.loads()` because testing
    python objects is easier than messing about with raw JSON strings.


And the implementation, conversely, uses `json.dumps()`

[role="sourcecode"]
.lists/tests.py
[source,python]
----
import json
from django.http import HttpResponse
from lists.models import List


def list(request, list_id):
    list_ = List.objects.get(id=list_id)
    item_dicts = [
        {'id': item.id, 'text': item.text}
        for item in list_.item_set.all()
    ]
    return HttpResponse(
        json.dumps(item_dicts),
        content_type='application/json'
    )
----


Adding POST
~~~~~~~~~~~

We'll start with the "happy path":


[role="sourcecode"]
.lists/tests.py
[source,python]
----
    def test_POSTing_a_new_item(self):
        list_ = List.objects.create()
        response = self.client.post(
            self.base_url.format(list_.id),
            {'text': 'new item'},
        )
        self.assertEqual(response.status_code, 201)
        new_item = list_.item_set.get()
        self.assertEqual(new_item.text, 'new item')
----


And the implementation is similarly simple -- basically
the same was what we do in our normal view, but we return
a 201 rather than a redirect:


[role="sourcecode"]
.lists/tests.py
[source,python]
----
def list(request, list_id):
    list_ = List.objects.get(id=list_id)
    if request.method == 'POST':
        Item.objects.create(list=list_, text=request.POST['text'])
        return HttpResponse(status=201)
    [...]
----


And that should get us started.


Testing the client-side with sinon.js
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Don't even 'think' of doing Ajax testing without a mocking library.  Different test frameworks
and tools have their own, sinon is generic.  It also provides JavaScript mocks, as we'll see...

http://sinonjs.org/


[role="sourcecode"]
.lists/static/tests/tests.html
[source,html]
----
  <div id="qunit-fixture">
    <form>
      <input name="text" />
      <div class="has-error">Error text</div>
    </form>
    <table id="id_list_table">  <!--<1>-->
    </table>
  </div>

  <script src="../jquery-3.1.1.min.js"></script>
  <script src="../list.js"></script>
  <script src="qunit-2.0.1.js"></script>
  <script src="sinon-1.17.6.js"></script>  <!--<2>-->

  <script>
/* global sinon */
var server;
QUnit.testStart(function () {
  server = sinon.fakeServer.create();  //<3>
});
QUnit.testDone(function () {
  server.restore();  //<3>
});

QUnit.test("errors should be hidden on keypress", function (assert) {
[...]


QUnit.test("should get items by ajax on initialize", function (assert) {
  var url = '/getitems/';
  window.Superlists.initialize(url);

  assert.equal(server.requests.length, 1); //<4>
  var request = server.requests[0];
  assert.equal(request.url, url);
  assert.equal(request.method, 'GET');
});

  </script>
----

<1> We add a new item to the fixture div to represent our list table

<2> We import 'sinon.js'

<3> `testStart` and `testDone` are the QUnit equivalents of `setUp` and
    `tearDown`.  We use them to tell sinon to start up its ajax testing
    tool, the `fakeServer`.

<4> That lets us make assertions about any ajax requests that were made
    by our code.


And we can get that passing with this

[role="sourcecode"]
.lists/static/lists.js
[source,diff]
----
@@ -1,6 +1,10 @@
 window.Superlists = {};
-window.Superlists.initialize = function () {
+window.Superlists.initialize = function (url) {
   $('input[name="text"]').on('keypress', function () {
     $('.has-error').hide();
   });
+
+  $.get(url);
+
 };
----


----
Took 35ms to run 5 tests. 5 passed, 0 failed.
----

But what about the async part, where we deal with the response?


Sinon and testing the async part of Ajax
++++++++++++++++++++++++++++++++++++++++

This is a major reason to love sinon.  `server.respond()` allows us to exactly
control the flow of the async code.


[role="sourcecode"]
.lists/static/tests/tests.html
[source,html]
----
QUnit.test("should fill in lists table from ajax response", function (assert) {
  var url = '/getitems/';
  var responseData = [
    {'id': 101, 'text': 'item 1 text'},
    {'id': 102, 'text': 'item 2 text'},
  ];
  server.respondWith('GET', url, [
    200, {"Content-Type": "application/json"}, JSON.stringify(responseData) //<1>
  ]);
  window.Superlists.initialize(url); //<2>

  server.respond(); //<3>

  var rows = $('#id_list_table tr');
  assert.equal(rows.length, 2);
  var row1 = $('#id_list_table tr:first-child td');
  console.log(row1);
  assert.equal(row1.text(), '1: item 1 text');
  var row2 = $('#id_list_table tr:last-child td');
  assert.equal(row2.text(), '2: item 2 text');
});
----

<1> We set up some response data for sinon to use, telling it what status code, headers,
    and importantly what kind of response JSON we want to simulate coming from the
    server.

<2> Then we call the function under test

<3> Here's the magic.  'Then' we can call `server.respond()`, whenever we like, and that
    will kick off all the async part of the Ajax loop -- all the callbacks we'd assigned
    to deal with the response.

And then we can quietly check whether our Ajax callback has actually populated our table
with the new list rows...

TIP: We're lucky because of the way jQuery registers its callbacks for Ajax when we use
    the `.done()` function.  If you want to switch to the more standard JavaScript promise
    `.then()` callback, we get one more level of async.  QUnit does have a way of dealing with
    that.  Check out the docs for the http://api.qunitjs.com/async/[async] function.  Other test
    frameworks have something similar.



Wiring it all up in the template and checking this first part
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~





.REST API tips
*******************************************************************************

dedupe ursl::
    in test

don't work with raw json strings::
    json.loads and json.dumps are your friend.

always use an ajax mocking library for your js tests::
    sinon is fine.  Jasmine has its own, as does Angular.

*******************************************************************************

