More complex forms
------------------

So our beautiful lists site has been live for a few days, and our users are
starting to come back to us with feedback.  "Hey, we'd really like to be 
able to add some notes to our tasks", they say.

Let's see how that might work as an FT:


[source,python]
.functional_tests/tests.py
----
def test_adding_notes(self):
    # Edith starts a new list

    # She notices a link next to her first new item that says "edit notes"
    # so she clicks it

    # She is presented with a form that allows her to write in some notes

    # She cicks submit and the note now shows up in the list

    # She enters a second item, and edits it to add a second,
    # longer note

    # Now when she clicks submit she sees that the text of
    # her second note is abbreviated.

    # She sees a "more" link, which she clicks, which takes
    # her to a page with the full note content.

    # She wonders whether there is a page for shorter notes
    # too, and realises that list items are clickable. She
    # can view her short item too.
----

Now let's start implementing the test, or at least the beginning of it:

[source,python]
.functional_tests/tests.py
----
def test_adding_notes(self):
    # Edith starts a new list
    self.browser.get(self.server_url)
    self.browser.find_element_by_id('id_new_item').send_keys("Buy milk\n")
    self.check_for_row_in_list_table("Buy milk")

    # She notices a link next to her first new item that says "edit notes"
    # so she clicks it
    self.browser.find_element_by_link_text("edit notes").click()

    # She is presented with a form that allows her to write in some notes
    self.browser.find_element_by_name('notes').send_keys(
        "You can find milk in a shop"
    )

    # She cicks submit and the note now shows up in the list
    self.browser.find_element_by_css_selector('input[type=submit]').click()
    self.assertIn(
        "You can find milk in a shop",
        self.browser.find_element_by_tag_name('body').text
    )
    self.fail('finish me')
----

And we're off!

----
NoSuchElementException: Message: u'Unable to locate element: {"method":"link
text","selector":"edit notes"}' ; Stacktrace: [...]
----

////
TODO: dontify?
////


So the next thing to do is add a link to each list item that takes the user to
a new page where they can add notes to the list item.  How about this:

    /lists/<list-id>/item/<item-id>/edit_notes/

In fact, how about a to-do list:

* The list view should have links to individual edit_notes URLs
* The edit_notes view should render a form with an editable
text field and a submit button
* The form should submit to another URL -- say
`/lists/<list-id>/item/<item-id>/notes` -- to update the notes
* Notes can be saved as a new attribute of the Item model (this decision
would mean that we can only ever have one set of notes per list item, but we
can always revisit it later)


[source,python]
.lists/tests.py

----
class EditNotesViewTest(TestCase):

    def test_edit_notes_view_renders_form_to_edit_notes(self):
        list1 = List.objects.create()
        item1 = Item.objects.create(text='itemey 1', list=list1)
        item2 = Item.objects.create(text='itemey 2', list=list1)

        client = Client()
        response = client.get(
            '/lists/%d/item/%d/edit_notes/' % (list1.id, item2.id)
        )

        self.assertIn(
            'action="/lists/%d/item/%d/notes"' % (list1.id, item2.id),
            response.content
        )
        self.assertIn('<input name="notes" type="textfield"', response.content)
----

Running this test gives us an unexpected  error:

----
ValueError: invalid literal for int() with base 10: '1/item/2/edit_notes'
----

Let's try and decode the traceback to see what's going on.

Reading tracebacks
~~~~~~~~~~~~~~~~~~

A brief aside on reading tracebacks from unit tests.  When we get an unexpected
failure like this, it can be baffling at first, but there are a few things you
can look out for in each traceback to help you get your bearings:

----
======================================================================
ERROR: test_edit_notes_view_renders_form_to_edit_notes
(lists.tests.EditNotesViewTest) <2>
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/workspace/superlists/lists/tests.py",
line 98, in test_edit_notes_view_renders_form_to_edit_notes <3>
    '/lists/%d/item/%d/edit_notes/' % (list1.id, item2.id) <3>
  File "/usr/local/lib/python2.7/dist-packages/django/test/client.py", line
453, in get
    response = super(Client, self).get(path, data=data, **extra)
  File "/usr/local/lib/python2.7/dist-packages/django/test/client.py", line
279, in get
    return self.request(**r)
  File "/usr/local/lib/python2.7/dist-packages/django/test/client.py", line
424, in request
    six.reraise(*exc_info)
  File "/usr/local/lib/python2.7/dist-packages/django/core/handlers/base.py",
line 115, in get_response
    response = callback(request, *callback_args, **callback_kwargs)
  File "/workspace/superlists/lists/views.py",
line 15, in view_list <4>
    list = List.objects.get(id=list_id) <4>
  File "/usr/local/lib/python2.7/dist-packages/django/db/models/manager.py",
line 143, in get
    return self.get_query_set().get(*args, **kwargs)
  File "/usr/local/lib/python2.7/dist-packages/django/db/models/query.py", line
379, in get
    clone = self.filter(*args, **kwargs)
  File "/usr/local/lib/python2.7/dist-packages/django/db/models/query.py", line
655, in filter
    return self._filter_or_exclude(False, *args, **kwargs)
  File "/usr/local/lib/python2.7/dist-packages/django/db/models/query.py", line
673, in _filter_or_exclude
    clone.query.add_q(Q(*args, **kwargs))
  File "/usr/local/lib/python2.7/dist-packages/django/db/models/sql/query.py",
line 1266, in add_q
    can_reuse=used_aliases, force_having=force_having)
  File "/usr/local/lib/python2.7/dist-packages/django/db/models/sql/query.py",
line 1197, in add_filter
    connector)
  File "/usr/local/lib/python2.7/dist-packages/django/db/models/sql/where.py",
line 71, in add
    value = obj.prepare(lookup_type, value)
  File "/usr/local/lib/python2.7/dist-packages/django/db/models/sql/where.py",
line 339, in prepare
    return self.field.get_prep_lookup(lookup_type, value)
  File
"/usr/local/lib/python2.7/dist-packages/django/db/models/fields/__init__.py",
line 322, in get_prep_lookup
    return self.get_prep_value(value)
  File
"/usr/local/lib/python2.7/dist-packages/django/db/models/fields/__init__.py",
line 555, in get_prep_value
    return int(value)
ValueError: invalid literal for int() with base 10: '1/item/2/edit_notes' <1>

 ---------------------------------------------------------------------
Ran 8 tests in 0.062s

FAILED (errors=1)
----

<1> The first place you look is usually 'the error itself' -- sometimes that's
all you need to see, and it will let you identify the problem immediately. But
sometimes, like in this case, it's not quite self-evident.
<2> The next thing to double-check is: 'which test is failing?'  Is it
definitely the one we expected, ie the one we just wrote?  in this case, the
answer is yes.
<3> Then we look for two things:  first, the place in 'our test code' that
caused the error. In this case it's the line where we make the HTTP request
via the test client.
<4> Then we look further down for where in 'our application code' we seem to
have hit a problem.  In this case, we see it's line 15 in our 'views.py', in
the view function called `view_list`

That's a bit of a surprise -- why did we end up inside `view_list`?  We asked
for a URL that looks like '/lists/1/item/2/edit_notes/'... And it seems
to have ended up in `view_list`, thinking that it wanted to find a list
whose `id` was `1/item/2/edit_notes`.  Something has gone wrong in our 
URL mapping.

We can look at 'lists/urls.py' and begin to guess why:

[source,python]
.lists/urls.py
----
from django.conf.urls import patterns, url

urlpatterns = patterns('',
    url(r'^(.+)/$', 'lists.views.view_list', name='view_list'),
    url(r'^(.+)/new_item$', 'lists.views.add_item', name='add_item'),
    url(r'^new$', 'lists.views.new_list', name='new_list'),
)
----

The `url` entry for `view_list` tries to capture the list ID using a capture
group `(.+)`, which it turns out is too greedy -- that matches almost any
sequence of characters, as long as it ends in a slash.  We need to tighten it
up.  Currently, our list IDs are numeric, so we change our capture group to 
only capture numerical digits (`\d`):


[source,python]
.lists/urls.py
----
from django.conf.urls import patterns, url

urlpatterns = patterns('',
    url(r'^(\d+)/$', 'lists.views.view_list', name='view_list'),
    url(r'^(\d+)/new_item$', 'lists.views.add_item', name='add_item'),
    url(r'^new$', 'lists.views.new_list', name='new_list'),
)
----

I've changed the regex for `add_item` as well.  Let's try running the unit
tests again:

----
FAIL: test_edit_notes_view_renders_form_to_edit_notes (lists.tests.EditNotesViewTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/workspace/superlists/lists/tests.py", line 102, in test_edit_notes_view_renders_form_to_edit_notes
    self.assertIn('action="/lists/%d/notes"' % (list1.id,), response.content)
AssertionError: 'action="/lists/1/notes"' not found in '<h1>Not Found</h1><p>The requested URL /lists/1/item/2/edit_notes/ was not found on this server.</p>'
----


TODO:  move this explanation to much earlier in the book.  It's too useful,
make a deliberate mistake or something...


That's better!  Now our test is ending up finding a "Not found" error page,
which is the failure we expected -- we ask for a brand new URL we haven't coded
a view for yet, and we get a page not found error.

Let's re-run the FTs quickly to make sure we haven't broken anything... good,
and now do a commit:


[subs="specialcharacters,quotes"]
----
$ *git diff* # new FT, new unit test, 2 lines changed in urls.py
$ *git commit -am"New FT + first unit test for notes, tweak urls list id regex"*
----

Now we can get onto creating a new URL and view for our notes editing page.

We start by adding a new URL, with a regex that now has two capture groups for
digits:

[source,python]
.lists/urls.py
----
urlpatterns = patterns('',
    url(r'^(\d+)/$', 'lists.views.view_list', name='view_list'),
    url(r'^(\d+)/new_item$', 'lists.views.add_item', name='add_item'),
    url(r'^(\d+)/item/(\d+)/edit_notes/$', 'lists.views.edit_notes', name='edit_notes'),
    url(r'^new$', 'lists.views.new_list', name='new_list'),
)
----

That gives us a 

----
ViewDoesNotExist: Could not import lists.views.edit_notes. View does not exist
in module lists.views.
----

So we add a dummy view in 'views.py':


[source,python]
.lists/views.py
----
def edit_notes():
    pass
----

Notice the next error:


----
TypeError: edit_notes() takes no arguments (3 given)
----

Which tells us that the two capture groups are working -- we are passing
in a total of 3 arguments to our new view, so it will need to have them
all in its signature:



[source,python]
.lists/views.py
----
def edit_notes(request, list_id, item_id):
    pass
----

Now we get

----
ValueError: The view lists.views.edit_notes didn't return an HttpResponse object.
----

We could return an empty 'HttpResponse', but let's skip that step while we're
feeling confident, since we know we're definitely going to use a template, and
do this:

[source,python]
.lists/views.py
----
def edit_notes(request, list_id, item_id):
    return render(request, 'edit_notes.html')
----

Now we get

----
TemplateDoesNotExist: edit_notes.html
----

So

[subs="specialcharacters,quotes"]
----
$ *touch lists/templates/edit_notes.html*
----

And now onto a more interesting test failure:

----
AssertionError: 'action="/lists/1/notes"' not found in ''
----

The test is checking that we have a form which points to the correct
URL.  Let's start creating our new template, basing it on one of the exiting
ones.  I'll start by tweaking the header test
////
TODO: test this
////
and the form's `action` attribute:

[source,html]
.lists/templates/edit_notes.html
----
{% extends 'base.html' %}

{% block header_text %}Edit notes{% endblock %}

{% block form %}
    <form method="POST" action="/lists/{{ list.id }}/item/{{ item.id }}/notes">
        {% csrf_token %}
    </form>
{% endblock %}
----

Re-using 'base.html' in this way might not give us the layout + styling we 
ultimately want for this page, but it will probably do to get started.  What
do our unit tests want next?

----

    self.assertIn('action="/lists/%d/notes"' % (list1.id,), response.content)
AssertionError: 'action="/lists/1/notes"' not found in '<!DOCTYPE html>\n<html>[...]
----

Hmm, the form `action` isn't quite right.  Digging further through the error message,
we can see why:

----
    <form method="POST" action="/lists//item//notes" >\n 
----

By default, Django's template language just replaces any unknown or missing
variables with empty text, so, because we haven't passed in an `item` or a
`list`, it can't possible generate a URL for us.  We'll need to pass them in
in the context for the template.  We can use Django's testing tools to help
check on them:

[source,python]
.lists/tests.py
----
    self.assertEqual(response.context['item'], item2)
    self.assertIn(
        'action="/lists/%d/item/%d/notes"' % (list1.id, item2.id),
        response.content
    )
----

Now we get

    KeyError: 'item'

So we pass through the item:


[source,python]
.lists/views.py
----
def edit_notes(request, list_id, item_id):
    item = Item.objects.get(id=item_id)
    return render(request, 'edit_notes.html', {'item': item})
----


That gets us closer, we still get an error but now, looking at the traceback,
the form action is nearly there:

    action="/lists//item/2/notes"

Rather than pass a `list` object to the template as well, we can just get it
from the item -- we tweak the template slightly:


[source,html]
.lists/templates/edit_notes.html
----
<form method="POST" action="/lists/{{ item.list.id }}/item/{{ item.id }}/notes">
----

And now we get a different failure!

----
    self.assertIn('<input name="notes" type="textfield"', response.content)
AssertionError: '<input name="notes" type="textfield"' not found in [...]
----

So we need to add our `textfield`, which will allow us to input multi-line 
comments:


[source,html]
.lists/templates/edit_notes.html
----
<form method="POST" action="/lists/{{ item.list.id }}/item/{{ item.id }}/notes">
    {% csrf_token %}
    <input name="notes" type="textfield"/>
</form>
----

And that's a pass!  Is there any chance the FT will move forwards?

    NoSuchElementException: Message: u'Unable to locate element: {"method":"link text","selector":"edit notes"}'

Nope.  We still need to add links to our main page.  That will be in
'list.html'.  Looking at it, it seems like a good time to change our
list table so that it has several columns, including one for notes:

[source,html]
.lists/templates/list.html
----
{% block table %}
    <table id="id_list_table">
        {% for item in list.item_set.all %}
            <tr>
                <td>{{ forloop.counter }}:</td>
                <td>{{ item.text }}</td>
                <td><a href="/lists/{{ list.id }}/item/{{ item.id }}/edit_notes/">edit notes</td>
            </tr>
        {% endfor %}
    </table>
{% endblock %}
----

But I'm already anticipating this is going to cause problems...
----
======================================================================
FAIL: test_adding_notes (functional_tests.tests.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/workspace/superlists/functional_tests/tests.py", line 137, in test_adding_notes
    self.check_for_row_in_list_table("1: Buy milk")
  File "/workspace/superlists/functional_tests/tests.py", line 35, in check_for_row_in_list_table
    self.assertIn(row_text, [row.text for row in rows])
AssertionError: '1: Buy milk' not found in [u'1: Buy milk edit notes']

======================================================================
FAIL: test_can_start_a_list_and_retrieve_it_later (functional_tests.tests.NewVisitorTest)
[...]
    self.assertIn(row_text, [row.text for row in rows])
AssertionError: '1: Buy peacock feathers' not found in [u'1: Buy peacock feathers edit notes']

FAILED (failures=2)
----

Sure enough!  We've messed with the basic structure of our list table, and
that affects several of our existing functional tests.  Thankfully, we've 
already applied the DRY principle to our functional tests, so most of the
code that examines the list table is already encapsulated in a single place,
the `check_for_row_in_list_table` function.  Let's adjust it:


[source,python]
.functional_tests/tests.py
----
    def check_for_row_in_list_table(self, row_text):
        table = self.browser.find_element_by_id('id_list_table')
        rows = table.find_elements_by_tag_name('tr')
        self.assertTrue(
            any(row_text in row.text for row in rows),
            "Could not find row with text %r, table text was:\n%s" % (
                row_text, table.text
            )

        )
----

Notice that `assertTrue/any` coming back?  I knew there was a reason I'd
started off using that -- I had an inkling that the rows in the table might
contain more than just the plain text of the item, so we really want to check
that the expected item text is contained in the row text -- hence the 
`row_text in row.text`.  It was still probably premature of me to write that
`any` formulation back then though -- I should have remembered YAGNI, always
start with the simplest implementation that works.

The new method gets the old tests passing, and our own test gets a little further:

----
  File "/workspace/superlists/functional_tests/tests.py", line 155, in test_adding_notes
    self.browser.find_element_by_css_selector('input[type=submit]').click()
[...]
NoSuchElementException: Message: u'Unable to locate element: {"method":"css selector","selector":"input[type=submit]"}' ; [...]
----

Ah yes, we forgot to add a submit button to our form.  Let's do that:

[source,html]
.lists/templates/edit_notes.html
----
    <form method="POST" action="/lists/{{ item.list.id }}/item/{{ item.id }}/notes">
        {% csrf_token %}
        <input name="notes" type="textfield"/>
        <input type="submit" value="Save"/>
    </form>
----

That gets us to the next stage:

----
AssertionError: 'You can find milk in a shop' not found in u'Not Found\nThe requested URL /lists/1/item/1/notes was not found on this server.'
----

Before we move on though, let's do a tiny bit of prettification.  One of the 
problems with TDD is that you can let yourself become fixated on getting your tests
to pass, and forget to try actually using your application yourself. Remember,
'real' test is whether your users enjoy using your app, so it's important to 
go and check it out yourself from time to time to pick up on things like design
and usability issues.

Let's spin up the dev server with `manage.py runserver` and take a look around.
Our addition of the 'edit notes' link to the table has made it look a bit
awkward.

.Our list table looks a little untidy
image::images/list_table_looking_untidy_1_item.png[List table with 1 item
showing edit notes link badly aligned]

A bit of bootstrap magic helps -- adding the `table` class to the table gives
it a bit of styling, and then wrapping the "edit notes" link in a `<p
class="text-right">` and a `<small>` tag makes it a little less intrusive:

[source,html]
.lists/templates/edit_notes.html
----
<table id="id_list_table" class="table">
    {% for item in list.item_set.all %}
        <tr>
            <td>{{ forloop.counter }}:</td>
            <td>{{ item.text }}</td>
            <td>
                <p class="text-right"><small>
                    <a href="/lists/{{ list.id }}/item/{{ item.id }}/edit_notes/">edit notes</a>
                </small></p>
            </td>
        </tr>
    {% endfor %}
</table>
----

how about when there's multiple items?

<image>

here's a reasonable state.

[source,html]
.lists/templates/edit_notes.html
----
<table id="id_list_table" class="table table-hover">
    {% for item in list.item_set.all %}
        <tr>
            <td>{{ forloop.counter }}:</td>
            <td>{{ item.text }}</td>
            <td width="20%">
                <p class="text-right"><small>
                    <a href="/lists/{{ list.id }}/item/{{ item.id }}/edit_notes/">edit notes</a>
                </small></p>
            </td>
        </tr>
    {% endfor %}
</table>
----
