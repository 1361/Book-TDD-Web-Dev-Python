Forms and input validation
--------------------------

In this chapter we'll learn how to test and implement validation of user inputs
using Django forms. We'll also take the opportunity to do a little tidying up.

WARNING: This chapter is under construction, and nowhere near finished.  Comments
welcomed!
//TODO remove me


Validation: preventing blank and duplicate list items
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As our first few users start using the site, we've noticed they sometimes make 
mistakes which mess up their lists, like accidentally submitting blank list
items, and accidentally inputting 2 identical items to a list.  Computers are
meant to help stop us from making silly mistakes, so let's see if we can't get
our site to help!

Let's see how that might work as an FT:


[role="sourcecode"]
.functional_tests/tests.py (ch09l001)
[source,python]
----
def test_cannot_add_empty_list_items(self):
    # Edith goes to the home page and accidentally tries to submit
    # an empty list item. She hits Enter on the empty input box

    # The home page refreshes, and there is an error message saying
    # that list items cannot be blank

    # She tries again with some text for the item, which now works

    # Perversely, she now decides to submit a second blank list item

    # She receives a similar warning on the list page

    # And she can correct it by filling some text in
    self.fail('write me!')
----

That's all very well, but before we go any further -- our functional tests
file is beginning to get a little crowded.  Let's split it out into several
files, in which each has a single test method.  

Remember that functional tests map to "user stories". If you were using some
sort of project management tool like an issue tracker, you might make it so
that each file matched one issue or ticket, and its filename contained the
ticket ID.

We'll also have one base test class which they can all inherit from.  Here's 
how to get there step-by-step:

Start by switching from using a tests file to a tests folder. In order for the
Django test runner to still work, we need to make sure the new tests module,
which is now a folder instead of a file, still has all the same tests -- we do
this by doing an import in the '__init__.py':

[subs="specialcharacters,quotes"]
----
$ *mkdir functional_tests/tests*
$ *touch functional_tests/tests/__init__.py*
$ *git mv functional_tests/tests.py functional_tests/tests/base.py*
$ @echo "from .base import *" >> functional_tests/tests/__init__.py@
----

TODO: aside on relative imports

And now we check that we can still see all 3 tests being run if we run
the FTs as before:

[subs="specialcharacters,quotes"]
----
$ *python3 manage.py test functional_tests*
[...]
AssertionError: write me!
Ran 3 tests in 11.290s
----

That works, we can do a first commit

[subs="specialcharacters,quotes"]
----
$ *git add functional_tests/tests*
$ *git commit -m "Move FTs into a tests folder"*
----

Now we prepare a base class for all the tests to inherit from, and have
each test be in its own class:

[role="sourcecode"]
.functional_tests/tests/base.py (ch09l002)
[source,python]
----
class FunctionalTest(LiveServerTestCase):

    @classmethod
    def setUpClass(cls):
        [...]
    def tearDownClass(cls):
        [...]
    def setUp(self):
        [...]
    def tearDown(self):
        [...]
    def check_for_row_in_list_table(self, row_text):
        [...]


class NewVisitorTest(FunctionalTest):

    def test_can_start_a_list_and_retrieve_it_later(self):
        [...]



class LayoutAndStylingTest(FunctionalTest):

    def test_layout_and_styling(self):
        [...]



class ItemValidationTest(FunctionalTest):

    def test_cannot_add_empty_list_items(self):
        [...]
----

Again, we can re-run the FTs and see they all still work.  I'm labouring this a
little bit, we could probably get away doing this stuff in less steps, but, as
I keep saying, practising the step-by-step method on the easy cases makes it
that much easier when we have a complex case.

Now we can split each class out into its own file.  It's easy to do this
by making 3 new copies of 'base.py', deleting all the irrelevant bits from
each and just keeping one import:

[subs="specialcharacters,quotes"]
----
*cp functional_tests/tests/base.py functional_tests/tests/test_simple_list_creation.py*
*cp functional_tests/tests/base.py functional_tests/tests/test_layout_and_styling.py*
*cp functional_tests/tests/base.py functional_tests/tests/test_list_item_validation.py*
----

'base.py' can be cut down to just the FunctionalTest class.  We leave the
helper method on the base class, because we suspect we're about to re-use
it in our new FT.

NOTE: Keeping helper methods in a base FunctionalTest class is a useful way 
of preventing duplication in FTs.  Later in the book we'll use the Page
pattern, which is related.

[role="sourcecode"]
.functional_tests/tests/base.py (ch09l003)
[source,python]
----
from django.test import LiveServerTestCase
from selenium import webdriver
import sys

class FunctionalTest(LiveServerTestCase):

    def check_for_row_in_list_table(self, row_text):
        [...]

----

Our first FT is now in its own file, with one class and one test method:

[role="sourcecode"]
.functional_tests/tests/test_simple_list_creation.py (ch09l004)
[source,python]
----
from .base import FunctionalTest
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

class NewVisitorTest(FunctionalTest):
    def test_can_start_a_list_and_retrieve_it_later(self):
        [...]
----

The layout and styling FT is now one file and one class:

[role="sourcecode"]
.functional_tests/tests/test_layout_and_styling.py (ch09l005)
[source,python]
----
from .base import FunctionalTest

class LayoutAndStylingTest(FunctionalTest):
        [...]
----

And finally our new validation test is in a file of its own too:

[role="sourcecode"]
.functional_tests/tests/test_list_item_validation.py (ch09l006)
[source,python]
----
from .base import FunctionalTest

class ItemValidationTest(FunctionalTest):
        [...]
----

Finally we need to change the tests module's dunderinit to import our 3
test classes:


[role="sourcecode"]
.functional_tests/tests/__init__.py (ch09l007)
[source,python]
----
from .test_simple_list_creation import NewVisitorTest
from .test_layout_and_styling import LayoutAndStylingTest
from .test_list_item_validation import ItemValidationTest
----

And we can test everything worked by re-running `manage.py test`, and checking
once again that all 3 tests are run.

[subs="specialcharacters,quotes"]
----
AssertionError: write me!
----

As a side-bonus, we're now able to run an individual test class, like this:

[subs="specialcharacters,quotes"]
----
$ *python3 manage.py test functional_tests.ItemValidationTest*
[...]
AssertionError: write me!
----

Brilliant, no need to sit around waiting for all the FTs when we're only
interested in a single one. Although we need to remember to run all of them
now and again, to check for regressions.  Later in the book we'll see how
to give that task over to an automated Continuous Integration loop. For now
let's commit!

[subs="specialcharacters,quotes"]
----
$ *git status* 
$ *git add functional_tests* 
$ *git commit -m"Moved Fts into their own individual files"*
----


Now let's start implementing the test, or at least the beginning of it:


[role="sourcecode"]
.functional_tests/tests/test_adding_notes.py (ch09l008)
[source,python]
----
def test_cannot_add_empty_list_items(self):
    # Edith goes to the home page and accidentally tries to submit
    # an empty list item. She hits Enter on the empty input box
    self.browser.get(self.server_url)
    self.browser.find_element_by_id('id_new_item').send_keys('\n')

    # The home page refreshes, and there is an error message saying
    # that list items cannot be blank
    error = self.browser.find_element_by_css_selector('.error') #<1>
    self.assertEqual(error.text, "You can't have an empty list item")

    # She tries again with some text for the item, which now works
    self.browser.find_element_by_id('id_new_item').send_keys('Buy milk\n')
    self.check_for_row_in_list_table('1: Buy milk') #<2>

    # Perversely, she now decides to submit a second blank list item
    self.browser.find_element_by_id('id_new_item').send_keys('\n')

    # She receives a similar warning on the list page
    self.check_for_row_in_list_table('1: Buy milk')
    error = self.browser.find_element_by_css_selector('.error')
    self.assertEqual(error.text, "You can't have an empty list item")

    # And she can correct it by filling some text in
    self.browser.find_element_by_id('id_new_item').send_keys('Make tea\n')
    self.check_for_row_in_list_table('1: Buy milk')
    self.check_for_row_in_list_table('2: Make tea')

    self.fail("Don't forget to also test duplicate items!")

----

A couple of things to note about this test:

<1> We specify we're going to use a CSS class called `.error` to mark our
error text.  We'll see that Bootstrap has some useful styling for those
<2> As predicted, we are re-using the `check_for_row_in_list_table` helper
function when we want to confirm that list item submission *does* work.

//TODO -- bootstrap.

The technique of keeping helper methods in a parent class is absolutely
vital to preventing duplication across your functional test code.  The day
we decide to change the implementation of how our list table works, we want
to make sure we only have to change our FT code in one place, not in dozens
of places across loads of FTs...

And we're off!

----
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"css selector","selector":".error"}' ; Stacktrace: 
----


Using model-layer validation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are two levels at which you can do validation in Django. One is
at the model level, and the other is higher up at the forms level.  I
like to use the lower level whenever possible, partially because I'm
a bit too fond of databases and database integrity rules, and partially
because it's safer -- you can sometimes forget which form you use to 
validate input, but you're always going to use the same database.


Refactoring unit tests into several files
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We're going to want to add another test for our model, but before we
do so, it's time to tidy up our unit tests in a similar way to the
functional tests:

[subs="specialcharacters,quotes"]
----
$ @mkdir lists/tests@
$ @touch lists/tests/__init__.py@
$ @git mv lists/tests.py lists/tests/test_all.py@
$ @echo "from .test_all import *" > lists/tests/__init__.py@
$ @git st@
$ @git add lists/tests@
$ @python3 manage.py test lists@
[...]
Ran 6 tests in 0.034s

OK
$ @git commit -m"Move unit tests into a folder with single file"@
----

Now we turn test_all into two files, one called `test_views.py` which
only contains view tests, and one called `test_models.py`:

[subs="specialcharacters,quotes"]
----
$ *git mv lists/tests/test_all.py lists/tests/test_views.py*
$ *cp lists/tests/test_views.py lists/tests/test_models.py*
----

We then strip 'test_models.py' down to being just the one test -- it means
it needs far fewer imports:

[source,python]
.lists/tests/test_models.py (ch09l009)
----
from django.test import TestCase

from lists.models import Item, List


class ListAndItemModelsTest(TestCase):

    def test_saving_and_retrieving_items(self):
        list = List()
        [...]
----

Whereas 'test_views.py'  just loses one class:

[source,diff]
.lists/tests/test_models.py (ch09l010)
----
diff --git a/lists/tests/test_views.py b/lists/tests/test_views.py
index fc1eb64..9305bf8 100644
--- a/lists/tests/test_views.py
+++ b/lists/tests/test_views.py
@@ -81,33 +81,3 @@ class ListViewTest(TestCase):
         self.assertTemplateUsed(response, 'list.html')
         self.assertEqual(response.context['list'], list)
 
-
-
-class ListAndItemModelsTest(TestCase):
-
-    def test_saving_and_retrieving_items(self):
[...]
----

And we re-run the tests to check everything is still there:

[subs="specialcharacters,quotes"]
----
$ *python3 manage.py test lists*
ImportError: No module named 'lists.tests.test_all'
----

Oops!  Forgot to change the dunderinit:


[source,python]
.lists/tests/__init__.py (ch09l010)
----
from .test_models import *
from .test_views import *
----

[subs="specialcharacters,quotes"]
----
$ *python3 manage.py test lists*
[...]
Ran 6 tests in 0.040s

OK
----

Great!  

[subs="specialcharacters,quotes"]
----
$ *git add lists/tests*
$ *git commit -m "Split out unit tests into two files"*
----

NOTE: Some people like to make their unit tests into a tests folder straight
away, as soon as they start a project, with the addition of another file,
'test_forms.py'. That's a perfectly good idea, I just thought I'd wait until it
became necessary, to avoid doing too much housekeeping all in the first
chapter!


Unit testing model validation and the self.assertRaises context manager
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Let's add a new test method to `ListAndItemModelsTest`, which tries to create
a blank list item:

[source,python]
.lists/tests/test_models.py (ch09l012)
----
from django.core.exceptions import ValidationError
class ListAndItemModelsTest(TestCase):
    [...]

    def test_cannot_save_empty_list_items(self):
        list1 = List.objects.create()
        item = Item(list=list1, text='')
        with self.assertRaises(ValidationError):
            item.save()
----

This is a new unit testing technique: when we want to check that doing
something will raise an error, we can use the `self.assertRaises` context
manager.  We could have used something like this instead:

[source,python]
----
try:
    item.save()
    self.fail('The full_clean should have raised an exception
except ValidationError:
    pass
----

But the `with` formulation is neater.  Now, we can try running the test, 
and see if fail:

----
    item.save()
AssertionError: ValidationError not raised
----

And now we discover one of Django's dirty little secrets. *This test should
already pass*.  If you take a look at the
https://docs.djangoproject.com/en/1.5/ref/models/fields/#blank[docs for the
Django model fields], you'll see that `TextField` actually defaults to
`blank=False`, which means that it should disallow empty values.

So why is the test not failing?  Well, for 
https://groups.google.com/forum/#!topic/django-developers/uIhzSwWHj4c[slightly
tedious historical reasons], Django models don't run full validation on
save.  As we'll see later, any constraints that are actually implemented in the
database will raise errors on save, but Sqlite doesn't support enforcing
emptiness constraints on text columns, and so our save method is letting this
invalid value through silently.

Django does have a method to manually run full validation however, called
`full_clean`.  You can hack it in to see it work if you like:


[source,python]
.lists/tests/test_models.py
----
    with self.assertRaises(ValidationError):
        item.save()
        item.full_clean()
----

Which would get the tests to pass.  Let's revert it an make a real
implementation by overriding the model's save method:

[source,python]
.lists/models.py (ch09l013)
----
class Item(models.Model):
    text = models.TextField()
    list = models.ForeignKey(List)

    def save(self, *args, **kwargs):
        self.full_clean()
        super().save(*args, **kwargs)
----

NOTE: It's good practice to use `*args, **kwargs` when overriding Django
model methods like `save`, because they're called from all sorts of strange
places, and you want to make sure those arguments get passed to the superclass
save, so that all the Django magic still works.

That works:

[subs="specialcharacters,quotes"]
----
$ * python3 manage.py test lists*
Creating test database for alias 'default'...
.......
 ---------------------------------------------------------------------
Ran 7 tests in 0.037s

OK
----


Handling model validation errors in the view:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We start by adjusting our tests in the `NewListTest` class.  I'm 
going to use two slightly different error-handling patterns here.

In the first case, our URL and view for new lists will optionally
render the same template as the home page, but with the addition
of an error message. Here's a unit tests for that:

[source,python]
.lists/tests/test_views.py
----
class NewListTest(TestCase):
    [...]

    def test_validation_errors_sent_back_to_home_page_template(self):
        response = Client().post('/lists/new', data={'item_text': ''})
        self.assertEqual(Item.objects.all().count(), 0)
        self.assertTemplateUsed(response, 'home.html')
        expected_error =  "You can't have an empty list item"
        self.assertContains(response, expected_error)
----

The test gives fails out with an error -- our view tries to save
an item with blank text, but the model validation raises an 
exception:

----
django.core.exceptions.ValidationError: {'text': ['This field cannot be blank.']}
----

So we try our first approach:  using a try/except to detect errors. Obeying the
testing goat, we start by just the try/except and nothing else.  The tests
should tell us what to code next...

[source,python]
.lists/views.py
----
def new_list(request):
    list = List.objects.create()
    try:
        Item.objects.create(text=request.POST['item_text'], list=list)
    except ValidationError:
        pass
----

Sure enough, the test now wants us to use a template:

----
AssertionError: No templates used to render the response
----

We try that naively:

[source,python]
.lists/views.py
----
    except ValidationError:
        return render(request, 'home.html')
----

And the tests now tell us to put the error message into the template:

----
AssertionError: False is not true : Couldn't find 'You can't have an empty list item' in response
----

We do that by passing a new template variable in:

[source,python]
.lists/tests.py
----
    except ValidationError:
        error_text = "You can't have an empty list item"
        return render(request, 'home.html', {"error": error_text})
----

And adjusting the template:

[source,html]
.lists/templates/home.html
----
    <form method="POST" action="/lists/new" >
        <input id="id_new_item" name="item_text" placeholder="Enter a to-do item" />
        {% csrf_token %}
        {% if error %}
            <p class="error">{{ error }}</p>
        {% endif %}
    </form>
----

Hmm, that doesn't work:

----
AssertionError: False is not true : Couldn't find 'You can't have an empty list item' in response
----

A little print-based debug:

[source,python]
.lists/tests/test_views.py
----
expected_error =  "You can't have an empty list item"
print(response.content.decode())
self.assertContains(response, expected_error)
----

Will show us the cause: Django has HTML-escaped the apostrophe:

----
<p class="error">You can&#39;t have an empty list item</p>
----

We could hack something like this in to our test:

[source,python]
----
    expected_error =  "You can&#39;t have an empty list item"
----

But using Django's helper function is probably a better idea:


[source,python]
.lists/tests/test_views.py
----
from django.utils.html import escape
[...]

    expected_error =  escape("You can't have an empty list item")
    self.assertContains(response, expected_error)
----

That passes!  Do the FTs pass?


[subs="specialcharacters,quotes"]
----
$ *python3 manage.py test functional_tests.ItemValidationTest*
[...]

  File
  "/workspace/superlists/functional_tests/tests/test_list_item_validation.py",
  line 24, in test_cannot_add_empty_list_items

selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"id","selector":"id_list_table"}' ; Stacktrace: 

----

Not quite, but they did get a little further.  Checking the `line 24`, we can
see that we've got past the first part of the test, and are now onto the second
check -- that submitting a second empty item also raises an exception.  That's
currently producing a server error instead of a nice exception, so let's fix
that.

First, a little commit:


[subs="specialcharacters,quotes"]
----
$ *git commit -am"Adjust new list view to render validation errors"*
----


Django pattern: processing POST request in the same view as renders the form
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This time we'll use a slightly different approach, one that's actually a very
common pattern in Django, which is to use the same view to process POST
requests as to render the form that they come from.  Whilst this doesn't fit
the REST-ful URL model quite as well, it has the important advantage that the
same URL can display a form, and display any errors encountered in processing
the user's input.

So, in 'list.html', our form will have a different target:

[source,html]
.lists/templates/lists.html
----
    <form method="POST" action="/lists/{{ list.id }}/" >
----

This will immediately break our original functional test:

----
$ python3 manage.py test functional_tests.NewVisitorTest
AssertionError: '2: Use peacock feathers to make a fly' not found in ['1: Buy
peacock feathers']
----


Now let's change the test for saving POST requests to existing lists, to
make it point at the base list URL, and also move it into `ListViewTest`:

[source,python]
.lists/tests/tests_views.py
----
class ListViewTest(TestCase):

    def test_list_view_displays_all_items(self):
        [...]

    def test_saving_a_POST_request_to_an_existing_list(self):
        [...]
        response = client.post(
            '/lists/%d/' % (list.id,),
            data={'item_text': 'A new item for an existing list'}
        )
----

(The `NewItemTest` class disappears). That gives

----
AssertionError: 0 != 1
----

Now we can change the `view_list` function to handle two types of request,
and delete the `add_item` view:


[source,python]
.lists/views.py
----
def view_list(request, list_id):
    list = List.objects.get(id=list_id)
    if request.method == 'POST':
        Item.objects.create(text=request.POST['item_text'], list=list)
        return redirect('/lists/%d/' % (list.id,))
    return render(request, 'list.html', {'list': list})
----


Oops, a couple of unexpected failures:

----
django.core.exceptions.ViewDoesNotExist: Could not import lists.views.add_item.
View does not exist in module lists.views.
[...]
django.core.exceptions.ViewDoesNotExist: Could not import lists.views.add_item.
View does not exist in module lists.views.
----

It's because we've deleted the view, but it's still being referred to in
'urls.py'.  We remove it from there:

[source,python]
.lists/urls.py
----
urlpatterns = patterns('',
    url(r'^(.+)/$', 'lists.views.view_list', name='view_list'),
    url(r'^new$', 'lists.views.new_list', name='new_list'),
)
----

And that gets us to the `OK`. Let's try a full FT run, to make sure our
refactor is complete:


----
$ python3 manage.py test functional_tests

Ran 3 tests in 15.276s

FAILED (errors=1)
----

We're back to the 1 failure in our new test. We should commit there.

[subs="specialcharacters,quotes"]
----
$ *git commit -am"Refactor list view to handle new item POSTs"*
----


Now we can write a new unit test for the validation of items posted 
to the existing lists view.  It's very similar to the one for the 
home page, just a couple of tweaks:

[source,python]
.lists/tests/test_views.py
----
class ListViewTest(TestCase):
    [...]

    def test_validation_errors_end_up_on_lists_page(self):
        list = List.objects.create()
        
        response = Client().post(
            '/lists/%d/' % (list.id,),
            data={'item_text': ''}
        ) 
        self.assertEqual(Item.objects.all().count(), 0)
        self.assertTemplateUsed(response, 'list.html')
        expected_error =  escape("You can't have an empty list item")
        self.assertContains(response, expected_error)
----

Here's an implementation:


[source,python]
.lists/views.py
----
def view_list(request, list_id):
    list = List.objects.get(id=list_id)
    error = None

    if request.method == 'POST':
        try:
            Item.objects.create(text=request.POST['item_text'], list=list)
            return redirect('/lists/%d/' % (list.id,))
        except ValidationError:
            error = "You can't have an empty list item"

    return render(request, 'list.html', {'list': list, "error": error})
----

There's definitely some duplication of code here, that try/except occurs
twice in 'views.py'.  Let's wait a bit before we do a refactor though, because
we know we're about to do some slightly different validation coding for 
duplicate items.

One of the reasons that the "three strikes and refactor" rule exists is that,
if you wait until you have 3 use cases, each might be slightly different, 
and it gives you a better view for what the commmon functionality is.  If 
you refactor too early, you may find that the 3rd use case doesn't quite
fit with your refactored code...

Meantime we need to add the error to the list template.

[source,html]
.lists/templates/lists.html
----
    <form method="POST" action="/lists/{{ list.id }}/" >
        <input id="id_new_item" name="item_text" placeholder="Enter a to-do item" />
        {% csrf_token %}
        {% if error %}
            <p class="error">{{ error }}</p>
        {% endif %}
    </form>
----


And that gets us to the end of the test!

----
AssertionError: Don't forget to also test duplicate items!
----


Another FT for duplicate items
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We can delete the `self.fail` from the previous test and add a second
test method to `ItemValidationTest`:

[source,python]
.lists/functional_tests/test_list_item_validation.py
----
def test_cannot_add_dulicate_items(self):
    # Edith goes to the home page and starts a new list
    self.browser.get(self.server_url)
    self.browser.find_element_by_id('id_new_item').send_keys('Buy wellies\n')
    self.check_for_row_in_list_table('1: Buy wellies')

    # She accidentally tries to enter a duplicate item
    self.browser.find_element_by_id('id_new_item').send_keys('Buy wellies\n')

    # She sees a helpful error message
    self.check_for_row_in_list_table('1: Buy milk')
    error = self.browser.find_element_by_css_selector('.error')
    self.assertEqual(error.text, "You've already got this in your list")
----

Why have two test methods rather than extending one, or having a new file
and class?  It just feels like these two tests belong together, but are
separate enough to merit being their own class.


[subs="specialcharacters,quotes"]
----
$ *python3 manage.py test functional_tests.ItemValidationTest*
[...]
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"css selector","selector":".error"}' ; Stacktrace: 

Ran 2 tests in 9.613s
----

OK, so we know the first of the two tests passes now, is there a way to run
just the failing one, I hear you ask!  Why yes indeed -- the technique known
as 'Dontification'.

Dontification
^^^^^^^^^^^^^
[source,python]
.lists/functional_tests/test_list_item_validation.py
----
    def DONTtest_cannot_add_empty_list_items(self):
----

We can 'temporarily' rename any of our test methods in such a way that they
don't begin with `test_`, and then the test runner ignores them.

WARNING: Dontification is dangerous -- you need to remember to change it back 
before you commit your changes back to the repo.  This is why line-by-line 
reviews of each of your diffs are a good idea!


Preventing duplicates at the model layer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We add another test to our model unit tests to check that duplicate items
in the same list raise an error

[source,python]
.lists/tests/test_models.py
----
def test_cannot_save_duplicate_items(self):
    list1 = List.objects.create()
    Item.objects.create(list=list1, text='bla')
    with self.assertRaises(ValidationError):
        Item.objects.create(list=list1, text='bla')
----

And, while it occurs to us, we add another test to make sure we don't 
overdo it on our integrity constraints:


[source,python]
.lists/tests/test_models.py
----
def test_CAN_save_same_item_to_different_lists(self):
    list1 = List.objects.create()
    list2 = List.objects.create()
    Item.objects.create(list=list1, text='bla')
    Item.objects.create(list=list2, text='bla') # should not raise
----

I always like to put a little comment for tests which are checking 
that a particular use case should 'not' raise an error, otherwise
it can be hard to see what's being tested.

----
AssertionError: ValidationError not raised
----

If we want to get it deliberately wrong, we can do this:


[source,python]
.lists/models.py
----
class Item(models.Model):
    text = models.TextField(unique=True)
    list = models.ForeignKey(List)
----

That lets us check that our second test really does pick up on this
problem:

----
Traceback (most recent call last):
  File "/workspace/superlists/lists/tests/test_models.py", line 54, in
test_CAN_save_same_item_to_different_lists
    Item.objects.create(list=list2, text='bla') # should not raise
    [...]
django.core.exceptions.ValidationError: {'text': ['Item with this Text already
exists.']}
----

TODO: An aside on when to write tests against developer stupidity...

Great.  The real implementation happens in a special class attribute called
`Meta`, and a constraint which says that that an item must be unique for a
particular list, or in other words, that text and list must be unique together:

[source,python]
.lists/tests.py
----

class Item(models.Model):
    text = models.TextField()
    list = models.ForeignKey(List)

    class Meta:
        unique_together = ('list', 'text')


    def save(self, *args, **kwargs):
        [...]
----

When we run the tests they reveal an unexpected failure:

----
======================================================================
FAIL: test_saving_and_retrieving_items
(lists.tests.test_models.ListAndItemModelsTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/harry/Dropbox/book/source/chapter_9/superlists/lists/tests/test_models.py", line 31, in test_saving_and_retrieving_items
    self.assertEqual(first_saved_item.text, 'The first (ever) list item')
AssertionError: 'Item the second' != 'The first (ever) list item'
- Item the second
----

That's a bit of a puzzler. A bit of print-based debugging:

[source,python]
.lists/tests/test_models.py
----
    first_saved_item = saved_items[0]
    print(first_saved_item.text)
    second_saved_item = saved_items[1]
    print(second_saved_item.text)
    self.assertEqual(first_saved_item.text, 'The first (ever) list item')
----


----
.....Item the second
The first (ever) list item
F.....
----

It looks like our uniqueness constraint has messed with the default ordering
of queries like `Item.objects.all()`.  Although we already have a failing test,
it's best to add a new test that explicitly tests for ordering:


[source,python]
.lists/tests/test_models.py
----
    def test_list_ordering(self):
        list1 = List.objects.create()
        item1 = Item.objects.create(list=list1, text='i1')
        item2 = Item.objects.create(list=list1, text='item 2')
        item3 = Item.objects.create(list=list1, text='3')
        self.assertEqual(
            Item.objects.all(),
            [item1, item2, item3]
        )
----

That gives us a new failure, but it's not a very readable one:

----
AssertionError: [<Item: Item object>, <Item: Item object>, <Item: Item object>]
!= [<Item: Item object>, <Item: Item object>, <Item: Item object>]
----

We need a better string representation for our objects.  Let's add another
unit tests:

NOTE: Ordinarily you wouldn't want to keep adding failing test after failing test,
it's best to work on one thing at a time. In this case, they're all quite
simple, so I'm not too worried.

[source,python]
.lists/tests/test_models.py
----
def test_string_representation(self):
    list1 = List.objects.create()
    item1 = Item.objects.create(list=list1, text='item text')
    self.assertEqual(str(item1), item1.text)
----

That gives us:

----
AssertionError: 'Item object' != 'item text'
----

As well as the other two failures.  Let's start fixing them all now:


[source,python]
.lists/models.py
----
class Item(models.Model):
    [...]

    def __str__(self):
        return self.text
----

NOTE: in Python 2.x versions of Django, the string representation used
to be __unicode__. That took me by surprise. See the
https://docs.djangoproject.com/en/1.5/topics/python3/#str-and-unicode-methods[docs].


Now we're down to 2 failures, and the ordering test has a more readable failure
message:

----
AssertionError: [<Item: 3>, <Item: i1>, <Item: item 2>] != [<Item: i1>, <Item:
item 2>, <Item: 3>]
----

We can fix that in the class Meta:

[source,python]
.lists/models.py
----
    class Meta:
        ordering = ('id',)
        unique_together = ('list', 'text')
----

Does that work?

----
AssertionError: [<Item: i1>, <Item: item 2>, <Item: 3>] != [<Item: i1>, <Item:
item 2>, <Item: 3>]
----

Urp?  It has worked, but the tests are confused.  I keep running into this
problem actually -- Django querysets don't compare well with lists.  We 
can fix it by converting the queryset to a list in our test:


[source,python]
.lists/tests/test_models.py
----
    self.assertEqual(
        list(Item.objects.all()),
        [item1, item2, item3]
    )
----


That gets us to a fully passing test suite. The next task is to handle
the validation error in the view.

Before we do that, a quick aside, for the curious. Do you remember I mentioned
earlier that some data integrity errors 'are' picked up on save?  Try
temporarily disabling our `.full_clean` in the model save:

[source,python]
.lists/models.py
----
    def save(self, *args, **kwargs):
        #self.full_clean()
        super().save(*args, **kwargs)
----

That gives

----
ERROR: test_cannot_save_duplicate_items
(lists.tests.test_models.ListAndItemModelsTest)
    return Database.Cursor.execute(self, query, params)
django.db.utils.IntegrityError: columns list_id, text are not unique

[... and a bunch of other failures due to validation not working any more]
----

Note that it's a different error to the one we want, an `IntegrityError` 
instead of a `ValidationError`.  In any case, let's put our `full_clean` 
back, and try running our FT, just to see where we are:

----
AssertionError: "You can't have an empty list item" != "You've already got this
in your list"
----


TODO: use Django ModelForm
TODO: tidy up URLs
TODO: switch to class-based views
TODO: add notes field (?)

