Forms and input validation
--------------------------

In this chapter we'll learn how to test and implement validation of user inputs
using Django forms. We'll also take the opportunity to do a little tidying up.


Validation: preventing blank and duplicate list items
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As our first few users start using the site, we've noticed they sometimes make 
mistakes which mess up their lists, like accidentally submitting blank list
items, and accidentally inputting 2 identical items to a list.  Computers are
meant to help stop us from making silly mistakes, so let's see if we can't get
our site to help!

Let's see how that might work as an FT:


[role="sourcecode"]
.functional_tests/tests.py (ch09l001)
[source,python]
----
def test_cannot_add_empty_list_items(self):
    # Edith goes to the home page and accidentally tries to submit
    # an empty list item. She hits Enter on the empty input box

    # The home page refreshes, and there is an error message saying
    # that list items cannot be blank

    # She tries again with some text for the item, which now works

    # Perversely, she now decides to submit a second blank list item

    # She receives a similar warning on the list page

    # And she can correct it by filling some text in
    self.fail('write me!')
----

That's all very well, but before we go any further -- our functional tests
file is beginning to get a little crowded.  Let's split it out into several
files, in which each has a single test method.  

Remember that functional tests map to "user stories". If you were using some
sort of project management tool like an issue tracker, you might make it so
that each file matched one issue or ticket, and its filename contained the
ticket ID.

We'll also have one base test class which they can all inherit from.  Here's 
how to get there step-by-step:

Start by switching from using a tests file to a tests folder. In order for the
Django test runner to still work, we need to make sure the new tests module,
which is now a folder instead of a file, still has all the same tests -- we do
this by doing an import in the '__init__.py':

[subs="specialcharacters,quotes"]
----
$ *mkdir functional_tests/tests*
$ *touch functional_tests/tests/__init__.py*
$ *git mv functional_tests/tests.py functional_tests/tests/base.py*
$ @echo "from .base import *" >> functional_tests/tests/__init__.py@
----


And now we check that we can still see all 3 tests being run if we run
the FTs as before:

[subs="specialcharacters,quotes"]
----
$ *python3 manage.py test functional_tests*
[...]
AssertionError: write me!
Ran 3 tests in 11.290s
----

That works, we can do a first commit

[subs="specialcharacters,quotes"]
----
$ *git add functional_tests/tests*
$ *git commit -m "Move FTs into a tests folder"*
----

Now we prepare a base class for all the tests to inherit from, and have
each test be in its own class:

[role="sourcecode"]
.functional_tests/tests/base.py (ch09l002)
[source,python]
----
class FunctionalTest(LiveServerTestCase):

    @classmethod
    def setUpClass(cls):
        [...]
    def tearDownClass(cls):
        [...]
    def setUp(self):
        [...]
    def tearDown(self):
        [...]
    def check_for_row_in_list_table(self, row_text):
        [...]


class NewVisitorTest(FunctionalTest):

    def test_can_start_a_list_and_retrieve_it_later(self):
        [...]



class LayoutAndStylingTest(FunctionalTest):

    def test_layout_and_styling(self):
        [...]



class ItemValidationTest(FunctionalTest):

    def test_cannot_add_empty_list_items(self):
        [...]
----

Again, we can re-run the Fts and see they all still work.  I'm labouring this a
little bit, we could probably get away doing this stuff in less steps, but, as
I keep saying, practising the step-by-step method on the easy cases makes it
that much easier when we have a complex case.

Now we can split each class out into its own file.  It's easy to do this
by making 3 new copies of 'base.py', deleting all the irrelevant bits from
each and just keeping one import:

[subs="specialcharacters,quotes"]
----
*cp functional_tests/tests/base.py functional_tests/tests/test_simple_list_creation.py*
*cp functional_tests/tests/base.py functional_tests/tests/test_layout_and_styling.py*
*cp functional_tests/tests/base.py functional_tests/tests/test_list_item_validation.py*
----

'base.py' can be cut down to just the FunctionalTest class.  We leave the
helper method on the base class, because we suspect we're about to re-use
it in our new FT.

NOTE: Keeping helper methods in a base FunctionalTest class is a useful way 
of preventing duplication in FTs.  Later in the book we'll use the Page
pattern, which is related.

[role="sourcecode"]
.functional_tests/tests/base.py (ch09l003)
[source,python]
----
from django.test import LiveServerTestCase
from selenium import webdriver
import sys

class FunctionalTest(LiveServerTestCase):

    def check_for_row_in_list_table(self, row_text):
        [...]

----

Our first FT is now in its own file, with one class and one test method:

[role="sourcecode"]
.functional_tests/tests/test_simple_list_creation.py (ch09l004)
[source,python]
----
from .base import FunctionalTest
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

class NewVisitorTest(FunctionalTest):
    def test_can_start_a_list_and_retrieve_it_later(self):
        [...]
----

The layout and styling FT is now one file and one class:

[role="sourcecode"]
.functional_tests/tests/test_layout_and_styling.py (ch09l005)
[source,python]
----
from .base import FunctionalTest

class LayoutAndStylingTest(FunctionalTest):
        [...]
----

And finally our new validation test is in a file of its own too:

[role="sourcecode"]
.functional_tests/tests/test_list_item_validation.py (ch09l006)
[source,python]
----
from .base import FunctionalTest

class ItemValidationTest(FunctionalTest):
        [...]
----

Finally we need to change the tests module's dunderinit to import our 3
test classes:


[role="sourcecode"]
.functional_tests/tests/__init__.py (ch09l007)
[source,python]
----
from .test_simple_list_creation import NewVisitorTest
from .test_layout_and_styling import LayoutAndStylingTest
from .test_list_item_validation import ItemValidationTest
----

And we can test everything worked by re-running `manage.py test`, and checking
once again that all 3 tests are run.

[subs="specialcharacters,quotes"]
----
AssertionError: write me!
----

As a side-bonus, we're now able to run an individual test class, like this:

[subs="specialcharacters,quotes"]
----
$ *python3 manage.py test functional_tests.ItemValidationTest*
[...]
AssertionError: write me!
----

Brilliant, no need to sit around waiting for all the FTs when we're only
interested in a single one. Although we need to remember to run all of them
now and again, to check for regressions.  Later in the book we'll see how
to give that task over to an automated Continuous Integration loop. For now
let's commit!

[subs="specialcharacters,quotes"]
----
$ *git status* 
$ *git add functional_tests* 
$ *git commit -m"Moved Fts into their own individual files"*
----


Now let's start implementing the test, or at least the beginning of it:


[role="sourcecode"]
.functional_tests/tests/test_adding_notes.py (ch09l008)
[source,python]
----
def test_cannot_add_empty_list_items(self):
    # Edith goes to the home page and accidentally tries to submit
    # an empty list item. She hits Enter on the empty input box
    self.browser.get(self.server_url)
    self.browser.find_element_by_id('id_new_item').send_keys('\n')

    # The home page refreshes, and there is an error message saying
    # that list items cannot be blank
    error = self.browser.find_element_by_css_selector('.error') #<1>
    self.assertEqual(error.text, "You can't have an empty list item")

    # She tries again with some text for the item, which now works
    self.browser.find_element_by_id('id_new_item').send_keys('Buy milk\n')
    self.check_for_row_in_list_table('Buy milk') #<2>

    # Perversely, she now decides to submit a second blank list item
    self.browser.find_element_by_id('id_new_item').send_keys('\n')

    # She receives a similar warning on the list page
    self.check_for_row_in_list_table('Buy milk')
    error = self.browser.find_element_by_css_selector('.error')
    self.assertEqual(error.text, "You can't have an empty list item")

    # And she can correct it by filling some text in
    self.browser.find_element_by_id('id_new_item').send_keys('Make tea\n')
    self.check_for_row_in_list_table('Buy milk')
    self.check_for_row_in_list_table('Make tea')

    self.fail("Don't forget to also test duplicate items!")

----

A couple of things to note about this test:

<1> We specify we're going to use a CSS class called `.error` to mark our
error text.  We'll see that Bootstrap has some useful styling for those
<2> As predicted, we are re-using the `check_for_row_in_list_table` helper
function when we want to confirm that list item submission *does* work.

The technique of keeping helper methods in a parent class is absolutely
vital to preventing duplication across your functional test code.  The day
we decide to change the implementation of how our list table works, we want
to make sure we only have to change our FT code in one place, not in dozens
of places across loads of FTs...

And we're off!

----
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"css selector","selector":".error"}' ; Stacktrace: 
----


Using model-layer validation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are two levels at which you can do validation in Django. One is
at the model level, and the other is higher up at the forms level.  I
like to use the lower level whenever possible, partially because I'm
a bit too fond of databases and database integrity rules, and partially
because it's safer -- you can sometimes forget which form you use to 
validate input, but you're always going to use the same database.


Refactoring unit tests into several files
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We're going to want to add another test for our model, but before we
do so, it's time to tidy up our unit tests in a similar way to the
functional tests:

[subs="specialcharacters,quotes"]
----
$ @mkdir lists/tests@
$ @touch lists/tests/__init__.py@
$ @git mv lists/tests.py lists/tests/test_all.py@
$ @echo "from .test_all import *" > lists/tests/__init__.py@
$ @git st@
$ @git add lists/tests@
$ @python3 manage.py test lists@
[...]
Ran 6 tests in 0.034s

OK
$ @git commit -m"Move unit tests into a folder with single file"@
----

Now we turn test_all into two files, one called `test_views.py` which
only contains view tests, and one called `test_models.py`:

[subs="specialcharacters,quotes"]
----
$ *git mv lists/tests/test_all.py lists/tests/test_views.py*
$ *cp lists/tests/test_views.py lists/tests/test_models.py*
----

We then strip 'test_models.py' down to being just the one test -- it means
it needs far fewer imports:

[source,python]
.lists/tests/test_models.py (ch09l009)
----
from django.test import TestCase

from lists.models import Item, List


class ListAndItemModelsTest(TestCase):

    def test_saving_and_retrieving_items(self):
        list = List()
        [...]
----

Whereas 'test_views.py'  just loses one class:

[source,diff]
.lists/tests/test_models.py (ch09l010)
----
diff --git a/lists/tests/test_views.py b/lists/tests/test_views.py
index fc1eb64..9305bf8 100644
--- a/lists/tests/test_views.py
+++ b/lists/tests/test_views.py
@@ -81,33 +81,3 @@ class ListViewTest(TestCase):
         self.assertTemplateUsed(response, 'list.html')
         self.assertEqual(response.context['list'], list)
 
-
-
-class ListAndItemModelsTest(TestCase):
-
-    def test_saving_and_retrieving_items(self):
[...]
----

And we re-run the tests to check everything is still there:

[subs="specialcharacters,quotes"]
----
$ *python3 manage.py test lists*
ImportError: No module named 'lists.tests.test_all'
----

Oops!  Forgot to change the dunderinit:


[source,python]
.lists/tests/__init__.py (ch09l010)
----
from .test_models import *
from .test_views import *
----

[subs="specialcharacters,quotes"]
----
$ *python3 manage.py test lists*
[...]
Ran 6 tests in 0.040s

OK
----

Great!  

[subs="specialcharacters,quotes"]
----
$ *git add lists/tests*
$ *git commit -m "Split out unit tests into two files"*
----

NOTE: Some people like to make their unit tests into a tests folder straight
away, as soon as they start a project, with the addition of another file,
'test_forms.py'. That's a perfectly good idea, I just thought I'd wait until it
became necessary, to avoid doing too much housekeeping all in the first
chapter!


Unit testing model validation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^






Objectives of this chapter:
- use Django forms
- ideally modelform
- show error-handling
- tidy up urls
- switch to class-based view
- prep s'thing for later chapters (notes field)


Outline:
- want to prevent dupes & blanks
- new FT method
- switch out to 2/3 fts
- show db integrity in models.py, unit test
- show how to catch errors in view
- refactor to have home page and list view render errors
- switch to using forms when more than 1 error message
- then: use form for editing existing items (new FT)
- then: add notes (?)
  - another new ft
  - formatting bits
  - adapt form...

- prevent empty items, duplicate items
- home page would need to handle post submits
- start by setting a db constraint, catching error?
- then use a modelform




