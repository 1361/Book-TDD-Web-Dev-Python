[[appendix-rest-api-frontend]]
[appendix]
REST API part 2: POST, status codes, JavaScript mocking
-------------------------------------------------------

(((REST)))
(((API)))
Chapter under construction


Implementing Ajax POST
~~~~~~~~~~~~~~~~~~~~~~

First we give our list form an `id` so we can pick it up
in our JS:

[role="sourcecode"]
.lists/templates/base.html
[source,diff]
----
@@ -56,7 +56,7 @@
           <div class="text-center">
             <h1>{% block header_text %}{% endblock %}</h1>
             {% block list_form %}
-              <form method="POST" action="{% block form_action %}{% endblock %}">
+              <form id="id_item_form" method="POST" action="{% block form_action %}{% endblock %}">
                 {{ form.text }}
                 {% csrf_token %}
                 {% if form.errors %}
----


Next tweak the fixture in our js test:

[role="sourcecode"]
.lists/static/tests/tests.html
[source,diff]
----
@@ -9,8 +9,9 @@
 <body>
   <div id="qunit"></div>
   <div id="qunit-fixture">
-    <form>
+    <form id="id_item_form">
       <input name="text" />
+      <input type="hidden" name="csrfmiddlewaretoken" value="tokey" />
       <div class="has-error">Error text</div>
     </form>
----


And here's our test:


[role="sourcecode"]
.lists/static/tests/tests.html
[source,javascript]
----
QUnit.test("should intercept form submit and do ajax post", function (assert) {
  var url = '/listitemsapi/';
  window.Superlists.initialize(url);

  $('#id_item_form input[name="text"]').val('user input');  //<1>
  $('#id_item_form input[name="csrfmiddlewaretoken"]').val('tokeney');  //<1>
  $('#id_item_form').submit();  //<1>

  assert.equal(server.requests.length, 2);  //<2>
  var request = server.requests[1];
  assert.equal(request.url, url);
  assert.equal(request.method, "POST");
  assert.equal(
    request.requestBody,
    'text=user+input&csrfmiddlewaretoken=tokeney'  //<3>
  );
});
----

<1> We simulate the user filling in the form and hitting submit.

<2> We now expect that there should be a second Ajax request (the
    first one is the GET for the list items table).

<3> We check our POST `requestBody`.  As you can see, it's
    URL-encoded, which isn't the most value to test, but it's still just about
    readable.

And here's how we implement it:

[role="sourcecode"]
.lists/static/list.js
[source,javascript]
----
    [...]
      $('#id_list_table').html(rows);
    });

    var form = $('#id_item_form');
    form.on('submit', function(event) {
      event.preventDefault();
      $.post(url, {
        'text': form.find('input[name="text"]').val(),
        'csrfmiddlewaretoken': form.find('input[name="csrfmiddlewaretoken"]').val(),
      });
    });
----

That get our JS tests passing but it breaks our FTs, because, although we're
doing our POST ok, we're not updating the page after the POST to show the new
list item:

----
  File "/workspace/superlists/functional_tests/base.py", line 109, in check_for_row_in_list_table
    self.assertIn(row_text, [row.text for row in rows])
AssertionError: '2: Use peacock feathers to make a fly' not found in ['1: Buy peacock feathers']
----



Mocking in JavaScript
~~~~~~~~~~~~~~~~~~~~~

We want our client-side to update the table of items after the Ajax POST completes.
Essentially it'll do the same work as we do as soon as the page loads, retrieving
the current list of items from the server, and filling in the item table.

Sounds like a helper function is in order!

[role="sourcecode"]
.lists/static/list.js
[source,javascript]
----
window.Superlists = {};

window.Superlists.updateItems = function (url) {
  $.get(url).done(function (response) {
    var rows = '';
    for (var i=0; i<response.length; i++) {
      var item = response[i];
      rows += '\n<tr><td>' + (i+1) + ': ' + item.text + '</td></tr>';
    }
    $('#id_list_table').html(rows);
  });
};

window.Superlists.initialize = function (url) {
  $('input[name="text"]').on('keypress', function () {
    $('.has-error').hide();
  });

  if (url) {
    window.Superlists.updateItems(url);

    var form = $('#id_item_form');
----

That was just a refactor, we check the JS tests all still pass:


    Took 46ms to run 11 tests. 11 passed, 0 failed.

Now how to test that our Ajax POST calls `updateItems` on POST success?  We
don't want to dumbly duplicate the code that simulates a server response
and checks the items table manually...   How about a Mock?


First we set up a thing called a "sandbox".  It will keep track of all
the mocks we create, and make sure to un-monkeypatch all the things that
have been mocked after each test.

[role="sourcecode"]
.lists/static/tests/tests.html
[source,html]
----
var server, sandbox;
QUnit.testStart(function () {
  server = sinon.fakeServer.create();
  sandbox = sinon.sandbox.create();
});
QUnit.testDone(function () {
  server.restore();
  sandbox.restore(); //<1>
});
----


<1> This `.restore()` is the important part, that undoes all the
    mocking we've done in each test.


[role="sourcecode"]
.lists/static/tests/tests.html
[source,html]
----
QUnit.test("should call updateItems after successful post", function (assert) {
  var url = '/listitemsapi/';
  window.Superlists.initialize(url); //<1>
  var response = [
    201,
    {"Content-Type": "application/json"},
    JSON.stringify({}),
  ];
  server.respondWith('POST', url, response); //<1>
  $('#id_item_form input[name="text"]').val('user input');
  $('#id_item_form input[name="csrfmiddlewaretoken"]').val('tokeney');
  $('#id_item_form').submit();

  sandbox.spy(window.Superlists, 'updateItems');  //<2>
  server.respond();  //<2>

  assert.equal(
    window.Superlists.updateItems.lastCall.args,  //<3>
    url
  );
});
----

<1> First important thing to notice:  We only set up our server response
    'after' we do the initialize.  We want this to be the response to the
    POST request that happens on form submit, not the response to the
    initial GET request (remember our lesson from chapter 13?  On of the most
    challenging things about JS testing is controlling the order of execution)

<2> Similarly, we only start mocking our helper function 'after' we know the
    first call for the initial GET has already happened.  The `sandbox.spy` call
    is what does the job that `patch` does in Python tests.  It replaces the given
    object with a mock version.

<3> our `updateItems` function has now grown some mocky extra attributes, like
    `lastCall` and `lastCall.args`, which are like the Python mock's `call_args`.


To get it passing, we first make a deliberate mistake, to check our tests really
do test what we think they do:


[role="sourcecode"]
.lists/static/lists.js
[source,javascript]
----
      $.post(url, {
        'text': form.find('input[name="text"]').val(),
        'csrfmiddlewaretoken': form.find('input[name="csrfmiddlewaretoken"]').val(),
      }).done(function () {
        window.Superlists.updateItems();
      });
----

Yep, we're almost there but not quite:

----
Test failed: should call updateItems after successful post
    Failed assertion: expected: /listitemsapi/, but was: 
file:///workspace/superlists/lists/static/tests/tests.html:120:15
----

And we fix it thusly:

[role="sourcecode"]
.lists/static/lists.js
[source,javascript]
----
      }).done(function () {
        window.Superlists.updateItems(url);
      });
----



.REST JavaScript tips
*******************************************************************************

Here comes a tip::
    It's all about ajax...

*******************************************************************************

