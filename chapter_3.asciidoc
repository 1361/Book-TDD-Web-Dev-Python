Chapter 3 - Testing a simple home page with unit tests
-------------------------------------------~~~~~~~~~~~

Where were we at the end of the last chapter? Let's re-run the test and find
out:

....
$ python functional_tests.py 
F
======================================================================
FAIL: test_can_start_a_todo_list_and_get_a_url_for_it (__main__.NewVisitorTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "functional_tests.py", line 19, in test_can_start_a_todo_list_and_get_a_url_for_it
    self.assertIn('To-Do', self.browser.title)
AssertionError: 'To-Do' not found in u'Welcome to Django'

----------------------------------------------------------------------
Ran 1 test in 4.747s

FAILED (failures=1)
....


One of the great things about TDD is that you never have to worry about
forgetting what to do next - just re-run your tests and they will tell
you what you need to work on. So we need to build a home page with
``To-Do'' in its title.


NOTE: Did you try it, and get an error saying 'Problem loading page'?  So did
I. It's because we forgot to spin up the dev. server first using 
`manage.py runserver`.  Do that, and you'll get the failure message we're
after.


Our first Django app, and our first unit test
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It's time to start working on our application.

Django encourages you to structure your code into ``apps'': one project can
have many apps, you might re-use the same app in different projects, and you
can use third-party apps developed by other people.

So the first thing to do is to start an app for our lists:

....
$ python manage.py startapp lists
....

That will create a folder at 'awesomelists/lists', next to
'awesomelists/awesomelists', and within it a number of placeholder files for
models, views and, of immediate interest to us, tests.

....
$ tree -I *.pyc
.
├── awesomelists
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── lists
│   ├── __init__.py
│   ├── models.py
│   ├── tests.py
│   └── views.py
├── manage.py
└── functional_tests.py
....


Unit tests, and how they differ from Functional tests
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As so often, the line between unit tests and functional tests can become a
little blurry.  The basic distinction, though, is that functional tests test
the application from the outside, from point of view of the user, whereas unit
tests test the application from the inside, from the point of view of the
programmer.

The TDD methodology I'm trying to teach then, follows this sort of a pattern:

1.  Start by writing a **functional test**, describing the new functionality
    from the point of view of the user

2.  Once we have a functional test that fails, we start to think about how
    to write code that can get it to pass (or at least to get past its current
    failure)

3.  We now use one or more **unit tests** to define how we want our code to
    behave -- the idea is that each line of production code we write should be 
    tested by (at least) one of our unit tests

4.  Once we have a failing unit test, we can write our application code.  We
    may iterate between steps 3 and 4 a few times

5.  Now we can re-run our functional tests and see if they pass, or get a
    little further.  That may prompt us to write some new unit tests, and
    some new code, and so on.

I would draw you a flowchart, but it really feels like over-egging the pudding!
Best to explain through demonstration.

You can see that, all the way through, the functional tests are driving what 
development we do from a high level, while the unit tests drive what we do
at a low level.

Now that may seem slightly redundant, and sometimes it can seem that way, but
functional tests and unit tests do really have very different objectives, and
they will usually end up looking quite different.  Functional tests should help
you build an application with the right functionality, and guarantee you never
accidentally break it.  Unit tests should help you to write code that's clean
and bug free.

Enough theory for now, let's see how it looks in practice.


Unit testing in Django
~~~~~~~~~~~~~~~~~~~~~~

Let's see how to write a unit test for our homepage view then. Open up
'lists/tests.py', and you'll see something like this:

[source,python]
----
"""
This file demonstrates writing tests using the unittest module. These will pass
when you run "manage.py test".

Replace this with more appropriate tests for your application.
"""

from django.test import TestCase


class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.assertEqual(1 + 1, 2)
----

Django has helpfully put a little place-holder in there for us to write tests
with.  You'll see it's tests are laid out in a similar pattern to our
functional test, although if you look closely you'll see it's using a special
version of `TestCase` imported from inside Django.  We'll find out more about
why that's special later.

Let's use this as a starting point to work from.  You've already seen that the
TDD cycle involves starting with a test that fails, then writing code to get it
to pass. Refining this idea, even before we can write a test for our code, we
want to know that the test we're writing is definitely being run.  So let's
start by making a test that we know will fail, by deliberately breaking the
default addition test.

[source,python]
----
        self.assertEqual(1 + 1, 3)
----

Now let's invoke Django's test runner - as usual, it's a 'manage.py' command,
`python manage.py test`:

....
$ python manage.py test
Creating test database for alias 'default'...
Traceback (most recent call last):
  File "manage.py", line 10, in <module>
    execute_from_command_line(sys.argv)

    [...lots more traceback]

    raise ImproperlyConfigured("settings.DATABASES is improperly configured. "
django.core.exceptions.ImproperlyConfigured: settings.DATABASES is improperly
configured. Please supply the ENGINE value. Check settings documentation for
more details.
....

Yuk, some pretty ugly traceback, but the message is actually quite helpful -
the test runner is complaining that it can't run tests until we set up some
kind of database. Let's do that, in the 'mysite/settings.py' file.  Open it up
and scroll to the line which defines `DATABASES` and `ENGINE`:

[source,python]
----
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.', # Add 'postgresql_psycopg2', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': '',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}
----

Helpful comments!  Let's use `sqlite3`, which is the quickest to set up.  We
can always change it later.

[source,python]
----
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', 
        'NAME': '',                      # Or path to database file if using sqlite3.
----

And let's try running the tests again:
....
$ python manage.py test
Creating test database for alias 'default'...
..........................................................................................................................................................................................................................................................................................................................................................s........................................................................
----------------------------------------------------------------------
Ran 419 tests in 17.679s

OK (skipped=1)
Destroying test database for alias 'default'...
....


419 tests!  We didn't write that many!  Well, with the generic `manage.py test`
command, Django runs all its own unit tests, as well as any tests for your
apps.

More worryingly though, we didn't see a test failure.  Assuming there have been
no changes in the fundamental properties of mathematics, 1 + 1 should not equal 3.
Where is our failing test?

Django will let you run tests for an individual app, by specifying it as a
command-line parameter. Let's try running just the tests for our app, `lists`:


....
Traceback (most recent call last):
  File "source/chapter_3/awesomelists/manage.py", line 10, in <module>
    execute_from_command_line(sys.argv)
    [lots of traceback]
    raise ImproperlyConfigured("App with label %s could not be found" % app_label)
django.core.exceptions.ImproperlyConfigured: App with label lists could not be found
....


BUT IT'S RIGHT THERE! Unfortunately, just running the `startapp` command and
having what is obviously an app in your project folder isn't quite enough
for Django to automatically recognise your app.  You have to tell it that you
really mean it, and add it to 'settings.py' as well. Open it up and look for a
variable called `INSTALLED_APPS`, to which we'll add `lists`:


[source,python]
----
INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Uncomment the next line to enable the admin:
    # 'django.contrib.admin',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
    'lists',
)
----

You can see there's lots of apps already in there by default (they're some of
the apps that caused all those 419 tests earlier).  We just need to add ours,
`lists`, to the bottom of the list.  Don't forget the trailing comma - it may
not be required, but one day you'll be really annoyed when you forget it and
Python concatenates two strings on different lines...

Now we can try running the tests for `lists` again:

....
$ python manage.py test lists
Creating test database for alias 'default'...
F
======================================================================
FAIL: test_basic_addition (lists.tests.SimpleTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/harry/Dropbox/book/source/chapter_3/awesomelists/lists/tests.py", line 16, in test_basic_addition
    self.assertEqual(1 + 1, 3)
AssertionError: 2 != 3

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
Destroying test database for alias 'default'...
....

That's more like it!  You can reassure yourself that it gets run as part of the
general command, `manage.py test` as well, and you should see it now runs 420
tests instead of 419.

This is a good point for a commit:

....
git status 
# should show you awesomelists/settings.py has changed and lists/ is untracked

git add awesomelists/settings.py
git add lists
git diff --cached # will show you the diff that you're about to commit
git commit -m"Add app for lists, with deliberately failing unit test"
....



Django's MVC, URLs and view functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Django is broadly structured along a classic 'Model-View-Controller (MVC)'
pattern.  Well, broadly.  It definitely has models, but its views are more like
a controller, and it's the templates that are actually the view part, but the
general idea is there.  If you're interested, you can look up the finer points
of the discussion 
https://docs.djangoproject.com/en/1.4/faq/general/#django-appears-to-be-a-mvc-framework-but-you-call-the-controller-the-view-and-the-view-the-template-how-come-you-don-t-use-the-standard-names[in the Django documentation].

But, irrespective of any of that, like any website, Django's main job is to
decide what to do when a user asks for a particular URL on our site.  Django's
workflow goes something like this:

* A **request** comes in for a particular **URL**
* Django uses some rules to decide which **view** function should deal with the
  request (this is referred to as 'resolving' the URL)
* The view function processes the request and returns an HTTP **response**

So we want to test two thing:

1.  Can we resolve the URL for the root of the site (``/'') to a particular
    view function we've made?
2.  Can we make this view function return some HTML which will get the 
    functional test to pass?

So let's write tests for those two things.  Open up 'lists/tests.py', and
change the default addition test to something like this:


[source,python]
----
from django.test import TestCase
from django.http import HttpRequest

from lists.views import home_page


----


<note on comments>



Onto writing a test for our view. Open up 'lists/tests.py', and change the
addition test to something like this:


[source,python]
----
from django.test import TestCase
from django.http import HttpRequest

from lists.views import home_page


class HomePageViewTest(TestCase):

    def test_home_page_returns_correct_html(self):
        request = HttpRequest()
        response = home_page(request)
        self.assertIn(response.content, '<title>To-Do lists</title>')
----

What's going on in this test?  We create an `HttpRequest` object and pass it to
a function called `home_page`, which we're expecting to find in `lists.views`.
We get a response from the view (you won't be surprised to hear that this
object is of a class called `HttpResponse`).  Then, we assert that the
`content` of the response -- which is the HTML that we send to the user --
contains a particular `<title>` tag, with the word ``To-Do'' in -- because
that's what we specified in our functional test.

Does that make sense?  If not, sometimes it helps to work through tests
backwards:

* Our functional test wants a home page with "To-Do" in the title
* So, we look at our response content, and check that it has the correct HTML
  tag to make that work
* To get the response, we call a our view function with an HTTP request,
  simulating what would happen when the user's browser asks for the page
* Finally, we're expecting to find that view function inside 'lists/views.'

You can see how the unit test is driven by the functional test, but it's also
much closer to the actual code -- we're thinking like programmers now, rather
than thinking like users.  We're also much more closely tied into our
implementation - we're using Django's own classes, as well as functions we're planning to write.

Let's run the tests now and see how we get on:

....
$ python manage.py test lists

Traceback (most recent call last):
  File "source/chapter_2/awesomelists/manage.py", line 10, in <module>
    execute_from_command_line(sys.argv)
    [... lots of traceback]
    from lists.views import home_page
ImportError: cannot import name home_page
....

It's a very predictable failure, we tried to import something we haven't even
written yet, but it's still good news. Now that we have both a failing
functional test and a failing unit test, we have the testing goat's full
blessing to code away.


At last!  We actually write some application code!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


<mess follows>


The django module that takes care of resolving URLs is called `urlresolvers`, and
it contains a function called `reverse`, whose job is 

Now let's




The root 'urls.py' for the whole site is in the 'awesomelists/awesomelists'
folder. Let's go take a look:


[source,python]
----
from django.conf.urls import patterns, include, url

# Uncomment the next two lines to enable the admin:
# from django.contrib import admin
# admin.autodiscover()

urlpatterns = patterns('',
    # Examples:
    # url(r'^$', 'awesomelists.views.home', name='home'),
    # url(r'^awesomelists/', include('awesomelists.foo.urls')),

    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    # url(r'^admin/', include(admin.site.urls)),
)
----


A `url` entry starts with a regular expression that defines which urls it
applies to, and goes on to say where it should send those request -- either to
a dot-notation encoded function like `awesomelists.views.home`, or maybe to another
'urls.py' file somewhere else using `include`.

Let's hijack the first entry, `'r^$'`, which basically means an empty URL,
AKA the root of the site. Instead of the dot-notation, let's define a real 
function to handle that request.  For now, all we want to do is return
some basic HTML, so let's do that:

[source,python]
----
from django.conf.urls import patterns, include, url
from django.http import HttpResponse

# Uncomment the next two lines to enable the admin:
# from django.contrib import admin
# admin.autodiscover()

HOME_PAGE = '''
<html>
    <head><title>To-Do App</title></head>
</html>'''

def get_home_page(request):
    return HttpResponse(HOME_PAGE)

urlpatterns = patterns('',
    # Examples:
    url(r'^$', get_home_page),
    # url(r'^awesomelists/', include('awesomelists.foo.urls')),

    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    # url(r'^admin/', include(admin.site.urls)),
)
----

That's a minimal homepage view function -- it takes a one argument called
request, and returns an `HttpResponse` containing some HTML text.  Some pretty
minimal HTML text in this case, but in TDD we only ever write enough code to
fix the current failing test, which in this case is about the browser `title`.

Let's see if it worked:

....
$ python functional_tests.py 
F
======================================================================
FAIL: test_can_start_a_todo_list_and_get_a_url_for_it (__main__.NewVisitorTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "functional_tests.py", line 20, in test_can_start_a_todo_list_and_get_a_url_for_it
    self.fail('Finish the test!')
AssertionError: Finish the test!

----------------------------------------------------------------------
Ran 1 test in 1.675s

FAILED (failures=1)
....

Looks like it, that's another 'expected fail'.

Not too bad! We converted our tests to using `unittest`, learnt about
'urls.py', and we wrote a minimal view function to render some HTML for our
front page.  We can probably call that a Chapter -- as soon as we've done
a commit, of course.

....
git status # should show urls.py has changed
git diff # review the changed lines in urls.py
git commit -a # will automatically add those changes to your commit
....

