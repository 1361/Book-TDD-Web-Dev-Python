Chapter 2 - A basic front page for our site
-------------------------------------------

Let's adapt our test, which currently checks for the default Django "it worked"
page, and check instead for some of the things we want to see on the front
page.

Oh, it's probably time to reveal what kind of web app we're building. Well, I
thought we'd go for... a "to-do" list site!  In doing so I'm very much
following fashion - a few years ago all web tutorials were about building a
blog.  Then it was forums and polls, nowadays it's to-do lists.

The reason is that a to-do list is a really nice example. At its most basic
it is very simple indeed -- just a list of text strings -- so it's easy to
get a "minimum viable" todo app up and running.  But it can be extended in all
sorts of ways -- different persistence models, adding deadlines, reminders,
sharing with other users, and improving the client-side UI. It should allow
me to demonstrate all of the main aspects of web programming^*^, and how you apply
TDD to them.

`*` 'With the possible exception of payments integration.  But that's a world
of pain whose discovery I prefer to leave you, dear readers, to enjoy on your
own.  Let's concentrate on phase 1, "collect underpants", first.'


Using the Django test runner
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's take a very small step, and say the first thing we want is that the page
should have a new title + heading, saying ``My Stuff to get done''.  We'll
adapt our current `tests.py`.

First off, though, it would be nice to move our tests file into the same folder
structure as our Django code.  It's also a bit tedious to have to remember to
spin up the development server (using `manage.py runserver`) each time.
Thankfully, Django has some tools to help.

Django likes to strucure websites (or "projects") into components called
"apps". The idea is that you break your site's functionality down into
coherent parts or apps. Some of these apps might have been developed by 3rd
parties, and some of them you might re-use between different projects.

To start an app, we use another management called `startapp`:

....
$ python manage.py startapp fts
$ tree -I *.pyc
.
├── fts
│   ├── __init__.py
│   ├── models.py
│   ├── tests.py
│   └── views.py
├── manage.py
└── mysite
    ├── __init__.py
    ├── settings.py
    ├── urls.py
    └── wsgi.py
....

You'll see it creates a new folder called "fts" inside your project.  Inside
that, it creates a file called tests.py.  Let's go take a look at it, and see
if we can move our code across.


Here's the default contents...


[source,python]
----
"""
This file demonstrates writing tests using the unittest module. These will pass
when you run "manage.py test".

Replace this with more appropriate tests for your application.
"""

from django.test import TestCase


class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.assertEqual(1 + 1, 2)
----

Django is encouraging us to use `unittest`, which is Python's standard testing
framework.  Let's do that, along with a few other useful things which I'll
explain shortly

[source,python]
----
from selenium import webdriver
from django.test import LiveServerTestCase


class HomePageTest(LiveServerTestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()

    def tearDown(self):
        self.browser.quit()

    def test_home_page(self):
        self.browser.get('http://localhost:8000')
        self.assertIn('Django', self.browser.title)
----


<note on copy & paste>

Things to note:

* the `setUp` and `tearDown` methods.  These are special methods which get run
  before and after each test.  I'm using them to start and stop our browser --
  note that they're a bit like a try/except, in that tearDown will get run even
  if there's an error during the test itself.  No more Firefox windows left
  lying around!

* the main body of the test is in a method called `test_home_page` -- any method
  whose name starts with `test_` is a test method, and will be run by the test
  runner

* tests are organised into classes, which are subclasses of `unittest.TestCase`.
  Django suggested its own `django.test.TestCase`, but we're using a special
  one called `LiveServerTestCase`.  It will automatically start up the Django
  dev server for us, during our test run

