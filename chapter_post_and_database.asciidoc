[[chapter_post_and_database]]
Saving User Input: Testing the Database
---------------------------------------


Wiring Up Our Form to Send a POST Request
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To get our browser to send a POST request, we need to do two things:

1. Give the `<input>` element a `name=` attribute.
2. Wrap it in a `<form>` tag with `method="POST"`.

Let's adjust our template at 'lists/templates/home.html':

[role="dofirst-ch05l000"]
[role="sourcecode"]
.lists/templates/home.html
====
[source,html]
----
<h1>Your To-Do list</h1>
<form method="POST">
    <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
</form>

<table id="id_list_table">
----
====

Now, running our FTs gives us a slightly cryptic, unexpected error:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python functional_tests.py*]
[...]
Traceback (most recent call last):
  File "functional_tests.py", line 40, in
test_can_start_a_list_and_retrieve_it_later
    table = self.browser.find_element_by_id('id_list_table')
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: [id="id_list_table"]
----


((("functional tests (FTs)", "debugging techniques")))((("time.sleeps")))((("error messages", seealso="troubleshooting")))((("print statements")))((("debugging", "of functional tests")))When
a functional test fails with an unexpected failure, there are several
things we can do to debug it:

* Add `print` statements, to show, for example, what the current page text is.
* Improve the 'error message' to show more info about the current state.
* Manually visit the site yourself.
* Use `time.sleep` to pause the test during executionfootnote:[Lots of people
also swear by using `pdb.set_trace()` to be able to drop into a debugger,
particularly for unit tests. I'm not enough of a pdb user to be able to give a
good intro to it, but you should definitely check it out at some point in your
testing career.].

[role="sourcecode"]
.functional_tests.py
====
[source,python]
----
    # When she hits enter, the page updates, and now the page lists
    # "1: Buy peacock feathers" as an item in a to-do list table
    inputbox.send_keys(Keys.ENTER)
    time.sleep(10)

    table = self.browser.find_element_by_id('id_list_table')
----
====


[[csrf_error_screenshot]]
.Django DEBUG page showing CSRF error
image::images/twp2_0501.png["Django DEBUG page showing CSRF error"]


.Security: Surprisingly Fun!
*******************************************************************************
I want to recommend the textbook for my course, Ross Anderson's
<<seceng,_Security Engineering_>>. It's quite light on pure crypto, but it's
absolutely full of interesting discussions of unexpected topics like
lock picking, forging bank notes, inkjet printer cartridge [keep-together]#economics#, and
spoofing South African Air Force jets with replay attacks.  It's a huge tome,
about three inches thick, and I promise you it's an absolute page-turner.
*******************************************************************************


csrf token magic:

[role="sourcecode"]
.lists/templates/home.html
====
[source,html]
----
<form method="POST">
    <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
    {% csrf_token %}
</form>
----
====

----
AssertionError: False is not true : New to-do item did not appear in table
----

((("", startref="DBIpostcreate05")))((("", startref="POSTcreate05")))We
can put our normal short `time.sleep` back now though:


[role="sourcecode"]
.functional_tests.py
====
[source,python]
----
    # "1: Buy peacock feathers" as an item in a to-do list table
    inputbox.send_keys(Keys.ENTER)
    time.sleep(1)

    table = self.browser.find_element_by_id('id_list_table')
----
====


Processing a POST Request on the Server
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


[role="sourcecode"]
.lists/tests.py (ch05l005)
====
[source,python]
----
def test_uses_home_template(self):
    response = self.client.get('/')
    self.assertTemplateUsed(response, 'home.html')


def test_can_save_a_POST_request(self):
    response = self.client.post('/', data={'item_text': 'A new list item'})
    self.assertIn('A new list item', response.content.decode())
----
====

* Ask about: self.client.post

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test*]
[...]
AssertionError: 'A new list item' not found in '<html>\n    <head>\n
<title>To-Do lists</title>\n    </head>\n    <body>\n        <h1>Your To-Do
list</h1>\n        <form method="POST">\n            <input name="item_text"
[...]
</body>\n</html>\n'
----

In typical TDD style, we start with a deliberately silly return value:

[role="sourcecode"]
.lists/views.py
====
[source,python]
----
from django.http import HttpResponse
from django.shortcuts import render

def home_page(request):
    if request.method == 'POST':
        return HttpResponse(request.POST['item_text'])
    return render(request, 'home.html')
----
====


That gets our unit tests passing, but it's not really what we want.  What we 
really want to do is add the POST submission to the table in the home page
template.


Passing Python Variables to Be Rendered in the Template
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[role="sourcecode small-code"]
.lists/templates/home.html
====
[source,html]
----
<body>
    <h1>Your To-Do list</h1>
    <form method="POST">
        <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
        {% csrf_token %}
    </form>

    <table id="id_list_table">
        <tr><td>{{ new_item_text }}</td></tr>
    </table>
</body>
----
====


Let's adjust our unit test so that it checks whether we are still using the template:


[role="sourcecode"]
.lists/tests.py
====
[source,python]
----
    def test_can_save_a_POST_request(self):
        response = self.client.post('/', data={'item_text': 'A new list item'})
        self.assertIn('A new list item', response.content.decode())
        self.assertTemplateUsed(response, 'home.html')
----
====


And that will fail as expected:

----
AssertionError: No templates used to render the response
----

use in view:

[role="sourcecode"]
.lists/views.py (ch05l009)
====
[source,python]
----
def home_page(request):
    return render(request, 'home.html', {
        'new_item_text': request.POST['item_text'],
    })
----
====

[role="pagebreak-before"]
Running the unit tests again:

----
ERROR: test_uses_home_template (lists.tests.HomePageTest)
[...]
  File "...python-tdd-book/lists/views.py", line 5, in home_page
    'new_item_text': request.POST['item_text'],
[...]
django.utils.datastructures.MultiValueDictKeyError: "'item_text'"

----


((("unexpected failures")))((("Test-Driven Development (TDD)", "concepts", "unexpected failures")))An
'unexpected failure'.  

* This is the whole point of having tests!


[role="sourcecode"]
.lists/views.py
====
[source,python]
----
def home_page(request):
    return render(request, 'home.html', {
        'new_item_text': request.POST.get('item_text', ''),
    })
----
====

* confused about request.POST.get?  ask!


The unit tests should now pass.  Let's see what the functional tests say:

----
AssertionError: False is not true : New to-do item did not appear in table
----


TIP: If your functional tests show you a different error at this point,
    or at any point in this chapter, complaining about a 
    `StaleElementReferenceException`, you may need to increase the
    `time.sleep` explicit wait--try 2 or 3 seconds instead of 1;
    then read on to the next chapter for a more robust solution.




((("debugging", "improving error messages")))Hmm, not a wonderfully helpful error.  Let's use another of our FT debugging
techniques: improving the error message.

[role="sourcecode"]
.functional_tests.py (ch05l011)
====
[source,python]
----
self.assertTrue(
    any(row.text == '1: Buy peacock feathers' for row in rows),
    f"New to-do item did not appear in table. Contents were:\n{table.text}"  #<1>
)
----
====

* ask about f-strings?

That gives us a more helpful error message:

----
AssertionError: False is not true : New to-do item did not appear in table.
Contents were:
Buy peacock feathers
----

You know what could be even better than that?


[role="sourcecode"]
.functional_tests.py (ch05l012)
====
[source,python]
----
    self.assertIn('1: Buy peacock feathers', [row.text for row in rows])
----
====

* Discussion point: feeling clever about your code is a code smell!

Much better.  

----
    self.assertIn('1: Buy peacock feathers', [row.text for row in rows])
AssertionError: '1: Buy peacock feathers' not found in ['Buy peacock feathers']
----



TIP: If, instead, your FT seems to be saying the table is empty ("not found in
    []"), check your `<input>` tag--does it have the correct
    `name="item_text"` attribute?  Without it, the user's input won't be
    associated with the right key in `request.POST`.



[role="sourcecode pagebreak-after"]
.lists/templates/home.html
====
[source,html]
----
    <tr><td>1: {{ new_item_text }}</td></tr>
----
====

.Red/Green/Refactor and Triangulation
*******************************************************************************
((("Test-Driven Development (TDD)", "concepts", "Red/Green/Refactor")))((("Red/Green/Refactor")))((("unit-test/code cycle")))((("Test-Driven Development (TDD)", "concepts", "triangulation")))((("triangulation")))The
unit-test/code cycle is sometimes taught as 'Red, Green, Refactor':

* Start by writing a unit test which fails ('Red').
* Write the simplest possible code to get it to pass ('Green'), 'even if
that means [keep-together]#cheating#'.
* 'Refactor' to get to better code that makes more sense.

* Ask about triangulation if I don't mention it!

*******************************************************************************





Now we get to the `self.fail('Finish the test!')`.

[role="sourcecode"]
.functional_tests.py
====
[source,python]
----
    # There is still a text box inviting her to add another item. She
    # enters "Use peacock feathers to make a fly" (Edith is very
    # methodical)
    inputbox = self.browser.find_element_by_id('id_new_item')
    inputbox.send_keys('Use peacock feathers to make a fly')
    inputbox.send_keys(Keys.ENTER)
    time.sleep(1)

    # The page updates again, and now shows both items on her list
    table = self.browser.find_element_by_id('id_list_table')
    rows = table.find_elements_by_tag_name('tr')
    self.assertIn('1: Buy peacock feathers', [row.text for row in rows])
    self.assertIn(
        '2: Use peacock feathers to make a fly',
         [row.text for row in rows]
    )

    # Edith wonders whether the site will remember her list. Then she sees
    # that the site has generated a unique URL for her -- there is some
    # explanatory text to that effect.
    self.fail('Finish the test!')

    # She visits that URL - her to-do list is still there.
----
====

((("", startref="DTtemplate05")))Sure
enough, the functional tests return an error:

----
AssertionError: '1: Buy peacock feathers' not found in ['1: Use peacock
feathers to make a fly']
----

Three Strikes and Refactor
~~~~~~~~~~~~~~~~~~~~~~~~~~

Before we go further--we've got a bad ``code smell'' in this FT. 

[subs="specialcharacters,quotes"]
----
$ *git diff*
# should show changes to functional_tests.py, home.html,
# tests.py and views.py
$ *git commit -a*
----

Helper method:

[role="sourcecode"]
.functional_tests.py
====
[source,python]
----
    def tearDown(self):
        self.browser.quit()


    def check_for_row_in_list_table(self, row_text):
        table = self.browser.find_element_by_id('id_list_table')
        rows = table.find_elements_by_tag_name('tr')
        self.assertIn(row_text, [row.text for row in rows])


    def test_can_start_a_list_and_retrieve_it_later(self):
        [...]
----
====

Let's use it in the FT:

[role="sourcecode"]
.functional_tests.py
====
[source,python]
----
    # When she hits enter, the page updates, and now the page lists
    # "1: Buy peacock feathers" as an item in a to-do list table
    inputbox.send_keys(Keys.ENTER)
    time.sleep(1)
    self.check_for_row_in_list_table('1: Buy peacock feathers')

    # There is still a text box inviting her to add another item. She
    # enters "Use peacock feathers to make a fly" (Edith is very
    # methodical)
    inputbox = self.browser.find_element_by_id('id_new_item')
    inputbox.send_keys('Use peacock feathers to make a fly')
    inputbox.send_keys(Keys.ENTER)
    time.sleep(1)

    # The page updates again, and now shows both items on her list
    self.check_for_row_in_list_table('1: Buy peacock feathers')
    self.check_for_row_in_list_table('2: Use peacock feathers to make a fly')

    # Edith wonders whether the site will remember her list. Then she sees
    [...]
----
====

We run the FT again to check that it still behaves in the same way...

----
AssertionError: '1: Buy peacock feathers' not found in ['1: Use peacock
feathers to make a fly']
----

Good. Now we can commit the FT refactor as its own small, atomic change:


[subs="specialcharacters,quotes"]
----
$ *git diff* # check the changes to functional_tests.py
$ *git commit -a*
----

And back to work.  


The Django ORM and Our First Model
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's create a new class in 'lists/tests.py':

[role="sourcecode"]
.lists/tests.py
====
[source,python]
----
from lists.models import Item
[...]

class ItemModelTest(TestCase):

    def test_saving_and_retrieving_items(self):
        first_item = Item()
        first_item.text = 'The first (ever) list item'
        first_item.save()

        second_item = Item()
        second_item.text = 'Item the second'
        second_item.save()

        saved_items = Item.objects.all()
        self.assertEqual(saved_items.count(), 2)

        first_saved_item = saved_items[0]
        second_saved_item = saved_items[1]
        self.assertEqual(first_saved_item.text, 'The first (ever) list item')
        self.assertEqual(second_saved_item.text, 'Item the second')
----
====


((("Django framework", "tutorials")))Django's
ORM has many other helpful and intuitive features; this might be a
good time to skim through the
https://docs.djangoproject.com/en/1.11/intro/tutorial01/[Django
tutorial], which has an excellent intro to them.


NOTE: I've written this unit test in a very verbose style, as a way of
    introducing the Django ORM. I wouldn't recommend writing your model
    tests like this "in real life".  We'll actually rewrite this test to
    be much more concise <<rewrite-model-test,later on>>, in 
    <<chapter_advanced_forms>>.


* Ask about: unit tests and the database.


.Advanced Exercise:
********************************************************************

What's the simplest version of this test that still thoroughly tests the
class?

********************************************************************


[subs="specialcharacters,macros"]
----
ImportError: cannot import name 'Item'
----


[[first-django-model]]
[role="sourcecode"]
.lists/models.py
====
[source,python]
----
from django.db import models

class Item(object):
    pass
----
====

//TODO: suggestion from TR, since this is a new concept, consider using
// baby steps here.

That gets our test as far as: 

----
    first_item.save()
AttributeError: 'Item' object has no attribute 'save'
----

To give our `Item` class a `save` method, and to make it into a real Django
model, we make it inherit from the `Model` class:


[role="sourcecode"]
.lists/models.py
====
[source,python]
----
from django.db import models

class Item(models.Model):
    pass
----
====


Our First Database Migration
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

((("database migrations")))The
next thing that happens is a database error:

----
django.db.utils.OperationalError: no such table: lists_item
----

NOTE: Ask about "migrations are a VCS for your database"


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py makemigrations*]
Migrations for 'lists':
  lists/migrations/0001_initial.py
    - Create model Item
$ pass:quotes[*ls lists/migrations*]
0001_initial.py  __init__.py  __pycache__
----

If you're curious, you can go and take a look in the migrations file,
and you'll see it's a representation of our additions to 'models.py'.

In the meantime, we should find our tests get a little further.


The Test Gets Surprisingly Far
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test lists*]
[...]
    self.assertEqual(first_saved_item.text, 'The first (ever) list item')
AttributeError: 'Item' object has no attribute 'text'
----

* Discussion:  how did it get this far?

Next:

[role="sourcecode"]
.lists/models.py
====
[source,python]
----
class Item(models.Model):
    text = models.TextField()
----
====


You can read more on field types in the Django
https://docs.djangoproject.com/en/1.11/intro/tutorial01/#creating-models[tutorial]
and in the
https://docs.djangoproject.com/en/1.11/ref/models/fields/[documentation].



A New Field Means a New Migration
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Running the tests gives us another database error:

----
django.db.utils.OperationalError: no such column: lists_item.text
----

It's because we've added another new field to our database, which means we need
to create another migration.  Nice of our tests to let us know!

Let's try it:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py makemigrations*]
You are trying to add a non-nullable field 'text' to item without a default; we
can't do that (the database needs something to populate existing rows).
Please select a fix:
 1) Provide a one-off default now (will be set on all existing rows with a null
value for this column)
 2) Quit, and let me add a default in models.py
Select an option:pass:quotes[*2*]
----

Ah.  It won't let us add the column without a default value.  Let's pick option
2 and set a default in 'models.py'.  I think you'll find the syntax reasonably
self-explanatory:


[role="sourcecode"]
.lists/models.py
====
[source,python]
----
class Item(models.Model):
    text = models.TextField(default='')
----
====

//IDEA: default could get another unit test, which could actually replace the
// overly verbose one.

And now the migration should complete:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py makemigrations*]
Migrations for 'lists':
  lists/migrations/0002_item_text.py
    - Add field text to item
----

So, two new lines in 'models.py', two database migrations, and as a result,
the `.text` attribute on our model objects is now 
recognised as a special attribute, so it does get saved to the database, and
the tests pass...

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test lists*]
[...]

Ran 3 tests in 0.010s
OK
----


((("", startref="orm05")))((("", startref="DBTorm05")))((("", startref="DJForm05")))So
let's do a commit for our first ever model!


[subs="specialcharacters,quotes"]
----
$ *git status* # see tests.py, models.py, and 2 untracked migrations
$ *git diff* # review changes to tests.py and models.py
$ *git add lists*
$ *git commit -m "Model for list Items and associated migration"*
----


Saving the POST to the Database
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[role="sourcecode"]
.lists/tests.py
====
[source,python]
----
def test_can_save_a_POST_request(self):
    response = self.client.post('/', data={'item_text': 'A new list item'})

    self.assertEqual(Item.objects.count(), 1)  #<1>
    new_item = Item.objects.first()  #<2>
    self.assertEqual(new_item.text, 'A new list item')  #<3>

    self.assertIn('A new list item', response.content.decode())
    self.assertTemplateUsed(response, 'home.html')
----
====


Let's add that to a little to-do list of our own,
perhaps on a piece of scrap paper:


[role="scratchpad"]
*****
* 'Code smell: POST test is too long?'
*****

----
    self.assertEqual(Item.objects.count(), 1)
AssertionError: 0 != 1
----

Let's adjust our view:

[role="sourcecode"]
.lists/views.py
====
[source,python]
----
from django.shortcuts import render
from lists.models import Item

def home_page(request):
    item = Item()
    item.text = request.POST.get('item_text', '')
    item.save()

    return render(request, 'home.html', {
        'new_item_text': request.POST.get('item_text', ''),
    })
----
====

this is a bit silly , but let's continue for now:

[role="sourcecode"]
.lists/views.py
====
[source,python]
----
    return render(request, 'home.html', {
        'new_item_text': item.text
    })
----
====

Let's have a little look at our scratchpad. I've added a couple of the other
things that are on our mind:

[role="scratchpad"]
*****
* 'Don't save blank items for every request'
* 'Code smell: POST test is too long?'
* 'Display multiple items in the table'
* 'Support more than one list!'
*****


[role="sourcecode"]
.lists/tests.py
====
[source,python]
----
class HomePageTest(TestCase):
    [...]

    def test_only_saves_items_when_necessary(self):
        self.client.get('/')
        self.assertEqual(Item.objects.count(), 0)
----
====

That gives us a `1 != 0` failure.  


[role="sourcecode"]
.lists/views.py
====
[source,python]
----
def home_page(request):
    if request.method == 'POST':
        new_item_text = request.POST['item_text']  #<1>
        Item.objects.create(text=new_item_text)  #<2>
    else:
        new_item_text = ''  #<1>

    return render(request, 'home.html', {
        'new_item_text': new_item_text,  #<1>
    })
----
====

----
Ran 4 tests in 0.010s

OK
----


Redirect After a POST
~~~~~~~~~~~~~~~~~~~~~


https://en.wikipedia.org/wiki/Post/Redirect/Get[Always redirect after a POST],

[role="sourcecode"]
.lists/tests.py
====
[source,python]
----
    def test_can_save_a_POST_request(self):
        response = self.client.post('/', data={'item_text': 'A new list item'})

        self.assertEqual(Item.objects.count(), 1)
        new_item = Item.objects.first()
        self.assertEqual(new_item.text, 'A new list item')

        self.assertEqual(response.status_code, 302)
        self.assertEqual(response['location'], '/')
----
====

That gives us the error `200 != 302`.  We can now tidy up our view
substantially:

[role="sourcecode"]
.lists/views.py (ch05l028)
====
[source,python]
----
from django.shortcuts import redirect, render
from lists.models import Item

def home_page(request):
    if request.method == 'POST':
        Item.objects.create(text=request.POST['item_text'])
        return redirect('/')

    return render(request, 'home.html')
----
====


And the tests should now pass:

----
Ran 4 tests in 0.010s

OK
----


Better Unit Testing Practice: Each Test Should Test One Thing
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.Advanced exercise: each test should test one thing
********************************************************************


[role="sourcecode skipme"]
.lists/tests.py
====
[source,python]
----
    def test_can_save_a_POST_request(self):
        ?


    def test_redirects_after_POST(self):
        ?
----
====


And we should now see six tests pass instead of five:

[role="skipme"]
----
Ran 5 tests in 0.010s

OK
----

********************************************************************


Rendering Items in the Template
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

better!  Back to our to-do list:

[role="scratchpad"]
*****
* '[strikethrough line-through]#Don't save blank items for every request#'
* '[strikethrough line-through]#Code smell: POST test is too long?#'
* 'Display multiple items in the table'
* 'Support more than one list!'
*****

Crossing things off the list is almost as satisfying as seeing tests pass!


[role="sourcecode"]
.lists/tests.py
====
[source,python]
----
class HomePageTest(TestCase):
    [...]

    def test_displays_all_list_items(self):
        Item.objects.create(text='itemey 1')
        Item.objects.create(text='itemey 2')

        response = self.client.get('/')

        self.assertIn('itemey 1', response.content.decode())
        self.assertIn('itemey 2', response.content.decode())
----
====


NOTE: Ask about line spacing in tests.

That fails as expected:

----
AssertionError: 'itemey 1' not found in '<html>\n    <head>\n [...]
----


[role="sourcecode"]
.lists/templates/home.html
====
[source,html]
----
<table id="id_list_table">
    {% for item in items %}
        <tr><td>1: {{ item.text }}</td></tr>
    {% endfor %}
</table>
----
====

Just changing the template doesn't get our tests to green; we need to actually
pass the items to it from our home page view:

[role="sourcecode"]
.lists/views.py
====
[source,python]
----
def home_page(request):
    if request.method == 'POST':
        Item.objects.create(text=request.POST['item_text'])
        return redirect('/')

    items = Item.objects.all()
    return render(request, 'home.html', {'items': items})
----
====


That does get the unit tests to pass...moment of truth, will the functional
test pass?

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python functional_tests.py*]
[...]
AssertionError: 'To-Do' not found in 'OperationalError at /'
----

((("", startref="DTrender05")))((("debugging", "manual visits")))Oops, apparently not.

[[operationalerror]]
[role="width-75"]
.Another helpful debug message
image::images/twp2_0502.png["OperationalError at / no such table: lists_item"]


[role="pagebreak-before less_space"]
Creating Our Production Database with migrate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[role="sourcecode currentcontents"]
.superlists/settings.py
====
[source,python]
----
[...]
# Database
# https://docs.djangoproject.com/en/1.11/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
----
====


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py migrate*]
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, lists, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying lists.0001_initial... OK
  Applying lists.0002_item_text... OK
  Applying sessions.0001_initial... OK
----

Now we can refresh the page on 'localhost', see that our error is gone, and try
running the functional tests
again:footnote:[If you get a different error at this point, try restarting your
dev server--it may have gotten confused by the changes to the database
happening under its feet.]

----
AssertionError: '2: Use peacock feathers to make a fly' not found in ['1: Buy
peacock feathers', '1: Use peacock feathers to make a fly']
----

// -- usually fails instead with:

// selenium.common.exceptions.InvalidSelectorException: Message: Given css'
// selector expression "tr" is invalid: TypeError: can\'t access dead object'



So close!  We just need to get our list numbering right.  Another awesome
Django template tag, `forloop.counter`, will help here:

[role="sourcecode"]
.lists/templates/home.html
====
[source,html]
----
    {% for item in items %}
        <tr><td>{{ forloop.counter }}: {{ item.text }}</td></tr>
    {% endfor %}
----
====


If you try it again, you should now see the FT get to the end:

----
    self.fail('Finish the test!')
AssertionError: Finish the test!
----

[[items_left_over_from_previous_run]]
.There are list items left over from the last run of the test
image::images/twp2_0503.png["There are list items left over from the last run of the test"]

Oh dear. It looks like previous runs of the test are leaving stuff lying around
in our database.  

----
1: Buy peacock feathers
2: Use peacock feathers to make a fly
3: Buy peacock feathers
4: Use peacock feathers to make a fly
5: Buy peacock feathers
6: Use peacock feathers to make a fly
----


Grrr.  We're so close!

[subs="specialcharacters,quotes"]
----
$ *rm db.sqlite3*
$ *python manage.py migrate --noinput*
----

Apart from that little bug in our functional testing, we've got some code
that's more or less working.  Let's do a commit.((("", startref="DTproduction05")))  


[subs="specialcharacters,quotes"]
----
$ *git add lists*
$ *git commit -m "Redirect after POST, and show all items in template"*
----

TIP: You might find it useful to add markers for the end of each chapter, like
    *`git tag end-of-chapter-05`*.


Recap
~~~~~

Where are we?  

* We've got a form set up to add new items to the list using POST.

* We've set up a simple model in the database to save list items.

* We've learned about creating database migrations, both for the
  test database (where they're applied automatically) and for the real
  database (where we have to apply them manually).

* We've used our first couple of Django template tags:  `{% csrf_token %}`
  and the `{% for ... endfor %}` loop.

* And we've used at least three different FT debugging techniques: in-line
  print statements, ++time.sleep++s, and improving the error messages.

[role="pagebreak-before"]
But we've got a couple of items on our own to-do list, namely getting the FT to
clean up after itself, and perhaps more critically, adding support for more
than one list.

[role="scratchpad"]
*****
* '[strikethrough line-through]#Don't save blank items for every request#'
* '[strikethrough line-through]#Code smell: POST test is too long?#'
* '[strikethrough line-through]#Display multiple items in the table#'
* 'Clean up after FT runs'
* 'Support more than one list!'
*****

I mean, we 'could' ship the site as it is, but people might find it
strange that the entire human population has to share a single to-do list.  I
suppose it might get people to stop and think about how connected we all are to
one another, how we all share a common destiny here on Spaceship Earth, and how
we must all work together to solve the global problems that we face.  

But in practical terms, the site wouldn't be very useful.((("", startref="UIdatabase05")))

Ah well.

[role="pagebreak-before less_space"]
.Useful TDD Concepts
*******************************************************************************

Regression::
    ((("Test-Driven Development (TDD)", "concepts", "regression")))((("regression")))When
new code breaks some aspect of the application which used to work.

Unexpected failure::
    ((("Test-Driven Development (TDD)", "concepts", "unexpected failures")))((("unexpected failures")))When
a test fails in a way we weren't expecting.  This either means that
    we've made a mistake in our tests, or that the tests have helped us find
    a regression, and we need to fix something in our code.

Red/Green/Refactor::
    ((("Test-Driven Development (TDD)", "concepts", "Red/Green/Refactor")))((("Red/Green/Refactor")))Another
way of describing the TDD process. Write a test and see it fail
    (Red), write some code to get it to pass (Green), then Refactor to improve
    the [keep-together]#implementation#.

Triangulation::
    ((("Test-Driven Development (TDD)", "concepts", "triangulation")))((("triangulation")))Adding
a test case with a new specific example for some existing code, to
    justify generalising the implementation (which may be a "cheat" until that
    point).

Three strikes and refactor::
    ((("Test-Driven Development (TDD)", "concepts", "three strikes and refactor")))((("three strikes and refactor rule")))A
rule of thumb for when to remove duplication from code. When two pieces
    of code look very similar, it often pays to wait until you see a third
    use case, so that you're more sure about what part of the code really
    is the common, re-usable part to refactor out.

The scratchpad to-do list::
    ((("Test-Driven Development (TDD)", "concepts", "scratchpad to-do list")))((("scratchpad to-do list")))A
place to write down things that occur to us as we're coding, so that
    we can finish up what we're doing and come back to them later.

*******************************************************************************

