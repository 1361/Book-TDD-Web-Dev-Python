Chapter 4 - What are we doing with all these tests?
---------------------------------------------------

A moment's reflection - what are we up to with all these tests?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now that we've seen the basics of TDD in action, it's time to pause 
and talk about why we're doing it.

I'm imagining several of you, dear readers, have been holding back
some seething frustration -- perhaps some of you have done a bit of unit
testing before, and perhaps some of you are just in a hurry. You've been
biting back questions like:

* Aren't all these tests a bit excessive?
* Surely some of them are redundant -- there's duplication between
  the functional tests and the unit tests
* What are you doing importing `django.core.urlresolvers` in your
  unit tests?  Isn't that testing Django, ie. third-party code?
* Those unit tests seemed way too trivial -- testing one line of declaration,
  and a one-line function that returns a constant! Isn't that just a waste of
  time? Shouldn't we save our tests for more complex things?
* What about all those tiny changes during the unit-test/code cycle?  Surely we
  could have just skipped to the end... I mean, `home_page = None`?  Really??
* Surely you don't code like this in real life?

Ah, young grasshopper. I too was once full of questions like these.  And
actually, I still am -- it's always a good thing to second-guess what you're
doing, and ask yourself whether what you're doing really has value, or
whether you're just wasting your time out of habit.

So it's worth reminding ourselves of what the prize is here.  Do you remember
my story about my first ever project, which started out just fine but soon 
accumulated a mass of technical debt, messy code, invisible dependencies and
became impossible to refactor or maintain?  That really was a true story, and
I can't convey to you how different an experience it is to work on a project
with TDD.  You never have to worry about refactoring or experimenting - the
tests will tell you if you make a mistake.  You never have to worry about
regressions.  You never have to sit around clicking through the same pages on 
your site, checking that they work.  I'm constantly surprised at all the stupid
little logic errors that unit tests have saved us from too.

So the thing is, it really does work.  TDD will help you to develop an
application that works, with clean, bug-free code that's a pleasure to 
work with.  It's a goal worth chasing.

OK, so perhaps 'in general', you're prepared to concede that TDD is a good
idea, but maybe you still think I'm overdoing it?  Well, here are some thoughts

First off, TDD is a discipline, and what that means is that it's not something
that comes naturally; because many of the payoffs aren't immediate but actually
come in the longer term, you have to force yourself to do it in the moment.
That's what the image of the testing goat is supposed to illustrate -- you need
to be a bit bloody-minded about it.

So yes, in the short term it may feel a bit silly to write tests for simple
functions and constants.  It's perfectly possible to imagine still doing TDD, 
but following more relaxed rules where you don't unit test 'absolutely' 
everything.  But I'm trying to demonstrate a methodology here -- if you follow
these principles, you can't go wrong.  It may seem trivial now, because we've
started with a very simple example.  The problem comes when your application
gets complex -- that's when you really need your tests.  And the danger is
that complexity tends to sneak up on you, gradually.  You may not notice it
happening, but quite soon you're a boiled frog.

<mention Giles + urls?>
<django test client?>

There are two other things to say in favour of tiny, simple tests for simple
functions:

Firstly, if they're really trivial tests, then they won't take you that long to
write them. So stop moaning and just write them already.

Secondly, it's always good to have a placeholder.  You never know when you're
on the way to becoming a boiled frog.  Having a placeholder test for a simple
function means it's that much less of a psychological barrier to overcome when
the simple function gets a tiny bit more complex -- perhaps it grows an `if`.
Then a few weeks later it grows a `for` loop. Before you know it, it's a
recursive metaclass-based polymorphic tree parser.  But because it's had
tests from the very beginning, it's well tested.  The alternative, which
involves trying to decide when a function becomes ``complicated enough'', is
fraught with subjectivism, and because there's no placeholder, writing the
test is a bit more effort, so you tend to put it off further...


So instead of trying to figure out some hand-wavey subjective rules for when
you should write tests, and when you can get away with not bothering, I suggest
following the discipline for now -- like any discipline, you have to take the
time to learn the rules before you can break them.

Now, back to our onions.


Using Selenium to test user interactions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We ended the last Chapter with an expected failure saying

....
AssertionError: Finish the test!
....

Let's do just that!  Open up 'functional_tests.py'


[source,python]
----
import unittest
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

class NewVisitorTest(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()

    def tearDown(self):
        self.browser.quit()

    def test_can_start_a_todo_list_and_get_a_url_for_it(self):
        # Edith has heard about a cool new online to-do app. She goes
        # to check out its homepage
        self.browser.get('http://localhost:8000')

        # She notices the page title and header mention to-do lists
        self.assertIn('To-Do', self.browser.title)
        header_text = self.browser.find_element_by_tag_name('h1').text
        self.assertIn('To-Do', header_text)

        # She is invited to enter a to-do item straight away
        body_text = self.browser.find_element_by_tag_name('body').text
        self.assertIn('Enter a to-do item', body_text)

        # She types "Buy peacock feathers" into a text box (Edith's hobby
        # is tying fly-fishing lures)
        inputbox = self.browser.find_element_by_id('id_new_item')
        inputbox.send_keys('Buy peacock feathers')

        # When she hits enter, the page updates, and now the page lists
        # "1: Buy peacock feathers" as an item in a to-do list table
        inputbox.send_keys(Keys.ENTER)

        table = self.browser.find_element_by_id('id_list_table')
        rows = table.find_elements_by_tag_name('tr')
        self.assertTrue(any(
            '1: Buy peacock feathers' in row.text
            for row in rows
        ))

        # There is still a text box inviting her to add another item. She
        # enters "Use peacock feathers to make a fly" (Edith is very
        # methodical)
        self.fail('Finish the test!')
        [...]
----

We're using several of the methods that Selenium provides to examine web pages:
`find_element_by_tag_name`, `find_element_by_id`, and
+find_element*s*_by_tag_name+ (notice the extra `s`, which means it will return
several elements rather than just one).  We also use `send_keys`, which is
Selenium's way of typing into input elements - note also the `Keys` class
(don't forget to import it), which lets us send special keys like enter, but
also modifiers like 'Ctrl'.

So let's see how it gets on (don't forget to start up the dev server with
`python manage.py runserver` first)

....
$ python functional_tests.py 
[...]
NoSuchElementException: Message: u'Unable to locate element: {"method":"tag
name","selector":"h1"}' ; Stacktrace: Method
FirefoxDriver.prototype.findElementInternal_ threw an error in
file:///tmp/tmpPVV1Pz/extensions/fxdriver@googlecode.com/components/
driver_component.js 
....

Decoding that, the test is saying it can't find an `<h1>` element on the page.
Well, a failing test means we're allowed to make changes to the code!  Let's
take a look at 'views.py'


* templates
* Django test client?


