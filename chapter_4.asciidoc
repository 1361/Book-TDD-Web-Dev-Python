Chapter 4 - What are we doing with all these tests?
---------------------------------------------------

A moment's reflection - what are we up to with all these tests?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now that we've seen the basics of TDD in action, it's time to pause 
and talk about why we're doing it.

I'm imagining several of you, dear readers, have been holding back
some seething frustration -- perhaps some of you have done a bit of unit
testing before, and perhaps some of you are just in a hurry. You've been
biting back questions like:

* Aren't all these tests a bit excessive?
* Surely some of them are redundant -- there's duplication between
  the functional tests and the unit tests
* What are you doing importing `django.core.urlresolvers` in your
  unit tests?  Isn't that testing Django, ie. third-party code?
* Those unit tests seemed way too trivial -- testing one line of declaration,
  and a one-line function that returns a constant! Isn't that just a waste of
  time? Shouldn't we save our tests for more complex things?
* What about all those tiny changes during the unit-test/code cycle?  Surely we
  could have just skipped to the end... I mean, `home_page = None`?  Really??
* Surely you don't code like this in real life?

Ah, young grasshopper. I too was once full of questions like these.  And
actually, I still am -- it's always a good thing to second-guess what you're
doing, and ask yourself whether what you're doing really has value, or
whether you're just wasting your time out of habit.

So it's worth reminding ourselves of what the prize is here.  Do you remember
my story about my first ever project, which started out just fine but soon 
accumulated a mass of technical debt, messy code, invisible dependencies and
became impossible to refactor or maintain?  That really was a true story, and
I can't convey to you how different an experience it is to work on a project
with TDD.  You never have to worry about refactoring or experimenting - the
tests will tell you if you make a mistake.  You never have to worry about
regressions.  You never have to sit around clicking through the same pages on 
your site, checking that they work.  I'm constantly surprised at all the stupid
little logic errors that unit tests have saved us from too.

So the thing is, it really does work.  TDD will help you to develop an
application that works, with clean, bug-free code that's a pleasure to 
work with.  It's a goal worth chasing.

OK, so perhaps 'in general', you're prepared to concede that TDD is a good
idea, but maybe you still think I'm overdoing it?  Well, here are some thoughts

First off, TDD is a discipline, and what that means is that it's not something
that comes naturally; because many of the payoffs aren't immediate but actually
come in the longer term, you have to force yourself to do it in the moment.
That's what the image of the testing goat is supposed to illustrate -- you need
to be a bit bloody-minded about it.

So yes, in the short term it may feel a bit silly to write tests for simple
functions and constants.  It's perfectly possible to imagine still doing TDD, 
but following more relaxed rules where you don't unit test 'absolutely' 
everything.  But I'm trying to demonstrate a methodology here -- if you follow
these principles, you can't go wrong.  It may seem trivial now, because we've
started with a very simple example.  The problem comes when your application
gets complex -- that's when you really need your tests.  And the danger is
that complexity tends to sneak up on you, gradually.  You may not notice it
happening, but quite soon you're a boiled frog.

<mention Giles + urls?>
<django test client?>

There are two other things to say in favour of tiny, simple tests for simple
functions:

Firstly, if they're really trivial tests, then they won't take you that long to
write them. So stop moaning and just write them already.

Secondly, it's always good to have a placeholder.  You never know when you're
on the way to becoming a boiled frog.  Having a placeholder test for a simple
function means it's that much less of a psychological barrier to overcome when
the simple function gets a tiny bit more complex -- perhaps it grows an `if`.
Then a few weeks later it grows a `for` loop. Before you know it, it's a
recursive metaclass-based polymorphic tree parser.  But because it's had
tests from the very beginning, it's well tested.  The alternative, which
involves trying to decide when a function becomes ``complicated enough'', is
fraught with subjectivism, and because there's no placeholder, writing the
test is a bit more effort, so you tend to put it off further...


So instead of trying to figure out some hand-wavey subjective rules for when
you should write tests, and when you can get away with not bothering, I suggest
following the discipline for now -- like any discipline, you have to take the
time to learn the rules before you can break them.

Now, back to our onions.


Using Selenium to test user interactions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We ended the last Chapter with an expected failure saying

....
AssertionError: Finish the test!
....

Let's do just that!  Open up 'functional_tests.py'


[source,python]
----
import unittest
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

class NewVisitorTest(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()

    def tearDown(self):
        self.browser.quit()

    def test_can_start_a_todo_list_and_get_a_url_for_it(self):
        # Edith has heard about a cool new online to-do app. She goes
        # to check out its homepage
        self.browser.get('http://localhost:8000')

        # She notices the page title and header mention to-do lists
        self.assertIn('To-Do', self.browser.title)
        header_text = self.browser.find_element_by_tag_name('h1').text
        self.assertIn('To-Do', header_text)

        # She is invited to enter a to-do item straight away
        body_text = self.browser.find_element_by_tag_name('body').text
        self.assertIn('Enter a to-do item', body_text)

        # She types "Buy peacock feathers" into a text box (Edith's hobby
        # is tying fly-fishing lures)
        inputbox = self.browser.find_element_by_id('id_new_item')
        inputbox.send_keys('Buy peacock feathers')

        # When she hits enter, the page updates, and now the page lists
        # "1: Buy peacock feathers" as an item in a to-do list table
        inputbox.send_keys(Keys.ENTER)

        table = self.browser.find_element_by_id('id_list_table')
        rows = table.find_elements_by_tag_name('tr')
        self.assertTrue(any(
            '1: Buy peacock feathers' in row.text
            for row in rows
        ))

        # There is still a text box inviting her to add another item. She
        # enters "Use peacock feathers to make a fly" (Edith is very
        # methodical)
        self.fail('Finish the test!')
        [...]
----

We're using several of the methods that Selenium provides to examine web pages:
`find_element_by_tag_name`, `find_element_by_id`, and
+find_element*s*_by_tag_name+ (notice the extra `s`, which means it will return
several elements rather than just one).  We also use `send_keys`, which is
Selenium's way of typing into input elements - note also the `Keys` class
(don't forget to import it), which lets us send special keys like enter, but
also modifiers like 'Ctrl'.

So let's see how it gets on (don't forget to start up the dev server with
`python manage.py runserver` first)

....
$ python functional_tests.py 
[...]
NoSuchElementException: Message: u'Unable to locate element: {"method":"tag
name","selector":"h1"}' ; Stacktrace: Method
FirefoxDriver.prototype.findElementInternal_ threw an error in
file:///tmp/tmpPVV1Pz/extensions/fxdriver@googlecode.com/components/
driver_component.js 
....

Decoding that, the test is saying it can't find an `<h1>` element on the page.
Let's see what we can do to change the HTML of our home page


The ``Don't test constants'' rule, and our first refactor
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's take a look at our unit tests, 'lists/tests.py'.  Currently we're
testing for specific HTML strings, but that's not a particularly
efficient way of testing HTML.  In general, one of the rules of unit
testing is *Don't test contants*, and testing HTML as text is a lot like
testing a constant.

In other words, if you have some code that says:


[source,python]
----
wibble = 3
----

There's not much point in a test that says

[source,python]
----
from myprogram import wibble
assert wibble = 3
----

Unit tests are really about testing logic, flow control and
configuration. So, one of the solutions is to make constants explicit,
and re-use them in our tests.  

So, what we want to do now is make the HTML string that our view returns
into a constant.  That's a *refactor* -- when we change the code for
architectural reasons without changing its functionality.

That last bit is really important. If you try and add new functionality
at the same time as refactoring, you're much more likely to run into
trouble.  Refactoring is actually a whole discipline in itself, and
the main reference is Martin Fowler's <<refactoring,Refactoring>>.

For now, let's start by making sure we have a passing test suite, which
we can use to check our refactoring is safe:

Let's do that in 'lists/tests.py'

....
$ python manage.py test lists
[...]
OK
....

We have passing tests.  That means we're allowed to try some refactoring.
In 'lists/views.py':


[source,python]
----
from django.http import HttpResponse

HOME_PAGE_HTML = '<html><title>To-Do lists</title></html>'

def home_page(request):
    return HttpResponse(HOME_PAGE_HTML)
----

That's a change to the code - do the tests still pass?

....
$ python manage.py test lists
[...]
OK
....

Excellent.  Now we can refactor our tests, so that they use our
constant:


[source,python]
----
[...]
from lists.views import home_page, HOME_PAGE_HTML

class HomePageTest(TestCase):
    [...]

    def test_home_page_returns_correct_html(self):
        request = HttpRequest()
        response = home_page(request)
        self.assertEqual(response.content, HOME_PAGE_HTML)

----

And try running the tests again:

....
$ python manage.py test lists
[...]
OK
....

Now, that was an absolutely trivial example of refactoring. Yes, we
probably could have skipped a few of the steps in between.  But once 
again, I'm teaching a methodolody here.  The way Kent Beck (one of
the great legends of TDD) put it is:


[quote, Kent Beck, TDD by example]
----
Do I expect you to always code like this?  No. I just want you
to always 'be able to'.
----

We're unlikely to go wrong when it's such a simple example, but when
you get into refactoring more complex and sensitive code, the step-by-step
approach can make sure you never get into trouble, and you always go
from working code to working code.

In fact as I was writing this my first instinct was to dive in and change
the test first -- make it import `HOME_PAGE_HTML`, delete the 3
superfluous assertions and just check the constant, and then go ahead
and make the code change.  But notice how that actually would have left
space for me to break things: I could easily have defined the constant
as containing any arbitrary string, instead of the string with the
right `<html>` and `<title>` tags.

By following a refactoring procedure, I was able to constrain myself,
and have confidence that the new code does exactly what the old code 
did.

As I say, there's a whole book on refactoring and I encourage you to 
read it.  But the main lesson is:  keep refactoring and functionality
changes entirely separate.  Use the tests to prevent yourself from
screwing up.  And take advantage of nice, simple refactors like this one,
because all that practice will help you get it right when you really need
it.

It's usually a good idea to do a commit after any refactoring, so let's
do one now:

....
git status # we've changed the FT and the tests and views
git diff # review the changes to the code
git commit -a  
# message should be "extended FT, and refactor home page to use a
# constant for its HTML
....


Something
~~~~~~~~~

In the meantime, our functional test is still failing.  Let's now 
make an actual code change to get it passing.  Because the HTML is now
in a constant, we can feel free to make changes to it, without needing
to write any extra unit tests

[source,python]
----
HOME_PAGE_HTML = '''<html>
<head>
    <title>To-Do lists</title>
</head>
<body>
    <h1>To-Do Lists</h1>
</body>
</html>'''
----




