Chapter 4 - What are we doing with all these tests?
---------------------------------------------------

A moment's reflection - what are we up to with all these tests?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now that we've seen the basics of TDD in action, it's time to pause 
and talk about why we're doing it.

I'm imagining several of you, dear readers, have been holding back
some seething frustration -- perhaps some of you have done a bit of unit
testing before, and perhaps some of you are just in a hurry. You've been
biting back questions like:

* Aren't all these tests a bit excessive?
* Surely some of them are redundant -- there's duplication between
  the functional tests and the unit tests
* What are you doing importing `django.core.urlresolvers` in your
  unit tests?  Isn't that testing Django, ie. third-party code?
* Those unit tests seemed way too trivial -- testing one line of declaration,
  and a one-line function that returns a constant! Isn't that just a waste of
  time? Shouldn't we save our tests for more complex things?
* What about all those tiny changes during the unit-test/code cycle?  Surely
  we could have just skipped to the end... I mean, `home_page = None`?
  Really??
* Surely you don't code like this in real life?

Ah, young grasshopper. I too was once full of questions like these.  And
actually, I still am -- it's always a good thing to second-guess what you're
doing, and ask yourself whether what you're doing really has value, or
whether you're just wasting your time out of habit.

So it's worth reminding ourselves of what the prize is here.  Do you remember
my story about my first ever project, which started out just fine but soon 
accumulated a mass of technical debt, messy code, invisible dependencies and
became impossible to refactor or maintain?  That really was a true story, and
I can't convey to you how different an experience it is to work on a project
with TDD.  You never have to worry about refactoring or experimenting - the
tests will tell you if you make a mistake.  You never have to worry about
regressions.  You never have to sit around clicking through the same pages on 
your site, checking that they work.  I'm constantly surprised at all the stupid
little logic errors that unit tests have saved us from too.

So the thing is, it really does work.  TDD will help you to develop an
application that works, with clean, bug-free code that's a pleasure to 
work with.  It's a goal worth chasing.

OK, so perhaps 'in general', you're prepared to concede that TDD is a good
idea, but maybe you still think I'm overdoing it?  Well, here are some thoughts

First off, TDD is a discipline, and what that means is that it's not something
that comes naturally; because many of the payoffs aren't immediate but actually
come in the longer term, you have to force yourself to do it in the moment.
That's what the image of the testing goat is supposed to illustrate -- you need
to be a bit bloody-minded about it.

So yes, in the short term it may feel a bit silly to write tests for simple
functions and constants.  It's perfectly possible to imagine still doing TDD, 
but following more relaxed rules where you don't unit test 'absolutely' 
everything.  But I'm trying to demonstrate a methodology here -- if you follow
these principles, you can't go wrong.  It may seem trivial now, because we've
started with a very simple example.  The problem comes when your application
gets complex -- that's when you really need your tests.  And the danger is
that complexity tends to sneak up on you, gradually.  You may not notice it
happening, but quite soon you're a boiled frog.

<mention Giles + urls?>
<django test client?>

There are two other things to say in favour of tiny, simple tests for simple
functions:

Firstly, if they're really trivial tests, then they won't take you that long to
write them. So stop moaning and just write them already.

Secondly, it's always good to have a placeholder.  You never know when you're
on the way to becoming a boiled frog.  Having a placeholder test for a simple
function means it's that much less of a psychological barrier to overcome when
the simple function gets a tiny bit more complex -- perhaps it grows an `if`.
Then a few weeks later it grows a `for` loop. Before you know it, it's a
recursive metaclass-based polymorphic tree parser.  But because it's had
tests from the very beginning, it's well tested.  The alternative, which
involves trying to decide when a function becomes ``complicated enough'', is
fraught with subjectivism, and because there's no placeholder, writing the
test is a bit more effort, so you tend to put it off further...


So instead of trying to figure out some hand-wavey subjective rules for when
you should write tests, and when you can get away with not bothering, I suggest
following the discipline for now -- like any discipline, you have to take the
time to learn the rules before you can break them.

Now, back to our onions.


Using Selenium to test user interactions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We ended the last Chapter with an expected failure saying

....
AssertionError: Finish the test!
....

Let's do just that!  Open up 'functional_tests.py'


[source,python]
----
import unittest
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

class NewVisitorTest(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()

    def tearDown(self):
        self.browser.quit()

    def test_can_start_a_todo_list_and_get_a_url_for_it(self):
        # Edith has heard about a cool new online to-do app. She goes
        # to check out its homepage
        self.browser.get('http://localhost:8000')

        # She notices the page title and header mention to-do lists
        self.assertIn('To-Do', self.browser.title)
        header_text = self.browser.find_element_by_tag_name('h1').text
        self.assertIn('To-Do', header_text)

        # She is invited to enter a to-do item straight away
        body_text = self.browser.find_element_by_tag_name('body').text
        self.assertIn('Enter a to-do item', body_text)

        # She types "Buy peacock feathers" into a text box (Edith's hobby
        # is tying fly-fishing lures)
        inputbox = self.browser.find_element_by_id('id_new_item')
        inputbox.send_keys('Buy peacock feathers')

        # When she hits enter, the page updates, and now the page lists
        # "1: Buy peacock feathers" as an item in a to-do list table
        inputbox.send_keys(Keys.ENTER)

        table = self.browser.find_element_by_id('id_list_table')
        rows = table.find_elements_by_tag_name('tr')
        self.assertTrue(any(
            '1: Buy peacock feathers' in row.text
            for row in rows
        ))

        # There is still a text box inviting her to add another item. She
        # enters "Use peacock feathers to make a fly" (Edith is very
        # methodical)
        self.fail('Finish the test!')
        [...]
----

We're using several of the methods that Selenium provides to examine web
pages: `find_element_by_tag_name`, `find_element_by_id`, and
+find_element*s*_by_tag_name+ (notice the extra `s`, which means it will
return several elements rather than just one).  We also use `send_keys`,
which is Selenium's way of typing into input elements - note also the
`Keys` class (don't forget to import it), which lets us send special keys
like enter, but also modifiers like 'Ctrl'.

So let's see how it gets on (don't forget to start up the dev server with
`python manage.py runserver` first)

....
$ python functional_tests.py 
[...]
NoSuchElementException: Message: u'Unable to locate element: {"method":"tag
name","selector":"h1"}' ; Stacktrace: Method
FirefoxDriver.prototype.findElementInternal_ threw an error in
file:///tmp/tmpPVV1Pz/extensions/fxdriver@googlecode.com/components/
driver_component.js 
....

Decoding that, the test is saying it can't find an `<h1>` element on the page.
Let's see what we can do to change the HTML of our home page


The ``Don't test constants'' rule, and templates to the rescue
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's take a look at our unit tests, 'lists/tests.py'.  Currently we're
testing for specific HTML strings, but that's not a particularly
efficient way of testing HTML.  In general, one of the rules of unit
testing is *Don't test contants*, and testing HTML as text is a lot like
testing a constant.

In other words, if you have some code that says:


[source,python]
----
wibble = 3
----

There's not much point in a test that says

[source,python]
----
from myprogram import wibble
assert wibble = 3
----

Unit tests are really about testing logic, flow control and
configuration. Making assertions about exactly what sequence of characters
we have in our HTML strings isn't doing that.  

What's more, mangling raw strings in Python really isn't a great way of
dealing with HTML.  There's a much better solution, which is to use 
templates.  Quite apart from anything else, if we can keep HTML to one
side in a file whose name ends in `.html`, we'll get better syntax 
highlighting! There are lots of Python templating frameworks out there,
and Django has its own which work very well.  Let's see if we can use
that instead of our current string wrangling.


What we want to do now is make our view function return exactly the same
HTML, but just using a different process.That's a *refactor* -- when we
change the code for architectural reasons without changing its
functionality.

That last bit is really important. If you try and add new functionality
at the same time as refactoring, you're much more likely to run into
trouble.  Refactoring is actually a whole discipline in itself, and
the main reference is Martin Fowler's <<refactoring,Refactoring>>.

For now, let's start by making sure we have a passing test suite, which
we can use to check our refactoring is safe:

Let's do that in 'lists/tests.py'

....
$ python manage.py test lists
[...]
OK
....

We have passing tests.  That means we're allowed to try some refactoring.

Let's start by taking our HTML string and putting it into its own file. 
We'll create a directory called 'lists/templates' to keep templates in,
and then open a file at 'lists/templates/home.html', to which we'll
transfer our HTML:

[source,html]
----
<html>
    <title>To-Do lists</title>
</html>
----

Mmmh, syntax-highlighted... Much nicer!  Now to change our view function:

[source,python]
----
from django.shortcuts import render


def home_page(request):
    return render(request, 'home.html')
----

Instead of building our own `HttpResponse`, we now use the django 
`render` function.  It takes the request as its first parameter (for
reasons we'll go into later) and the name of the template.  Django
will automatically search folders called 'templates' inside any of
your apps' directories.

That's a change to the code - do the tests still pass?

....
$ python manage.py test lists
    self.assertTrue(response.content.endswith('</html>'))
AssertionError: False is not true
....

Darn, not quite. I had to do a little `print repr(response.content)` to
debug this, but it turns out that the templates are introducing an 
additional newline at the end.  We can get them to pass like this:


[source,python]
----
self.assertTrue(response.content.strip().endswith('</html>'))
----

And try running the tests again:

....
$ python manage.py test lists
[...]
OK
....

But better still, we should now refactor the tests so that they're
no longer testing constants -- instead, they should check that we're
rendering the right template.  Another django helper function called
`render_to_string` is our friend here:


[source,python]
----
from django.template.loader import render_to_string
[...]

    def test_home_page_returns_correct_html(self):
        request = HttpRequest()
        response = home_page(request)
        expected_html = render_to_string('home.html')
        self.assertEqual(response.content, expected_html)
----

So now, instead of testing constants we're testing our implementation

NOTE: Yes, I know the Django Test Client has tools to test templates. I'll
introduce that later. For now, I think it's good to show how some of the
internals work.

On refactoring
~~~~~~~~~~~~~~

Now, that was an absolutely trivial example of refactoring. Yes, we
probably could have skipped a few of the steps in between.  But once 
again, I'm teaching a methodolody here.  The way Kent Beck (one of
the great legends of TDD) put it is:


[quote, Kent Beck, TDD by example]
----
Do I expect you to always code like this?  No. I just want you
to always 'be able to'.
----

We're unlikely to go wrong when it's such a simple example, but when
you get into refactoring more complex and sensitive code, the step-by-step
approach can make sure you never get into trouble, and you always go
from working code to working code.

In fact as I was writing this my first instinct was to dive in and change
the test first -- make it import `HOME_PAGE_HTML`, delete the 3
superfluous assertions and just check the constant, and then go ahead
and make the code change.  But notice how that actually would have left
space for me to break things: I could easily have defined the constant
as containing any arbitrary string, instead of the string with the
right `<html>` and `<title>` tags.

By following a refactoring procedure, I was able to constrain myself,
and have confidence that the new code does exactly what the old code 
did.

As I say, there's a whole book on refactoring and I encourage you to 
read it.  But the main lesson is:  keep refactoring and functionality
changes entirely separate.  Use the tests to prevent yourself from
screwing up.  And take advantage of nice, simple refactors like this one,
because all that practice will help you get it right when you really need
it.

It's usually a good idea to do a commit after any refactoring, so let's
do one now:

....
git status # see changes to the FT, lists.py and views.py 
           # but also the new templates folder
git add .
git diff --staged # review the changes we're about to commit
git commit # message should be, eg "extended FT, and refactored
           # home page view to use a template
....


Something
~~~~~~~~~

In the meantime, our functional test is still failing.  Let's now 
make an actual code change to get it passing.  Because our HTML is now
in a template, we can feel free to make changes to it, without needing
to write any extra unit tests.

[source,html]
----
<html>
    <head>
        <title>To-Do lists</title>
    </head>
    <body>
        <h1>Your To-Do list</h1>
    </body>
</html>
----

Let's see if our functional test likes it a little better:

.....
AssertionError: 'Enter a to-do item' not found in u'Your To-Do list'
.....

OK...

[source,html]
----
<html>
    <head>
        <title>To-Do lists</title>
    </head>
    <body>
        <h1>Your To-Do list</h1>
        <label>Enter a to-do item</label>
    </body>
</html>
----

And now?

....
NoSuchElementException: Message: u'Unable to locate element:
{"method":"id","selector":"id_new_item"}' [...]
....

[source,html]
----
<html>
    <head>
        <title>To-Do lists</title>
    </head>
    <body>
        <h1>Your To-Do list</h1>
        <label>Enter a to-do item</label>
        <input id="id_new_item" />
    </body>
</html>
----

And now?

....
NoSuchElementException: Message: u'Unable to locate element:
{"method":"id","selector":"id_list_table"}'[...]
....

To get that to work we'll 

