Database migrations
-------------------

We've made a change to our database -- we've added some constraints to some
of the columns in the list table.  In order to apply these to our live site,
we'll need to alter the tables in the existing database. This is a
'database migration'.

The current established tool for database migrations with Django is called 
http://south.readthedocs.org/en/latest/index.html[South].  

NOTE: At the time of writing, Andrew Godwin, South's talented creator, had just
finished a
http://www.kickstarter.com/projects/andrewgodwin/schema-migrations-for-django[project]
to integrate South into the Django core, in the shape of a new feature called
https://docs.djangoproject.com/en/dev/topics/migrations/[Migrations]. I plan to
upgrade to using this new version of south at some point before publishing this
book, but I got blocked by a https://code.djangoproject.com/ticket/21236][bug].


We start by installing South:

[subs="specialcharacters,quotes"]
----
$ *../virtualenv/bin/pip install south*
[...]
Successfully installed Django
Cleaning up...
$ *../virtualenv/bin/django-admin.py --version*
1.7.dev20131006142710
----

We add it to `INSTALLED_APPS`:

[role="sourcecode"]
.superlists/settings.py
[source,python]
----
INSTALLED_APPS = (
    [...]
    # 'django.contrib.admindocs',
    'lists',
    'functional_tests',
   'south',
)
----


And to 'requirements.txt':

[role="sourcecode"]
.requirements.txt
[source,text]
----
Django==1.5.1
gunicorn==17.5
south==1.8.2
----

We can commit that to version control:

[subs="specialcharacters,quotes"]
----
$ *git commit -am "Add South"
----

Creating an initial migration to match the current live state
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For migrations to work, they need to know what we're migrating from and to.
The place this really matters is on the live server, so we want to be able
to migrate from the database state as it currently is on live, to the state
that's in the latest version of the code.

Here's where version control comes in useful. We can use `git log` to look back
for a commit that we made during chapter 8, or maybe right at the beginning of
chapter 9.

----
$ *git log --oneline*
18480bd Create base FT class and a class for each test. --ch09l002--
87e99b5 Move functional tests into a folder
7fa00f1 New ft for item validaiton. --ch09l001--
8ca488b Add a fabfile for automated deploys    # <---  this looks like it!
d28e6ea Notes and template config files for provisioning
6b0d814 Add gunicorn to virtualenv requirements
6a6c91e Add requirements.txt for virtualenv
$ *git checkout 8ca488b*
----

TODO: use a git tag to mark the last deployed version back in chapter 8

Once our source tree is back to a state that matches live, we create
our initial migration.  First you'll need to re-add south to 
`INSTALLED_APPS` in 'settings.py'. Yes, I know.  But we're essentially
re-writing history here, and sometimes that's hard.

Once you've done that, here's how we do an initial migration:

[subs="specialcharacters,quotes"]
----
$ ../virtualenv/bin/python3 manage.py schemamigration lists --initial
Creating __init__.py in '/home/harry/Dropbox/book/source/chapter_09/superlists/lists/migrations'...
 + Added model lists.List
 + Added model lists.Item
Created 0001_initial.py. You can now apply this migration with: ./manage.py migrate lists
----

The migration is stored in a directory called 'migrations' inside the
lists app:

[subs="specialcharacters,quotes"]
----
$ *tree lists/migrations/*
lists/migrations/
├── 0001_initial.py
├── __init__.py
└── __pycache__
----

We go back to the latest code version:

[subs="specialcharacters,quotes"]
----
$ *git checkout -f master*  # -f ignores change to settings.py
----

And we add the migration to version control:

[subs="specialcharacters,quotes"]
----
$ *git add lists/migrations/*
$ *git status*  # should show 2 new files
$ *git commit -m"initial migration to match live"*
----

Next we create the "real" migration that we want to apply.  This time
we use `--auto`:

[subs="specialcharacters,quotes"]
----
$ *../virtualenv/bin/python manage.py schemamigration --auto lists*
 + Added unique constraint for ['list', 'text'] on lists.Item
Created 0002_auto__add_unique_item_list_text.py. You can now apply this
migration with: ./manage.py migrate lists
----

Sure enough, it spots the new constraint.  Let's add that to VCS too:

[subs="specialcharacters,quotes"]
----
$ *git add lists/migrations/0002_auto__add_unique_item_list_text.py*
$ *git commit -m"Add new migration for list item uniqueness constraint"*
----

Migrations: like a VCS for your database
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The way migrations work is that they store a series of pictures of what your
database looks like as your code evolves.  In order to apply a migration, the
migrations tool also needs to have a view of what the database 'currently'
looks like.  

But, because we only started using migrations half-way through our development
(and this is quite a common occurrence), the migrations tool doesn't know
where it currently is.  In order to tell it, we do what's called a "fake" 
migration, to tell it that the current database state is at the 0001 migration
that we stored earlier, and that the one we want to go to is 0002.

Let's test this out locally.  First, we go and make a database that has the old
state, ie one that looks like live:

[subs="specialcharacters,quotes"]
----
$ *git checkout 8ca488b*
$ *rm ../database/database.sqlite*
$ *python3 manage.py syncdb --noinput*
$ *git checkout master*
----

Now, back on master, if you try doing a migration, you'll see that
Django is confused:

[subs="specialcharacters,quotes"]
----
$ *../virtualenv/bin/python3 manage.py migrate*
Running migrations for lists:
 - Migrating forwards to 0002_auto__add_unique_item_list_text.
 > lists:0001_initial
FATAL ERROR - The following SQL query failed: CREATE TABLE "lists_list" ("id" integer NOT NULL PRIMARY KEY)
[...]
 ! NOTE: The error which caused the migration to fail is further up.
Error in migration: lists:0001_initial
DatabaseError: table "lists_list" already exists
----

It's because Django is confused about the current state of the database. It 
thinks it needs to create this lists table, but it's already there. Here's how
we tell it that the database currently reflects the place where we are at
migration 0001, ie the place where live is:

----
$ *../virtualenv/bin/python3 manage.py migrate lists --fake 0001*
Running migrations for lists:
 - Migrating forwards to 0001_initial.
 > lists:0001_initial
   (faked)
----

And now we can test applying the real migration we want to do to
live:

----
$ *../virtualenv/bin/python3 manage.py migrate lists
Running migrations for lists:
 - Migrating forwards to 0002_auto__add_unique_item_list_text.
 > lists:0002_auto__add_unique_item_list_text
 - Loading initial data for lists.
Installed 0 object(s) from 0 fixture(s)
----

Brilliant! Are you confused?  I am, slightly, and I'm the one writing this.
Here's a recap:

* we need to apply a database migration to the live database when we deploy, 
to add the uniqueness constraint
* we're going to use South migrations for this.  We've created two migrations,
one (0001) which takes us from nothing to the old state, and one which takes
us from there to the state we want (0002)
* to test this, we've created a database in the same state as live by
checking out our old codebase and doing a syncdb
* in order to apply a migration, South needs to know what the current state
of the database is
* we tell it by applying a "fake" version of migration 0001
* then we're in a position to apply the real migration, 0002

So how are we actually going to do this on our live servers?  By replicating
those last two steps.  We're using a fabfile for our deployments, so let's 
adjust it now:

TODO: fix bug in fabfile checkout code (correct use of git reset)

[role="sourcecode"]
.dploy_tools/fabfile.py
[source,python]
----
def _update_database(source_folder):
    run('cd %s && ../virtualenv/bin/python3 manage.py syncdb' % (source_folder,))
    # one-off fake database migration. remove me before next deploy
    run('cd %s && ../virtualenv/bin/python3 manage.py migrate lists --fake 0001' % (
        source_folder,
    ))
    run('cd %s && ../virtualenv/bin/python3 manage.py migrate' % (source_folder,))
----

Still nervous?  Me too, but that's why we have a staging environment. Here 
goes nothing!

----
$ cd deploy_tools
$ fab deploy --host=superlists.ottg.eu
[superlists.ottg.eu] Executing task 'deploy'
[superlists.ottg.eu] run: mkdir -p /home/harry/sites/superlists.ottg.eu

[...]

[superlists.ottg.eu] run: cd /home/harry/sites/superlists.ottg.eu/source && ../virtualenv/bin/python3 manage.py syncdb
[superlists.ottg.eu] out: Syncing...
[superlists.ottg.eu] out: Creating tables ...
[superlists.ottg.eu] out: Creating table south_migrationhistory
[superlists.ottg.eu] out: Installing custom SQL ...
[superlists.ottg.eu] out: Installing indexes ...
[superlists.ottg.eu] out: Installed 0 object(s) from 0 fixture(s)
[superlists.ottg.eu] out: 
[superlists.ottg.eu] out: Synced:
[superlists.ottg.eu] out:  > django.contrib.auth
[superlists.ottg.eu] out:  > django.contrib.contenttypes
[superlists.ottg.eu] out:  > django.contrib.sessions
[superlists.ottg.eu] out:  > django.contrib.sites
[superlists.ottg.eu] out:  > django.contrib.messages
[superlists.ottg.eu] out:  > django.contrib.staticfiles
[superlists.ottg.eu] out:  > functional_tests
[superlists.ottg.eu] out:  > south
[superlists.ottg.eu] out: 
[superlists.ottg.eu] out: Not synced (use migrations):
[superlists.ottg.eu] out:  - lists
[superlists.ottg.eu] out: (use ./manage.py migrate to migrate these)
[superlists.ottg.eu] out: 

[superlists.ottg.eu] run: cd /home/harry/sites/superlists.ottg.eu/source && ../virtualenv/bin/python3 manage.py migrate lists --fake 0001
[superlists.ottg.eu] out:  - Soft matched migration 0001 to 0001_initial.
[superlists.ottg.eu] out: Running migrations for lists:
[superlists.ottg.eu] out:  - Migrating forwards to 0001_initial.
[superlists.ottg.eu] out:  > lists:0001_initial
[superlists.ottg.eu] out:    (faked)
[superlists.ottg.eu] out: 
----

Hooray!


On testing database migrations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


* seen how to do it using the staging site.
* automated deployment process is a help

