A simple form
-------------

At the end of the last chapter, we were left with the thought that there
was too much duplication of code in the validation handling bits of our
views. Django encourages you to use Form classes to do the work of validating
user input, and choosing what error messages to display. Let's see how that
works.

As we go through the chapter, we'll also improve our view unit tests.
Currently, many of them test several things at once.  We'll move them towards
best practice, where each has a single assertion.


Moving validation logic into a form
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TIP: In Django, a complex view is a code smell.  Could some of that logic
be pushed out to a form?  Or to some custom methods on the model class? Or
maybe even to a non-Django module that represents your business logic?

Forms have several powers in Django:

* They can process user input and validate it for errors.

* They can be rendered used in templates to render HTML input elements,
  and error messages too.

* And, as we'll see later, some of them can even save data to the database
  for you.

//TODO: some kind of note that you don't *have* to use all 3 functionalities

Let's do a little experimenting with forms by using a unit test.  My plan is to
iterate towards a complete solution, and hopefully introduce forms gradually
enough that they'll make sense if you've never seen them before!

First we add a new file for our forms unit tests, and we start with a test that
just looks at the form HTML:

[role="sourcecode"]
.lists/tests/test_forms.py 
[source,python]
----
from django.test import TestCase

from lists.forms import ItemForm


class ItemFormTest(TestCase):

    def test_form_renders_item_text_input(self):
        form = ItemForm()
        self.fail(form.as_p())
----

`form.as_p()` renders the form as HTML.  This unit test is using a self.fail
for some explanatory coding.  You could just as easily use a `manage.py shell`
session, although you'd need to keep reloading your code for each change.

For now it will just fail with an import error.

Let's make a minimal form.  It inherits from the base Form class, and has 
a single field called `item_text`:

[role="sourcecode"]
.lists/forms.py 
[source,python]
----
from django import forms

class ItemForm(forms.Form):
    item_text = forms.CharField()
----

We now see a failure message which tells us what the auto-generated form 
HTML will look like.

----
    self.fail(form.as_p())
AssertionError: <p><label for="id_item_text">Item text:</label> <input
id="id_item_text" name="item_text" type="text" /></p>
----

It's already pretty close to what we have in 'base.html'.  We're missing
the placeholder attribute and the bootstrap CSS classes.  Let's make our
unit test into a test for that:

[role="sourcecode"]
.lists/tests/test_forms.py 
[source,python]
----
class ItemFormTest(TestCase):

    def test_form_item_input_has_placeholder_and_css_classes(self):
        form = ItemForm()
        self.assertIn('placeholder="Enter a to-do item"', form.as_p())
        self.assertIn('class="form-control input-lg"', form.as_p())
----

That gives us a fail which justifies some real coding.  How can we customise
the input for a form field?  Using a "widget".  Here it is with just
the placeholder:


[role="sourcecode"]
.lists/forms.py 
[source,python]
----
class ItemForm(forms.Form):
    item_text = forms.CharField(
        widget=forms.fields.TextInput(attrs={
            'placeholder': 'Enter a to-do item',
        }),
    )
----

That gives:

----
AssertionError: 'class="form-control input-lg"' not found in '<p><label
for="id_item_text">Item text:</label> <input id="id_item_text" name="item_text"
placeholder="Enter a to-do item" type="text" /></p>'
----

And then:

[role="sourcecode"]
.lists/forms.py 
[source,python]
----
    widget=forms.fields.TextInput(attrs={
        'placeholder': 'Enter a to-do item',
        'class': 'form-control input-lg',
    }),
----

NOTE: doing this sort of widget customisation would get tedious if we 
had a much larger, more complex form.  Check out
https://django-crispy-forms.readthedocs.org/[django-crispy-forms] and
http://django-floppyforms.readthedocs.org/en/latest/[django-floppy-forms]
for some help.


.Development-driven tests: using unit tests for exploratory coding.
*******************************************************************************
Does this feel a bit like development-driven-tests?  That's OK, now 
and again.  

When you're exploring a new API, you're absolutely allowed to mess about with
it for a while before you get back to rigorous TDD.  You might use the 
interactive console, or write some exploratory code (but you have to promise
the testing goat that you'll throw it away and re-write it properly later)

Here we're actually using a unit test as a way of experimenting with the
forms API. It's actually a pretty good way of learning how it works!
*******************************************************************************


Switching to a Django ModelForm
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

What's next?  We want our form to re-use the validation code that we've already
defined on our model.  Django provides a special class which can auto-generate
a form for a model, called ModelForm.  As you'll see, it's configured using a
special attribute called `Meta`:

[role="sourcecode"]
.lists/forms.py 
[source,python]
----
from django import forms

from lists.models import Item

class ItemForm(forms.models.ModelForm):

    class Meta:
        model = Item
        fields = ('text',)
----

In `Meta` we specify which model the form is for, and which fields we want it
to use.

ModelForms do all sorts of smart stuff, like assigning sensible HTML
form input types to different types of field, and applying default 
validation.  Check out the 
https://docs.djangoproject.com/en/1.6/topics/forms/modelforms/[docs] for more
info.

We now have some different-looking form HTML:

----
AssertionError: 'placeholder="Enter a to-do item"' not found in '<p><label
for="id_text">Text:</label> <textarea cols="40" id="id_text" name="text"
rows="10">\r\n</textarea></p>'
----

It's lost our placeholder and CSS class. But you can also see that it's using
`name="text"` instead of `name="item_text"`. We can probably live with that.
But it's using a `textarea` instead of a normal input, and that's not the UI we
want for our app. Thankfully, you can override widgets for ModelForm fields,
similarly to the way we did it with the normal form:


[role="sourcecode"]
.lists/forms.py 
[source,python]
----
class ItemForm(forms.models.ModelForm):

    class Meta:
        model = Item
        fields = ('text',)
        widgets = {
            'text': forms.fields.TextInput(attrs={
                'placeholder': 'Enter a to-do item',
                'class': 'form-control input-lg',
            }),
        }
----

That gets the test passing. 

Testing and customising form validation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now let's see if the ModelForm has picked up the same validation rules which we
defined on the model.  We'll also learn how to pass data into the form, as if
it came from the user:

//TODO consider skipping this?


[role="sourcecode"]
.lists/tests/test_forms.py (ch09l046)
[source,python]
----
    def test_form_validation_for_blank_items(self):
        form = ItemForm(data={'text': ''})
        form.save()
----

That gives us:

----
ValueError: The Item could not be created because the data didn't validate.
----

Good, the form won't allow you to save if you give it an empty item text.

Now let's see if we can get it to use the specific error message that we 
want.  The API for checking form validation 'before' we try and save any
data is a function called `is_valid`:

[role="sourcecode"]
.lists/tests/test_forms.py (ch09l047)
[source,python]
----
def test_form_validation_for_blank_items(self):
    form = ItemForm(data={'text': ''})
    self.assertFalse(form.is_valid())
    self.assertEqual(
        form.errors['text'],
        ["You can't have an empty list item"]
    )
----

Calling `form.is_valid()` returns True or False, but it also has the
side-effect of validating the input data, and populating the errors
attribute.  It's a dictionary mapping the names of fields to lists of
errors for those fields (it's possible for a field to have more than 
one error)

That gives us:

----
AssertionError: ['This field is required.'] != ["You can't have an empty list
item"]
----

Django already has a default error message which we could present to the
user -- you might use it if you were in a hurry to build your web app,
but we care enough to make our message special.  Customising it does
involve hacking the form's init though:


[role="sourcecode"]
.lists/forms.py (ch10l010)
[source,python]
----
from django import forms

from lists.models import Item

class ItemForm(forms.models.ModelForm):

    class Meta:
        [...]


    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        empty_error = "You can't have an empty list item"
        self.fields['text'].error_messages['required'] = empty_error
----

NOTE: Django 1.6 has a simpler way of overriding field error messages. I
haven't had time to implement it yet, but you should feel free to look it
up and use it!
//TODO: update + remove this


You know what would be even better than messing about with all these
error strings?  Having a constant:  


[role="sourcecode"]
.lists/forms.py (ch10l011)
[source,python]
----
EMPTY_LIST_ERROR = "You can't have an empty list item"


class ItemForm(forms.models.ModelForm):

    class Meta:
        [...]


    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields['text'].error_messages['required'] = EMPTY_LIST_ERROR

    [...]
----

Re-run the tests to see they pass.... OK.  Now we change the test:

[role="sourcecode"]
.lists/tests/test_forms.py (ch09l050) 
[source,python]
----
from lists.forms import EMPTY_LIST_ERROR, ItemForm
[...]

    def test_form_validation_for_blank_items(self):
        form = ItemForm(data={'text': ''})
        self.assertFalse(form.is_valid())
        self.assertEqual(form.errors['text'], [EMPTY_LIST_ERROR])
----

And the tests still pass. Great.  Totes committable:

[subs="specialcharacters,quotes"]
----
$ *git status* # should show lists/forms.py and tests/test_forms.py
$ *git add lists*
$ *git commit -m "new form for list items"*
----


Using the form in our views
~~~~~~~~~~~~~~~~~~~~~~~~~~~

I had originally thought to extend this form to capture uniqueness validation
as well as empty-item validation.  But there's a sort of corollary to the
"deploy as early as possible" lean methodology, which is "merge code as early
as possible".  In other words: while building this bit of forms code, it would
be easy to go on for ages, adding more and more functionality to the form -- I
should know, because that's exactly what I did during the drafting of this
chapter, and I ended up doing all sorts of work making an all-singing,
all-dancing form class before I realised it wouldn't really work for our most
basic use case.

So, instead, try and use your new bit of code as soon as possible.  This makes
sure you never have unused bits of code lying around, and that you start
checking your code against "the real world" as soon as possible.

We have a form class which can render some HTML and do validation of at
least one kind of error -- let's start using it!  We should be able to use
it in our 'base.html' template, and so in all of our views.

Using the form in a view with a GET request
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Let's start in our unit tests for the home view. We'll replace the old-style
`test_home_page_returns_correct_html` with a set of tests that use the Django
Test Client.  We leave the old test in at first, to check that our new tests are
equivalent:

TODO: say we're getting rid of test_root_url_resolves_to_home_page_view too

[role="sourcecode"]
.lists/tests/test_views.py (ch10l013)
[source,python]
----
from lists.forms import ItemForm
[...]

    def test_home_page_returns_correct_html(self):
        request = HttpRequest()
        [...]


    def test_home_page_renders_home_template(self):
        response = self.client.get('/')
        self.assertTemplateUsed(response, 'home.html') #<1>


    def test_home_page_uses_item_form(self):
        response = self.client.get('/')
        self.assertIsInstance(response.context['form'], ItemForm) #<2>
----

<1> We'll use the helper method `assertTemplateUsed` to replace our old
    manual test of the template

<2> We use `assertIsInstance` to check that our view uses the right form

//TODO: mention that assertIsInstance can be dangerous.  what's the effect on maintenance? should check interface

That gives us:

----
KeyError: 'form'
----


So we use the form in our home page view:

[role="sourcecode"]
.lists/views.py (ch10l014)
[source,python]
----
[...]
from lists.forms import ItemForm
from lists.models import Item, List

def home_page(request):
    return render(request, 'home.html', {'form': ItemForm()})
----

OK, now let's try using it in the template -- we replace the old `<input ..>`
with `{{ form.text }}`:


[role="sourcecode"]
.lists/templates/base.html (ch10l015)
[source,html]
----
    <form method="POST" action="{% block form_action %}{% endblock %}">
        {{ form.text }}
        {% csrf_token %}
        {% if error %}
             <div class="form-group has-error">
----

`{{ form.text }}` renders just the HTML input for the `text` field of the form.

Now the old test is out of date:

----
    self.assertEqual(response.content.decode(), expected_html)
AssertionError: '<!DOCTYPE html>\n<html lang="en">\n    <head>\n
[...]
----

That error message is impossible to read though. Let's clarify it's message a
little:

[role="sourcecode"]
.lists/tests/test_views.py (ch09l054)
[source,python]
----
class HomePageTest(TestCase):
    maxDiff = None #<2>
    [...]
    def test_home_page_returns_correct_html(self):
        request = HttpRequest()
        response = home_page(request)
        expected_html = render_to_string('home.html')
        self.assertMultiLineEqual(response.content.decode(), expected_html) #<1>
----

<1> `assertMultiLineEqual` is useful for comparing long strings, it gives you a
diff-style output, but it truncates long diffs by default...

<2> ...so that's why we also need to set `maxDiff = None` on the test class.

Sure enough, it's because our `render_to_string` call doesn't know about the
form :

----
[...]
                          <form method="POST" action="/lists/new">
-                             <input class="form-control input-lg" id="id_text"
name="text" placeholder="Enter a to-do item" type="text" />
+
[...]
----

But we can fix that:

[role="sourcecode"]
.lists/tests/test_views.py
[source,python]
----
def test_home_page_returns_correct_html(self):
    request = HttpRequest()
    response = home_page(request)
    expected_html = render_to_string('home.html', {'form': ItemForm()})
    self.assertMultiLineEqual(response.content.decode(), expected_html)
----


And that gets us back to passing.  We've now reassured ourselves enough
that the behaviour has stayed the same, so it's now OK to delete
the old test. The `assertTemplateUsed` and `response.context` checks from
the new test are sufficient for testing a basic view with a GET request.


A big find & replace
^^^^^^^^^^^^^^^^^^^^

One thing we have done, though, is changed our form -- it no longer uses
the same `id` and `name` attributes.  You'll see if we run our functional
tests that they fail the first time they try and find the input box.


----
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"id","selector":"id_new_item"}' ; Stacktrace: 
----

We'll need to fix this, and it's going to involve a big find & replace.
Before we do that, let's do a commit, to keep the rename separate from 
the logic change.

[subs="specialcharacters,quotes"]
----
$ *git diff* # review changes in home.html, views.py and its tests
$ *git commit -am "use new form in home_page, simplify tests. NB breaks stuff"*
----

Let's fix the functional tests.  A quick grep shows us there are several
places where we're using `id_new_item`

[subs="specialcharacters,quotes"]
----
$ @grep id_new_item functional_tests/test*@
----

That's a good call for a refactor.  Let's make a new helper method
in 'base.py':

[role="sourcecode"]
.functional_tests/base.py (ch09l057)
[source,python]
----
class FunctionalTest(LiveServerTestCase):
    [...]
    def get_item_input_box(self):
        return self.browser.find_element_by_id('id_text')
----

And then we use it throughout - I had to make 3 changes in 
'test_simple_list_creation.py', 2 in 'test_layout_and_styling.py' and 4
in 'test_list_item_validation.py', eg:
//TODO - layout and styling doesnt use the id, so not greppable


[role="skipme"]
[source,python]
----
    # She is invited to enter a to-do item straight away
    inputbox = self.get_item_input_box()
----

Or

[role="skipme"]
[source,python]
----
    # an empty list item. She hits Enter on the empty input box
    self.browser.get(self.server_url)
    self.get_item_input_box().send_keys('\n')
----

I won't show you every single one, I'm sure you can manage this for 
yourself!  You can re-do the `grep` to check you've caught them all..

We're past the first step, but now we have to bring the rest of the application
code in line with the change.  We need to find any occurrences of the old id
(`id_new_item`) and name (`item_text`) and replace them too, with `id_text` and
`text`, respectively.

[role="dofirst-ch09l058"] 
[subs="specialcharacters,quotes"]
----
$ *grep -r id_new_item lists/*

lists/static/base.css:#id_new_item {
----

That's one change, and similarly for the `name`:

[role="dofirst-ch10l021"] 
[subs="specialcharacters,macros"]
----
$ pass:quotes[*grep -Ir item_text lists*]
lists/views.py:        Item.objects.create(text=request.POST['item_text'],
list=list_)
lists/views.py:            Item.objects.create(text=request.POST['item_text'],
list=list_)
lists/tests/test_views.py:            data={'item_text': 'A new list item'}
lists/tests/test_views.py:            data={'item_text': 'A new list item'}
lists/tests/test_views.py:        response = self.client.post('/lists/new',
data={'item_text': ''})
[...]
----

Once we're done, we re-run the unit tests to check everything still works:

[role="dofirst-ch10l022"] 
[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*] 
Creating test database for alias 'default'...
................
 ---------------------------------------------------------------------
Ran 16 tests in 0.126s

OK
Destroying test database for alias 'default'...
----

And the functional tests too:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests*] 
[...]
======================================================================
ERROR: test_cannot_add_empty_list_items
 ---------------------------------------------------------------------
(functional_tests.test_list_item_validation.ItemValidationTest)
  File "/workspace/superlists/functional_tests/base.py", line 30, in
get_item_input_box
    return self.browser.find_element_by_id('id_text')
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"id","selector":"id_text"}' ; Stacktrace: 
[...]
----


So close!  Let's look at where this is happening -- we check the line number
from the validation FT, and see it's happening after we've submitted a blank
list item.  We see the error text on the next page, but the form has
disappeared!

Now, looking in 'views.py', we see that we're not passing the form to the
'home.html' template inside the `new_list` view:


[role="skipme"]
[source,python]
----
except ValidationError:
    error_text = "You can't have an empty list item"
    return render(request, 'home.html', {"error": error_text})
----

This is a job our form should be doing!  Before we make any more changes
though, let's do a commit

[subs="specialcharacters,quotes"]
----
$ *git status*
$ *git commit -am"rename all item input ids and names. still broken"*
----

Using the form in a view that takes POST requests
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now we adjust the unit tests for the `new_list` view. Instead of manually
checking for a hard-coded error string, we check for the `EMPTY_LIST_ERROR`
from 'forms.py', and we can also check that a form of the right class
was passed to the template.

[role="sourcecode"]
.lists/tests/test_views.py (ch09l066)
[source,python]
----
from lists.forms import ItemForm, EMPTY_LIST_ERROR
[...]

class NewListTest(TestCase):
[...]

    def test_validation_errors_sent_back_to_home_page_template(self):
        response = self.client.post('/lists/new', data={'text': ''})
        self.assertEqual(Item.objects.all().count(), 0)
        self.assertTemplateUsed(response, 'home.html')
        self.assertContains(response, escape(EMPTY_LIST_ERROR))
        self.assertIsInstance(response.context['form'], ItemForm)
----

//TODO: split out into two tests, or make a note that it needs to be done.


Sure enough, the form isn't being passed to the template:

----
KeyError: 'form'
----

And here's how we use the form in the view:  


[role="sourcecode"]
.lists/views.py
[source,python]
----
def new_list(request):
    form = ItemForm(data=request.POST) #<1>
    if form.is_valid(): #<2>
        list_ = List.objects.create()
        Item.objects.create(text=request.POST['text'], list=list_)
        return redirect(list_)
    else:
        return render(request, 'home.html', {"form": form}) #<3>
----

<1> We pass the `request.POST` data into the form's constructor, 
<2> We use `form.is_valid()` to determine whether this is a good or a
bad submission
<3> In the bad case, we pass the form down to the template, instead of
our hard-coded error string.

Incidentally, did you notice that we've also fixed a small bug?  In the
previous code, we were saving a superfluous List object, even for invalid
inputs.  They would have been left lying around our database.  We should add an
extra assert in our unit tests once this refactor is done.

* remove duplication of validation logic in views.
* add test that we don't save superfluous lists

At this point the tests will fail, because we're not yet using the form
to display errors in the template:

[role="sourcecode"]
.lists/templates/base.html (ch10l026)
[source,html]
----
     <form method="POST" action="{% block form_action %}{% endblock %}">
        {{ form.text }}
        {% csrf_token %}
        {% if form.errors %} #<1> 
            <div class="form-group has-error">
                <div class="help-block">{{ form.text.errors }}</div> #<2>
            </div>
        {% endif %}
    </form>
----

<1> `form.errors` contains a list of all the errors for the form
<2> `form.text.errors` is a list of just the errors for the `text` field.

//TODO div vs span, either mention it or change the earlier one.

What does that do to our tests?

----
FAIL: test_validation_errors_end_up_on_lists_page
(lists.tests.test_views.ListViewTest)
[...]
AssertionError: False is not true : Couldn't find 'You can&#39;t have an empty
list item' in response
----

An unexpected failure -- it's actually in the tests for our final view,
`view_list`.  Because we've changed the way errors are displayed in 'all'
templates, we're no longer showing the error that we manually pass into the
template.

That means we're going to need to re-work `view_list` as well, before we can
get back to a working state.


Using the form in the final view
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This view handles both GET and POST requests.  Let's start with checking 
the form is used in GET requests.  Let's add a new test for that:


//ch10l023-1
[role="sourcecode"]
.lists/tests/test_views.py
[source,python]
----
class ListViewTest(TestCase):
    [...]

    def test_displays_item_form(self):
        list_ = List.objects.create()
        response = self.client.get('/lists/%d/' % (list_.id,))
        self.assertIsInstance(response.context['form'], ItemForm)
        self.assertContains(response, 'name="text"')
----

That gives:

----
KeyError: 'form'
----

Here's a minimal implementation:

[role="sourcecode"]
.lists/views.py (ch10l023)
[source,python]
----
def view_list(request, list_id):
    [...]
    form = ItemForm()
    return render(request, 'list.html', {'list': list_, "form": form, "error": error})
----


A helper method for several short tests
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Onto invalid forms.  We'll split our current single test for the
invalid case (`test_validation_errors_end_up_on_lists_page`) into several
separate ones:

[role="sourcecode"]
.lists/tests/test_views.py (ch10l024)
[source,python]
----
class ListViewTest(TestCase):
    [...]

    def post_invalid_input(self):
        list_ = List.objects.create()
        return self.client.post(
            '/lists/%d/' % (list_.id,),
            data={'text': ''}
        )

    def test_invalid_input_means_nothing_saved_to_db(self):
        self.post_invalid_input()
        self.assertEqual(Item.objects.all().count(), 0)

    def test_invalid_input_renders_list_template(self):
        response = self.post_invalid_input()
        self.assertTemplateUsed(response, 'list.html')

    def test_invalid_input_renders_form_with_errors(self):
        response = self.post_invalid_input()
        self.assertIsInstance(response.context['form'], ItemForm)
        self.assertContains(response, escape(EMPTY_LIST_ERROR))
----

Look at that -- by making a little helper function, `post_invalid_input`,
we can make three separate tests without duplicating lots of lines of code. 

It often feels more natural to write view tests as a single, monolithic
block of assertions -- the view should do this and this and this then 
return that with this.  But breaking things out into multiple tests is
definitely worthwhile; as we saw in previous chapters, it helps you isolate
the exact problem you may have, when you later come and change your code and 
accidentally introduce a bug. Helper methods are one of the tools that lower
the psychological barrier.


----
AssertionError: False is not true : Couldn't find 'You can&#39;t have an empty
list item' in response
----

Now let's see if we can properly rewrite the view to use our form.  Here's a
first cut:


//ch10l025
[role="sourcecode"]
.lists/views.py
[source,python]
----
def view_list(request, list_id):
    list_ = List.objects.get(id=list_id)
    form = ItemForm()
    if request.method == 'POST':
        form = ItemForm(data=request.POST)
        if form.is_valid():
            Item.objects.create(text=request.POST['text'], list=list_)
            return redirect(list_)
    return render(request, 'list.html', {'list': list_, "form": form})
----

That gets the unit tests passing.  

----
Ran 19 tests in 0.086s

OK
----

How about the FTs?


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests*]
Creating test database for alias 'default'...
...
 ---------------------------------------------------------------------
Ran 3 tests in 12.154s

OK
Destroying test database for alias 'default'...
----

Woohoo!  Can you feel that feeling of relief wash over you?  We've just made
a fairly major change to our small app -- that input field, its name and ID,
is absolutely critical to making everything work.  We've touched 7 or 8
different files, doing a refactor that's quite involved... This is the kind of
thing that, without tests, would seriously worry me.  In fact, I might well
have decided that it wasn't worth messing with code that works...  But, because
we have a full tests suite, we can delve around in it, tidying things up, safe
in the knowledge that the tests are there to spot any mistakes we make.  It
just makes it that much likelier that you're going to keep refactoring, keep
tidying up, keep gardening, keep tending your code, keep everything neat and
tidy and clean and smooth and precise and concise and functional.

* [strikethrough line-through]#remove duplication of validation logic in views.#
* add test that we don't save superfluous lists

Definitely time for a commit.

[subs="specialcharacters,quotes"]
----
$ *git diff* 
$ *git commit -am"use form in all views, back to working state"*
----


Before we forget, let's add our check that invalid new list forms don't create
a pointless list object:

[role="sourcecode"]
.lists/tests/test_views.py (ch09l069)
[source,python]
----
    def test_validation_errors_sent_back_to_home_page_template(self):
        response = self.client.post('/lists/new', data={'text': ''})
        self.assertEqual(List.objects.all().count(), 0)
        self.assertEqual(Item.objects.all().count(), 0)
        self.assertTemplateUsed(response, 'home.html')
        self.assertContains(response, escape(EMPTY_LIST_ERROR))
----
//TODO: did we lose an `assertIsInstance` here? these tests are a bit of a mess

That should pass. Commit, strike final item off list!

[subs="specialcharacters,quotes"]
----
$ *git commit -am"extra test for not saving List on invalid input"*
----

* [strikethrough line-through]#remove duplication of validation logic in views.#
* [strikethrough line-through]#add test that we don't save superfluous lists#




Using the form's own save method
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are a couple more things we can do to make our views even simpler.  I've
mentioned that forms are suppose to be able to save data to the database for
us.  Our case won't quite work out of the box, because the item needs to know
what list to save to, but it's not hard to fix that.

We start, as always, with a test.  Just to illustrate what the problem is,
let's see what happens if we just try to call `form.save()`:


[role="sourcecode"]
.lists/tests/test_forms.py (ch10l027)
[source,python]
----
    def test_form_save_handles_saving_to_a_list(self):
        form = ItemForm(data={'text': 'do me'})
        new_item = form.save()
----

Django isn't happy, because an item needs to belong to a list:

----
django.core.exceptions.ValidationError: {'list': ['This field cannot be
null.']}
----

Our solution is to tell the form's save method what list it should save to:

[role="sourcecode"]
.lists/tests/test_forms.py
[source,python]
----
from lists.models import Item, List
[...]

    def test_form_save_handles_saving_to_a_list(self):
        list_ = List.objects.create()
        form = ItemForm(data={'text': 'do me'})
        new_item = form.save(for_list=list_)
        self.assertEqual(new_item, Item.objects.all()[0])
        self.assertEqual(new_item.text, 'do me')
        self.assertEqual(new_item.list, list_)
----

We then make sure that the item is correctly saved to the database, with
the right attributes. 

----
TypeError: save() got an unexpected keyword argument 'for_list'
----

And here's how we can implement our custom save method:

[role="sourcecode"]
.lists/forms.py (ch10l029)
[source,python]
----
    def save(self, for_list):
        self.instance.list = for_list
        return super().save()
----

The `.instance` attribute on a form represents the database object that is
being modified or created.  And I only learned that as I was writing this
chapter!  There are other ways of getting this to work, including manually
creating the object yourself, or using the `commit=False` argument to save,
but this is by far the neatest.

----
Ran 20 tests in 0.086s

OK
----


Finally we can refactor our views. `new_list` first:


[role="sourcecode"]
.lists/views.py
[source,python]
----
def new_list(request):
    form = ItemForm(data=request.POST)
    if form.is_valid():
        list_ = List.objects.create()
        form.save(for_list=list_)
        return redirect(list_)
    else:
        return render(request, 'home.html', {"form": form})
----

Re-run the test to check everything still passes:

----
Ran 20 tests in 0.086s

OK
----

And now `view_list`:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def view_list(request, list_id):
    list_ = List.objects.get(id=list_id)
    form = ItemForm()
    if request.method == 'POST':
        form = ItemForm(data=request.POST)
        if form.is_valid():
            form.save(for_list=list_)
            return redirect(list_)
    return render(request, 'list.html', {'list': list_, "form": form})
----


Great!  Our two views are now looking very much like "normal" Django views:
they take information from a user's request, combine it with some custom logic
or information from the URL (`list_id`), pass it to a form for validation
and possible saving, and then redirect or render a template.


The request.POST or None trick
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

There's one final, optional refactor I want to show you, which I got from
my colleague Hansel Dunlop (and who in turn got it from Danny Greenfield, I
believe):

[role="sourcecode"]
.lists/views.py
[source,python]
----
def view_list(request, list_id):
    list_ = List.objects.get(id=list_id)
    form = ItemForm(data=request.POST or None)
    if form.is_valid():
        form.save(for_list=list_)
        return redirect(list_)
    return render(request, 'list.html', {'list': list_, "form": form})
----

It relies on the fact that the `or` operator, in Python, evaluates to the
second argument if the first is falsy.  Constructing a form with `data=None`
is equivalent to creating an "unbound" form, for which `is_valid()` will
always be False.  On the other hand, if there is something in the POST dict,
then we 'will' pass it to the form, and `is_valid()` will do its normal 
validation work.

A quick peek at the 
https://docs.djangoproject.com/en/1.6/ref/forms/api/#bound-and-unbound-forms[Django
docs on bound and unbound forms] may be worth it at this point.


So that trick saves us at least two lines of code and one level of indentation,
but some people might argue it's less readable.   It's up to you whether you
adopt it!

TODO: this trick is actually rather frowned on it turns out. Basically it will
go wrong in some edge cases where request.POST is the empty dict, and thus 
falsy, but it could still be valid user input. There's more info on 
http://pydanny.com/the-easy-form-views-pattern-controversy.html[Pydanny's blog].
Thanks to Mark Lavin for pointing it out to me, especially for highlighting the
fact that unticked checkboxes don't appear in POST dictionaries, but they may
well be valid inputs to a form.

So, it's probably best if you 'dont\'t' follow my advice and use this trick.
I'll probably remove this section altogether before the book is finished...


Forms and validation are really important in Django, and in web programming in
general, so let's see if we can't make a slightly more complicated one in the
next chapter.

.Tips
*******************************************************************************
Thin views::
    If you find yourself looking at complex views, and having to write a lot of
    tests for them, it's time to start thinking about whether that logic could
    be moved elsewhere: possibly to a form, like we've done here.  
    +
    Another possible place would be a custom method on the model class.  And --
    once the complexity of the app demands it -- out of Django-specific files
    and into your own classes and functions, that capture your core business
    logic.

Single assertion per test::
    One assertion per test is the ultimate goal, but it's OK if you don't start
    out that way. Helper functions can keep them from getting too bloated.
*******************************************************************************


