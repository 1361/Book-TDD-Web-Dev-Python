More advanced Forms 
-------------------

Now let's look at some more advanced forms usage.  We've helped our users
to avoid blank list items, let's help them avoid duplicate items.

NOTE: If any chapter is going to get the chop, this is a likely one. So,
please do let me know what you think:  is it valuable?  Which are your
favourite and least favourite bits?  What would you try and preserve
from it, if it were to disappear?


Another FT for duplicate items
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We add a second test method to `ItemValidationTest`:

[role="sourcecode"]
.functional_tests/tests/test_list_item_validation.py (ch11l001)
[source,python]
----
def test_cannot_add_duplicate_items(self):
    # Edith goes to the home page and starts a new list
    self.browser.get(self.server_url)
    self.get_item_input_box().send_keys('Buy wellies\n')
    self.check_for_row_in_list_table('1: Buy wellies')

    # She accidentally tries to enter a duplicate item
    self.get_item_input_box().send_keys('Buy wellies\n')

    # She sees a helpful error message
    self.check_for_row_in_list_table('1: Buy wellies')
    error = self.browser.find_element_by_css_selector('.has-error')
    self.assertEqual(error.text, "You've already got this in your list")
----

Why have two test methods rather than extending one, or having a new file
and class?  It's a judgement call.  These two feel closely related, they're
both about validation on the same input field, so it feels right to
keep them in the same file.  On the other hand, they're logically separate
enough that it's practical to keep them in different methods.


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.ItemValidationTest*] 
[...]
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"css selector","selector":".has-error"}' ; Stacktrace: 

Ran 2 tests in 9.613s
----

OK, so we know the first of the two tests passes now, is there a way to run
just the failing one, I hear you ask!  Why yes indeed:

//TODO: unskip
[role="skipme"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test \
functional_tests.ItemValidationTest.test_cannot_add_duplicate_items*] 
[...]
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"css selector","selector":".has-error"}' ; Stacktrace: 
----


Preventing duplicates at the model layer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We add another test to our model unit tests to check that duplicate items
in the same list raise an error

[role="sourcecode"]
.lists/tests/test_models.py (ch09l028)
[source,python]
----
def test_cannot_save_duplicate_items(self):
    list1 = List.objects.create()
    Item.objects.create(list=list1, text='bla')
    with self.assertRaises(ValidationError):
        Item.objects.create(list=list1, text='bla')
----

And, while it occurs to us, we add another test to make sure we don't 
overdo it on our integrity constraints:


[role="sourcecode"]
.lists/tests/test_models.py (ch09l029)
[source,python]
----
def test_CAN_save_same_item_to_different_lists(self):
    list1 = List.objects.create()
    list2 = List.objects.create()
    Item.objects.create(list=list1, text='bla')
    Item.objects.create(list=list2, text='bla') # should not raise
----

I always like to put a little comment for tests which are checking 
that a particular use case should 'not' raise an error, otherwise
it can be hard to see what's being tested.

----
AssertionError: ValidationError not raised
----

If we want to get it deliberately wrong, we can do this:


[role="sourcecode"]
.lists/models.py (ch09l030)
[source,python]
----
class Item(models.Model):
    text = models.TextField(unique=True)
    list = models.ForeignKey(List)
----

That lets us check that our second test really does pick up on this
problem:

----
Traceback (most recent call last):
  File "/workspace/superlists/lists/tests/test_models.py", line 60, in
test_CAN_save_same_item_to_different_lists
    Item.objects.create(list=list2, text='bla') # should not raise
    [...]
django.core.exceptions.ValidationError: {'text': ['Item with this Text already
exists.']}
----

.An aside on when to test for developer stupidity
*******************************************************************************
One of the judgement calls in testing is when you should write tests that sound
like "check we haven't done something stupid".  In general, you should be wary
of these.

In this case, we've written a test to check that you can't save duplicate items
to the same list.  Now, the simplest way to get that test to pass, the way in
which you'd write the least lines of code, would be to make it impossible to
save 'any' duplicate items.  That justifies writing another test, despite the
fact that it would be a "stupid" or "wrong" thing for us to code.

But you can't be writing tests for every possible way we could have coded
something wrong.  If you have a function that adds two numbers, you can write
a couple of tests:

[role="skipme"]
[source,python]
----
assert adder(1, 1) == 2
assert adder(2, 1) == 3
----

But you have the right to assume that the implementation isn't deliberately
screwey or perverse:

[role="skipme"]
[source,python]
----
def adder(a, b):
    # unlikely code!
    if a = 3:
        return 666
    else:
        return a + b
----

One way of putting it is that you should trust yourself not to do something
'deliberately' stupid, but not to do something 'accidentally' stupid.
*******************************************************************************

Just like ModelForms, models have a `class Meta`, and that's where we can
implement a constraint which says that that an item must be unique for a
particular list, or in other words, that text and list must be unique together:

[role="sourcecode"]
.lists/models.py (ch09l031)
[source,python]
----
class Item(models.Model):
    text = models.TextField()
    list = models.ForeignKey(List)

    class Meta:
        unique_together = ('list', 'text')


    def save(self, *args, **kwargs):
        [...]
----

You might want to take a quick peek at the 
https://docs.djangoproject.com/en/1.5/ref/models/options/[Django docs on model
meta attributes] at this point.


A little digression on Queryset ordering and string representations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


When we run the tests they reveal an unexpected failure:

----
======================================================================
FAIL: test_saving_and_retrieving_items
(lists.tests.test_models.ListAndItemModelsTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/workspace/superlists/lists/tests/test_models.py", line 31, in
test_saving_and_retrieving_items
    self.assertEqual(first_saved_item.text, 'The first (ever) list item')
AssertionError: 'Item the second' != 'The first (ever) list item'
- Item the second
[...]
----

That's a bit of a puzzler. A bit of print-based debugging:

[role="skipme"]
[role="sourcecode"]
.lists/tests/test_models.py
[source,python]
----
    first_saved_item = saved_items[0]
    print(first_saved_item.text)
    second_saved_item = saved_items[1]
    print(second_saved_item.text)
    self.assertEqual(first_saved_item.text, 'The first (ever) list item')
----

Will show us...

[role="skipme"]
----
.....Item the second
The first (ever) list item
F.....
----

It looks like our uniqueness constraint has messed with the default ordering
of queries like `Item.objects.all()`.  Although we already have a failing test,
it's best to add a new test that explicitly tests for ordering:


[role="sourcecode"]
.lists/tests/test_models.py (ch09l032)
[source,python]
----
    def test_list_ordering(self):
        list1 = List.objects.create()
        item1 = Item.objects.create(list=list1, text='i1')
        item2 = Item.objects.create(list=list1, text='item 2')
        item3 = Item.objects.create(list=list1, text='3')
        self.assertEqual(
            Item.objects.all(),
            [item1, item2, item3]
        )
----


That gives us a new failure, but it's not a very readable one:

----
AssertionError: [<Item: Item object>, <Item: Item object>, <Item: Item object>]
!= [<Item: Item object>, <Item: Item object>, <Item: Item object>]
----

We need a better string representation for our objects.  Let's add another
unit tests:


NOTE: Ordinarily you would be wary of adding more failing tests when you
already have some -- it makes reading test output that much more complicated,
and just generally makes you nervous. Will we ever get back to a working
state? In this case, they're all quite simple tests, so I'm not worried.

[role="sourcecode"]
.lists/tests/test_models.py (ch09l033)
[source,python]
----
def test_string_representation(self):
    list1 = List.objects.create() 
    item1 = Item.objects.create(list=list1, text='some text')
    self.assertEqual(str(item1), item1.text)
----

That gives us:

----
AssertionError: 'Item object' != 'some text'
----

As well as the other two failures.  Let's start fixing them all now:


[role="sourcecode"]
.lists/models.py (ch09l034)
[source,python]
----
class Item(models.Model):
    [...]

    def __str__(self):
        return self.text
----

NOTE: in Python 2.x versions of Django, the string representation method used
to be __unicode__. Like much string handling, this is simplified in Python 3.
See the
https://docs.djangoproject.com/en/1.5/topics/python3/#str-and-unicode-methods[docs].


Now we're down to 2 failures, and the ordering test has a more readable failure
message:

----
AssertionError: [<Item: 3>, <Item: i1>, <Item: item 2>] != [<Item: i1>, <Item:
item 2>, <Item: 3>]
----

We can fix that in the class Meta:

[role="sourcecode"]
.lists/models.py (ch09l035)
[source,python]
----
    class Meta:
        ordering = ('id',)
        unique_together = ('list', 'text')
----

Does that work?

----
AssertionError: [<Item: i1>, <Item: item 2>, <Item: 3>] != [<Item: i1>, <Item:
item 2>, <Item: 3>]
----

Urp?  It has worked, you can see the items 'are' in the same order, but the
tests are confused.  I keep running into this problem actually -- Django
querysets don't compare well with lists.  We can fix it by converting the
queryset to a list in our test:

TODO: investigate new Django test helper, "assertQuerySetEqual"?

[role="sourcecode"]
.lists/tests/test_models.py (ch09l036)
[source,python]
----
    self.assertEqual(
        list(Item.objects.all()),
        [item1, item2, item3]
    )
----

That works, we get a fully passing test suite:

----
OK
----

Time for a commit!


[subs="specialcharacters,quotes"]
----
$ *git diff*
$ *git commit -am "Implement duplicate item validation at model layer"*
----

The next task is to handle the validation error in the view. Before we do that,
a quick aside, for the curious. Do you remember I mentioned earlier that some
data integrity errors 'are' picked up on save?  Try temporarily disabling our
`.full_clean` in the model save:

[role="sourcecode"]
.lists/models.py
[source,python]
----
    def save(self, *args, **kwargs):
        #self.full_clean()
        super().save(*args, **kwargs)
----

That gives

----
ERROR: test_cannot_save_duplicate_items
(lists.tests.test_models.ListAndItemModelsTest)
    return Database.Cursor.execute(self, query, params)
django.db.utils.IntegrityError: columns list_id, text are not unique

[... and a bunch of other failures due to validation not working any more]
----

Note that it's a different error to the one we want, an `IntegrityError` 
instead of a `ValidationError`.  


Handling validation at the views layer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Let's put our `full_clean` back, and try running our FT, just to see where we
are:

[role="dofirst-ch09l035"] 
----
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"id","selector":"id_list_table"}' ; Stacktrace: 
----

In case you didn't see it as it flew past, the site is 500ing.  A
quick unit test at the view level ought to clear this up:
//TODO: remove or explain 500ing jargon?


[role="sourcecode"]
.lists/tests/test_views.py (ch11l014)
[source,python]
----
    def test_invalid_input_renders_form_with_errors(self):
        [...]


    def test_duplicate_item_validation_errors_end_up_on_lists_page(self):
        list1 = List.objects.create()
        item1 = Item.objects.create(list=list1, text='textey')
        response = self.client.post(
            '/lists/%d/' % (list1.id,),
            data={'text': 'textey'}
        )

        expected_error =  escape("You've already got this in your list")
        self.assertContains(response, expected_error)
        self.assertTemplateUsed(response, 'list.html')
        self.assertEqual(Item.objects.all().count(), 1)
----

Gives

----
django.core.exceptions.ValidationError: {'__all__': ['Item with this List and
Text already exists.']}
----

Here's one possible solution:

[role="sourcecode"]
.lists/views.py (ch11l015)
[source,python]
----
if form.is_valid():
    try:
        form.save(for_list=list_)
        return redirect(list_)
    except ValidationError:
        form.errors.update({'text': "You've already got this in your list"})
return render(request, 'list.html', {'list': list_, "form": form})
----

//TODO: use _update_errors? or don't use it later.

OK, we know that's an ugly hack, we need to get the form to do this work,
we did for new lists, but -- it will probably work. 

----
Ran 25 tests in 0.104s

OK
----

----
Ran 4 tests in 19.048s

OK
----

What matters is that it gets us to 'Green'. We'll definitely do the 'Refactor'
part very soon. First, a commit.

[subs="specialcharacters,quotes"]
----
$ *git diff*
$ *git commit -am"duplicate item validation hacked in at views level"*
----


A more complex form to handle uniqueness validation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The form to create a new list only needs to know one thing, the new item text.
A form which validates that list items are unique needs to know both.  Just
like we overrode the save method on our ItemForm, this time we'll override
the constructor on our new form class so that it knows what list it applies to.

We duplicate up our tests for the previous form, tweaking them slightly:

[role="sourcecode"]
[source,python]
.lists/tests/test_forms.py (ch09l070)
----
from lists.forms import (
    DUPLICATE_ITEM_ERROR, EMPTY_LIST_ERROR,
    ExistingListItemForm, ItemForm
)
[...]

class ExistingListItemFormTest(TestCase):

    def test_form_renders_item_text_input(self):
        listey = List.objects.create()
        form = ExistingListItemForm(for_list=listey)
        self.assertIn('placeholder="Enter a to-do item"', form.as_p())


    def test_form_validation_for_blank_items(self):
        listey = List.objects.create()
        form = ExistingListItemForm(for_list=listey, data={'text': ''})
        self.assertFalse(form.is_valid())
        self.assertEqual(form.errors['text'], [EMPTY_LIST_ERROR])


    def test_form_validation_for_duplicate_items(self):
        listey = List.objects.create()
        Item.objects.create(list=listey, text='no twins!')
        form = ExistingListItemForm(for_list=listey, data={'text': 'no twins!'})
        self.assertFalse(form.is_valid())
        self.assertEqual(form.errors['text'], [DUPLICATE_ITEM_ERROR])
----
//TODO: get rid of "listey" variable name, for consistency

We can iterate through a few TDD cycles (I won't show them all, but I'm sure
you'll do them, right? Remember, the Goat sees all) until we get a form with a
custom constructor, which just ignores its for_list argument:

[role="sourcecode"]
.lists/forms.py (ch09l071)
[source,python]
----
DUPLICATE_ITEM_ERROR = "You've already got this in your list"
[...]
class ExistingListItemForm(forms.models.ModelForm):
    def __init__(self, for_list, *args, **kwargs):
        super().__init__(*args, **kwargs)
----

Gives

----
ValueError: ModelForm has no model class specified.
----

Now let's see if making it inherit from our existing form helps:

[role="sourcecode"]
.lists/forms.py (ch09l072)
[source,python]
----
class ExistingListItemForm(ItemForm):
    def __init__(self, for_list, *args, **kwargs):
        super().__init__(*args, **kwargs)
----

That takes us down to just one failure:

----
FAIL: test_form_validation_for_duplicate_items
(lists.tests.test_forms.ExistingListItemFormTest)
    self.assertFalse(form.is_valid())
AssertionError: True is not false
----

The next step requires a little knowledge of Django's internals, but you
can read up on it in the Django docs on 
https://docs.djangoproject.com/en/1.5/ref/models/instances/#validating-objects[Model
validation] and
https://docs.djangoproject.com/en/1.5/ref/forms/validation/[Form validation].

Django uses a method called `validate_unique`, both on forms and models, and
we can use both, in conjunction with the `instance` attribute:

[role="sourcecode"]
.lists/forms.py
[source,python]
----
from django.core.exceptions import ValidationError
[...]

class ExistingListItemForm(ItemForm):

    def __init__(self, for_list, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.instance.list = for_list


    def validate_unique(self):
        try:
            self.instance.validate_unique()
        except ValidationError:
            self._update_errors({'text': [DUPLICATE_ITEM_ERROR]})
----


And we're there!  A quick commit

[subs="specialcharacters,quotes"]
----
$ *git diff*
$ *git commit -a*
----


Using the existing lists item form in the list view
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now let's see if we can put this form to work in our view.

Let's start by using our constant, now that we've defined it. Tidy tidy!

[role="sourcecode"]
.lists/tests/test_views.py (ch11l049)
[source,python]
----
from lists.forms import (
    DUPLICATE_ITEM_ERROR, EMPTY_LIST_ERROR,
    ExistingListItemForm, ItemForm,
)
[...]

    def test_duplicate_item_validation_errors_end_up_on_lists_page(self):
        [...]
        expected_error =  escape(DUPLICATE_ITEM_ERROR)
----

----
Ran 28 tests in 0.130s

OK
----

Next -- let's find places where we should be using our new form
class. There's two checks in our view tests that we use the right
form, let's change them both:

[role="sourcecode"]
.lists/tests/test_views.py
[source,python]
----
def test_displays_item_form(self):
    list_ = List.objects.create()
    response = self.client.get('/lists/%d/' % (list_.id,))
    self.assertIsInstance(response.context['form'], ExistingListItemForm)


def test_invalid_input_renders_form_with_errors(self):
    response = self.post_invalid_input()
    self.assertIsInstance(response.context['form'], ExistingListItemForm)
----

That gives us:

//TODO: unskip
[role="skipme"]
----
AssertionError: <lists.forms.ItemForm object at 0x7f767e4b7f90> is not an
instance of <class 'lists.forms.ExistingListItemForm'>
----

So we can adjust the view:

[role="sourcecode"]
.lists/views.py (ch11l051)
[source,python]
----
from lists.forms import ExistingListItemForm, ItemForm
[...]
def view_list(request, list_id):
    list_ = List.objects.get(id=list_id)
    form = ExistingListItemForm(for_list=list_, data=request.POST or None)
    if form.is_valid():
        form.save()
        return redirect(list_)
    return render(request, 'list.html', {'list': list_, "form": form})
----

And, oops, an unexpected fail:

----
TypeError: save() missing 1 required positional argument: 'for_list'
----

Our custom save method from the parent `ItemForm` is no longer needed. 
Let's make a quick unit test for that:


[role="sourcecode"]
.lists/tests/test_forms.py (ch11l053)
[source,python]
----
def test_form_save(self):
    listey = List.objects.create()
    form = ExistingListItemForm(for_list=listey, data={'text': 'hi'})
    new_item = form.save()
    self.assertEqual(new_item, Item.objects.all()[0])
----

We can make our form call the grandparent save method:

[role="sourcecode"]
.lists/forms.py (ch11l054)
[source,python]
----
    def save(self):
        return super(forms.models.ModelForm, self).save()
----


And we're there!  Unit tests pass!

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
[...]
Ran 29 tests in 0.082s

OK
----

And so does our FT for validation:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.ItemValidationTest*]
Creating test database for alias 'default'...
..
 ---------------------------------------------------------------------
Ran 2 tests in 12.048s

OK
Destroying test database for alias 'default'...
----

As a final check, we re-run 'all' the FTs:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests*]
Creating test database for alias 'default'...
....
 ---------------------------------------------------------------------
Ran 4 tests in 19.048s

OK
Destroying test database for alias 'default'...
----

Hooray! Time for a final commit, and a wrap-up of what we've learned about
testing views over the last few chapters:


.Recap: what to test in views
*******************************************************************************

[role="skipme"
[source,python]
.Partial listing show all view test + assertions
----
class ListViewTest(TestCase):
    def test_uses_list_template(self):
        response = self.client.get('/lists/%d/' % (list_.id,)) #<1>
        self.assertTemplateUsed(response, 'list.html') #<2>
    def test_passes_correct_list_to_template(self):
        self.assertEqual(response.context['list'], correct_list) #<3>
    def test_displays_item_form(self):
        self.assertIsInstance(response.context['form'], ExistingListItemForm) #<4>
        self.assertContains(response, 'name="text"') #<7>
    def test_displays_only_items_for_that_list(self):
        self.assertContains(response, 'itemey 1') #<5>
        self.assertContains(response, 'itemey 2') #<5>
        self.assertNotContains(response, 'other list item 1') #<5>
    def test_can_save_a_POST_request_to_an_existing_list(self):
        self.assertEqual(Item.objects.all().count(), 1) #<6>
        self.assertEqual(new_item.text, 'A new item for an existing list') #<6>
    def test_POST_redirects_to_list_view(self):
        self.assertRedirects(response, '/lists/%d/' % (correct_list.id,)) #<6>
    def test_invalid_input_means_nothing_saved_to_db(self):
        self.assertEqual(Item.objects.all().count(), 0) #<6>
    def test_invalid_input_renders_list_template(self):
        self.assertTemplateUsed(response, 'list.html') #<6>
    def test_invalid_input_renders_form_with_errors(self):
        self.assertIsInstance(response.context['form'], ExistingListItemForm) #<7>
        self.assertContains(response, escape(EMPTY_LIST_ERROR)) #<7>
----

<1> Use the Django Test Client

<2> Check the template used.  Then, check each item in the template context:

<3> Check any objects are the right ones, or Querysets have the
    correct items.

<4> Check any forms are of the correct class

<5> Test any template logic:  any `for` or `if` should get a minimal test

<6> For views that handle POST requests, make sure you test both the valid
    case and the invalid case.

<7> Sanity-check that your form is rendered, and its errors are displayed

Why these points?  Skip ahead to <<appendix2,Appendix II>>, and I'll show how
they are sufficient to ensure that our views are still correct if we refactor
them to start using Class-Based Views.

*******************************************************************************

