[[chapter_philosophy_and_refactoring]]
What Are We Doing with All These Tests? (And, Refactoring)
----------------------------------------------------------

[[figure4-1]]
.Test ALL the things (original illustration source: http://bit.ly/1iXxdYp[Allie Brosh, Hyperbole and a Half])
image::images/twp2_0401.png["Test ALL the things",float="right"]

Topics to discuss:

* "Bucket from a well" metaphor
* TDD as a discipline -- kata
* the value of ridiculously small/simple tests?


Using Selenium to Test User Interactions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

((("Selenium", "testing user interactions with", id="Suser04")))((("user interactions", "testing with Selenium", id="UIselenium04")))Where
were we at the end of the last chapter? Let's rerun the test and find
out:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python functional_tests.py*]
F
======================================================================
FAIL: test_can_start_a_list_and_retrieve_it_later (__main__.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "functional_tests.py", line 19, in
test_can_start_a_list_and_retrieve_it_later
    self.fail('Finish the test!')
AssertionError: Finish the test!

 ---------------------------------------------------------------------
Ran 1 test in 1.609s

FAILED (failures=1)
----


Did you try it, and get an error saying 'Problem loading page' or
'Unable to connect'?  So did I. It's because we forgot to spin up the dev
server first using `manage.py runserver`.  Do that, and you'll get the failure
message we're after.

``Finish the test'', it says, so let's do just that!  Open up
'functional_tests.py' and we'll extend our FT:


[role="sourcecode"]
.functional_tests.py
====
[source,python]
----
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
import time
import unittest

class NewVisitorTest(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()

    def tearDown(self):
        self.browser.quit()

    def test_can_start_a_list_and_retrieve_it_later(self):
        # Edith has heard about a cool new online to-do app. She goes
        # to check out its homepage
        self.browser.get('http://localhost:8000')

        # She notices the page title and header mention to-do lists
        self.assertIn('To-Do', self.browser.title)
        header_text = self.browser.find_element_by_tag_name('h1').text  #<1>
        self.assertIn('To-Do', header_text)

        # She is invited to enter a to-do item straight away
        inputbox = self.browser.find_element_by_id('id_new_item')  #<1>
        self.assertEqual(
            inputbox.get_attribute('placeholder'),
            'Enter a to-do item'
        )

        # She types "Buy peacock feathers" into a text box (Edith's hobby
        # is tying fly-fishing lures)
        inputbox.send_keys('Buy peacock feathers')  #<2>

        # When she hits enter, the page updates, and now the page lists
        # "1: Buy peacock feathers" as an item in a to-do list table
        inputbox.send_keys(Keys.ENTER)  #<3>
        time.sleep(1)  #<4>

        table = self.browser.find_element_by_id('id_list_table')
        rows = table.find_elements_by_tag_name('tr')  #<1>
        self.assertTrue(
            any(row.text == '1: Buy peacock feathers' for row in rows)
        )

        # There is still a text box inviting her to add another item. She
        # enters "Use peacock feathers to make a fly" (Edith is very
        # methodical)
        self.fail('Finish the test!')

        # The page updates again, and now shows both items on her list
        [...]
----
====

Ask about:
* `find_element_by_tag_name`, `find_element_by_id`, 
* `find_element`**`s`**`_by_tag_name` (notice the extra `s`)
* `send_keys`,
* `Keys` class 
* `any` function + generator expressions

Also, just look at that `any` function. It's a little-known Python built-in.
I don't even need to explain it, do I? Python is such a joy.



((("generator expressions")))((("list comprehensions")))Although, if you're one of my readers who doesn't know Python, what's happening
inside the `any` is a 'generator expression', which is like a 'list
comprehension' but awesomer. You need to read up on this. If you Google it,
you'll find http://bit.ly/1iXxD18[Guido himself explaining it nicely].
Come back and tell me that's not pure joy!


Let's see how it gets on:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python functional_tests.py*]
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: h1
----

Big changes to a functional test are usually a good thing to commit on their
own 

[subs="specialcharacters,quotes"]
----
$ *git diff*  # should show changes to functional_tests.py
$ *git commit -am "Functional test now checks we can input a to-do item"*
----




The ``Don't Test Constants'' Rule, and Templates to the Rescue
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In other words, if you have some code that says:


[source,python]
----
wibble = 3
----

There's not much point in a test that says:

[source,python]
----
from myprogram import wibble
assert wibble == 3
----


Refactoring to Use a Template
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Objective: **refactor** view to return same HTML

Start with test run:

[subs="specialcharacters,quotes"]
----
$ *python manage.py test*
[...]
OK
----

Great! We'll start by taking our HTML string and putting it into its own file.
Create a directory called 'lists/templates' to keep templates in, and then open
a file at 'lists/templates/home.html', to which we'll transfer our 
HTML:footnote:[Some people like to use another subfolder named after the app
(i.e., 'lists/templates/lists') and then refer to the template as
'lists/home.html'.  This is called "template namespacing". I figured it was
overcomplicated for this small project, but it may be worth it on larger
projects.  There's more in the
https://docs.djangoproject.com/en/1.11/intro/tutorial03/#write-views-that-actually-do-something[Django tutorial].]


[role="sourcecode"]
.lists/templates/home.html
====
[source,html]
----
<html>
    <title>To-Do lists</title>
</html>
----
====


Mmmh, syntax-highlighted...much nicer! Now to change our view function:


[role="sourcecode"]
.lists/views.py
====
[source,python]
----
from django.shortcuts import render

def home_page(request):
    return render(request, 'home.html')
----
====

Let's see if it works:

[subs="specialcharacters,macros,callouts"]
----
$ pass:quotes[*python manage.py test*]
[...]
======================================================================
ERROR: test_home_page_returns_correct_html (lists.tests.HomePageTest)<2>
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "...python-tdd-book/lists/tests.py", line 17, in
test_home_page_returns_correct_html
    response = home_page(request)<3>
  File "...python-tdd-book/lists/views.py", line 5, in home_page
    return render(request, 'home.html')<4>
  File "/usr/local/lib/python3.6/dist-packages/django/shortcuts.py", line 48,
in render
    return HttpResponse(loader.render_to_string(*args, **kwargs),
  File "/usr/local/lib/python3.6/dist-packages/django/template/loader.py", line
170, in render_to_string
    t = get_template(template_name, dirs)
  File "/usr/local/lib/python3.6/dist-packages/django/template/loader.py", line
144, in get_template
    template, origin = find_template(template_name, dirs)
  File "/usr/local/lib/python3.6/dist-packages/django/template/loader.py", line
136, in find_template
    raise TemplateDoesNotExist(name)
django.template.base.TemplateDoesNotExist: home.html<1>

 ---------------------------------------------------------------------
Ran 2 tests in 0.004s
----

Another chance to analyse a traceback:

<1> We start with the error: it can't find the template.

<2> Then we double-check what test is failing: sure enough, it's our test
    of the view HTML.

<3> Then we find the line in our tests that caused the failure: it's when
    we call the `home_page` function.

<4> Finally, we look for the part of our own application code that caused the
    failure: it's when we try to call `render`.


So why can't Django find the template?  It's right where it's supposed to be,
in the 'lists/templates' folder.


* Need to add lists app to 'settings.py':


[role="sourcecode"]
.superlists/settings.py
====
[source,python]
----
# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'lists',
]
----
====

//TODO: the new way of adding it would be lists.apps.ListConfig


Does that do the trick?


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test*]
    [...]
    self.assertTrue(html.endswith('</html>'))
AssertionError: False is not true
----

Darn, not quite.

NOTE: Depending on whether your text editor insists on adding newlines to the
      end of files, you may not even see this error.  If so, you can safely
      ignore the next bit, and skip straight to where you can see the listing
      says OK.



[role="sourcecode"]
.lists/tests.py
====
[source,python]
----
self.assertTrue(html.strip().endswith('</html>'))
----
====

hooray!

[subs="specialcharacters,quotes"]
----
$ *python manage.py test*
[...]
OK
----

Now we can change the tests so that they're no longer testing constants

The Django Test Client
^^^^^^^^^^^^^^^^^^^^^^

((("Django framework", "Test Client", id="DJFtestclient04")))((("Test Client (Django)", id="testclient04")))One
way we could test this is to manually render the template ourselves:

[role="sourcecode skipme"]
.lists/tests.py
====
[source,python]
----
from django.template.loader import render_to_string
[...]

    def test_home_page_returns_correct_html(self):
        request = HttpRequest()
        response = home_page(request)
        html = response.content.decode('utf8')
        expected_html = render_to_string('home.html')
        self.assertEqual(html, expected_html)
----
====


But that's a bit of an unwieldy way of testing that we use the right template.
And all this faffing about with `.decode()` and `.strip()` is distracting.
Instead, Django gives us a tool called the
https://docs.djangoproject.com/en/1.11/topics/testing/tools/#the-test-client[Django
Test Client], which has built-in ways of checking what templates are used.
Here's how it looks:


[role="sourcecode"]
.lists/tests.py
====
[source,python]
----
    def test_home_page_returns_correct_html(self):
        response = self.client.get('/')  #<1>

        html = response.content.decode('utf8')  #<2>
        self.assertTrue(html.startswith('<html>'))
        self.assertIn('<title>To-Do lists</title>', html)
        self.assertTrue(html.strip().endswith('</html>'))

        self.assertTemplateUsed(response, 'home.html')  #<3>
----
====

(as usual, ask for explanations of lines with numbers if needed)

And that test will still pass:

----
Ran 2 tests in 0.016s

OK
----

Just because I'm always suspicious of a test I haven't seen fail, let's
deliberately break it:

[role="sourcecode"]
.lists/tests.py
====
[source,python]
----
        self.assertTemplateUsed(response, 'wrong.html')
----
====

That way we'll also learn what its error messages look like:

----
AssertionError: False is not true : Template 'wrong.html' was not a template
used to render the response. Actual template(s) used: home.html
----

That's very helpful!  Let's change the assert back to the right thing.  While
we're at it, we can delete our old assertions.  And we can also delete the
old +test_root_&#x200b;url_resolves+ test, because that's tested implicitly by the
Django Test Client.  We've combined two long-winded tests into one!

[role="sourcecode"]
.lists/tests.py (ch04l010)
====
[source,python]
----
from django.test import TestCase

class HomePageTest(TestCase):

    def test_uses_home_template(self):
        response = self.client.get('/')
        self.assertTemplateUsed(response, 'home.html')
----
====


The main point, though, is that instead of testing constants we're testing our
implementation.

NOTE: ask: why not always just use the Django Test client?


.Advanced Exercise:
********************************************************************

TODO

********************************************************************


On Refactoring
~~~~~~~~~~~~~~

((("unit tests", "refactoring in")))((("refactoring")))That
was an absolutely trivial example of refactoring. But, as Kent Beck puts
it in <<tddbe,'Test-Driven Development: By Example'>>, "Am I recommending that
you actually work this way? No. I'm recommending that you be 'able' to work
this way".

TIP: When refactoring, work on either the code or the tests, but not both at
     once.


[[RefactoringCat]]
.Refactoring Cat--be sure to look up the full animated GIF (source: 4GIFs.com)
image::images/twp2_0402.png["An adventurous cat, trying to refactor its way out of a slippery bathtub"]


It's a good idea to do a commit after any refactoring:

[subs="specialcharacters,quotes"]
----
$ *git status* # see tests.py, views.py, settings.py, + new templates folder
$ *git add .*  # will also add the untracked templates folder
$ *git diff --staged* # review the changes we're about to commit
$ *git commit -m "Refactor home page view to use a template"*
----



A Little More of Our Front Page
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the meantime, our functional test is still failing.  Let's now make an
actual code change to get it passing.  

[role="sourcecode"]
.lists/templates/home.html
====
[source,html]
----
<html>
    <head>
        <title>To-Do lists</title>
    </head>
    <body>
        <h1>Your To-Do list</h1>
    </body>
</html>
----
====

Let's see if our functional test likes it a little better:

----
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: [id="id_new_item"]
----

OK...


[role="sourcecode"]
.lists/templates/home.html
====
[source,html]
----
    [...]
        <h1>Your To-Do list</h1>
        <input id="id_new_item" />
    </body>
    [...]
----
====

And now?

----
AssertionError: '' != 'Enter a to-do item'
----

We add our placeholder text...

[role="sourcecode"]
.lists/templates/home.html
====
[source,html]
----
    <input id="id_new_item" placeholder="Enter a to-do item" />
----
====

Which gives:

----
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: [id="id_list_table"]
----

So we can go ahead and put the table onto the page. At this stage it'll just be
empty...

[role="sourcecode"]
.lists/templates/home.html
====
[source,html]
----
    <input id="id_new_item" placeholder="Enter a to-do item" />
    <table id="id_list_table">
    </table>
</body>
----
====

Now what does the FT say?

----
  File "functional_tests.py", line 43, in
test_can_start_a_list_and_retrieve_it_later
    any(row.text == '1: Buy peacock feathers' for row in rows)
AssertionError: False is not true
----

That `any` function!


[role="sourcecode"]
.functional_tests.py
====
[source,python]
----
    self.assertTrue(
        any(row.text == '1: Buy peacock feathers' for row in rows),
        "New to-do item did not appear in table"
    )
----
====

If you run the FT again, you should see our message:

----
AssertionError: False is not true : New to-do item did not appear in table
----

But now, to get this to pass, we will need to actually process the user's
form submission.  And that's a topic for the next chapter.

For now let's do a commit:

[subs="specialcharacters,quotes"]
----
$ *git diff*
$ *git commit -am "Front page HTML now generated from a template"*
----


Thanks to a bit of refactoring, we've got our view set up to render a template,
we've stopped testing constants, and we're now well placed to start processing
user input.

.Advanced Exercise:
********************************************************************

How could we improve that check-that-the-new-item-has-appeared-in-the-table
assertion further?   

********************************************************************


Recap: The TDD Process
~~~~~~~~~~~~~~~~~~~~~~


((("Test-Driven Development (TDD)", "overall process of", id="TDDprocess04")))We've
now seen all the main aspects of the TDD process, in practice:

* Functional tests
* Unit tests
* The unit-test/code cycle
* Refactoring

What is the overall TDD process? See <<simple-TDD-diagram>>.


[[simple-TDD-diagram]]
.Overall TDD process
image::images/twp2_0403.png["A flowchart showing tests, coding and refactoring"]

But how does this apply when we have functional tests 'and' unit tests?  Well,
you can think of the functional test as being a high-level view of the cycle,
where "writing the code" to get the functional tests to pass actually involves
using another, smaller TDD cycle which uses unit tests. See
<<Double-Loop-TDD-diagram>>.

This way of looking at things is sometimes called "Double-Loop TDD". One of my
eminent tech reviewers, Emily Bache, wrote http://bit.ly/1iXzoLR[a blog post]
on the topic, which I recommend for a different perspective.

[[Double-Loop-TDD-diagram]]
.The TDD process with functional and unit tests
image::images/twp2_0404.png["A flowchart showing functional tests as the overall cycle, and unit tests helping to code"]


We'll explore all of the different parts of this workflow in more detail
over the coming chapters.((("", startref="TDDprocess04")))


