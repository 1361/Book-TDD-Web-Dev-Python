Chapter 1 - Getting Django set up using a Functional Test
---------------------------------------------------------

In my first draft of this book, I started off with a "toy" example, designed to
introduce the concepts of TDD before we dive into the complexities of web 
development (you can still look it up if you like, it's on my github page).

In the end though, I decided that you guys would prefer to dive right in.
You're here to learn about web programming, not Roman Numeral calculators
(even if the latter can be surprisingly interesting).

So without further ado, let's get started.

Obey the testing goat: Do nothing until you have a test
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

''Obey the testing goat'' was a short-lived meme from PyCon 2010, which I
intend to single-handedly resuscitate. Now, normally first step in web
development is getting your web framework installed and configured. Download
this, install that, configure the other, run the widget...  But TDD
requires a different mindset.  When you're doing TDD, you always have the
Testing Goat inside you -- single-minded as goats are -- bleating ''Test-first,
Test-first!''

In TDD the first step is always the same: *write a test*.  

'First' we write the test, 'then' we run it and check that it fails as
expected.  'Only then' do we go ahead and build some of our app.  Repeat that 
to yourself in a goat-like voice.

Another thing about goats is that they take one step at a time.  That's why
they seldom fall off mountains see, no matter how steep they are. So, we'll
proceed with nice small steps; the first thing we want to do is check that
we've installed Django successfully, and that it works -- the absolute minimum,
and the way we'll check is by confirming that we can spin up Django's
development server and actually see it running, in a normal web browser, on our
local PC.

[[first-FT]]
We'll use the Selenium browser automation tool for this. Create a new Python
file called `tests.py`, and enter the following code.  If you feel like making
a few little goat noises as you do it, it may help.

[source,python]
----
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://localhost:8000')
assert 'Django' in browser.title
----

That's our first functional test; I'll talk more about what I mean by
functional test, and how it contrasts to unit tests.  For now, it's enough to
assure ourselves that we understand what it's doing: 
- opening up a Selenium "webdriver" for the Firefox browser
- using it to open up a web page which we're expecting the local PC to be
  hosting
- checking (making a test assertion) that that page has the word "Django" in
  its title

That's pretty much as simple as it could get. Let's try running it:

If you haven't already, you'll need to install Selenium. `pip install selenium`
is probably the command you need to run. 

NOTE: If you don't know what `pip` is, 
http://www.pip-installer.org/en/latest/[you should find out!]


....
$ python tests.py 
Traceback (most recent call last):
  File "tests.py", line 4, in <module>
    assert 'Django' in browser.title
AssertionError
....

You should see a browser window pop up, try and open up `localhost:80001`, and
then the Python error.  Actually, it's a little untidy because it leaves that
window lying around on your desktop.  We'll fix that later.

For now though, we have a failing test, so that means we're allowed to start 
building our app.


Getting Django up and running
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

First step is getting Django installed -- do a `pip install django`, and if you
run into any problems, refer to the Django documentation.

NOTE: This book was written using Django 1.4. From what I could tell,
everything should still work in Django 1.5. Back in Django 1.3, however,
things like the default folder structure are quite different, so you'll
probably find it quite confusing to try and follow along with 1.3. Upgrade!

Once Django is installed, we can create a *project* to be the main container
for our site.  Django provides a little command-line tool for this:

....
django-admin.py startproject awesomelists
....

That will create a folder called `awesomelists`, and a set of files and subfolders
inside it:

....
$ tree awesomelists/
awesomelists/
├── manage.py
└── awesomelists
    ├── __init__.py
    ├── settings.py
    ├── urls.py
    └── wsgi.py
....

Yes, there's a folder called `awesomelists` inside a folder called `awesomelists`.  It's a
bit confusing, but it's just one of those slightly strange things -- there are
good reasons when you look back at the history of Django.  For now, you can 
just take it as read that the `awesomelists/awesomelists` folder is for stuff that applies
to the whole project -- including `settings.py`, which is used for the global
configuration of the site.

You'll also have noticed `manage.py`.  That's Django's Swiss army knife, and
one of the things it can do is run a development server.  Let's try that now:

....
$ python manage.py runserver
Validating models...

0 errors found
Django version 1.4.2, using settings 'awesomelists.settings'
Development server is running at http://127.0.0.1:8000/
Quit the server with CONTROL-C.

....

Leave that running, and open another command shell.  In that, we can try
running our tests again:

....
$ python tests.py 
$
....

Not much action on the command-line, but you should notice two things: Firstly,
there was no ugly "AssertionError", and secondly, the Firefox window that
Selenium popped up (briefly) had a different-looking page on it.


Well, it may not look like much, but that was our first ever passing test!
Hooray!

If it all feels a bit too much like magic, like it wasn't quite real, why not
go and take a look at what the dev server is showing manually, by opening a
web browser yourself and visiting `http://localhost:8000'.  You should see
something like this:

image:it_worked.png[Screenshot of Django "It Worked" screen]

You can quit the development server now if you like, back in the original
shell, using Ctrl+C.

There's one last thing to do before we finish the chapter - start to commit our
work to a VCS.  If you're an experienced programmer, you don't need to hear me 
preaching about version control, but if you're new to it, please believe me
when I say that VCS is a must-have.  As soon as your project gets to be more
than a few weeks old and a few lines of code, having a VCS available to look
back over old versions of code, revert changes, explore new ideas safely, even
just as a backup tool... Boy. TDD goes hand in hand with version control, and I
want to make sure I impart how it fits into the workflow.

So, our first commit! If anything it's a bit late!  I'm going to use `git`,
'cos it's the best.  If you don't have git installed, go ahead and download it
now. 

NOTE: install git on a mac - it just so happens I was on a mac today -- I had
to do a `sudo ln -s /usr/local/git/bin/git /usr/local/bin/git` before I
actually had a workable command-line git. I'm not sure if that's a common 
problem...

Let's start by moving `tests.py` into the `awesomelists` folder, and doing the 
`git init` to start the repository:

....
$ ls
awesomelists          tests.py
$ mv tests.py awesomelists/
$ cd awesomelists/
$ git init .
Initialized empty Git repository in /chapter_1/awesomelists/.git/
....

Now let's add the files we want to commit -- which is everything really!

....
$ ls
manage.py       awesomelists          tests.py
$ git add *
$ git status
# On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use "git rm --cached <file>..." to unstage)
#
#       new file:   manage.py
#       new file:   awesomelists/__init__.py
#       new file:   awesomelists/__init__.pyc
#       new file:   awesomelists/settings.py
#       new file:   awesomelists/settings.pyc
#       new file:   awesomelists/urls.py
#       new file:   awesomelists/urls.pyc
#       new file:   awesomelists/wsgi.py
#       new file:   awesomelists/wsgi.pyc
#       new file:   tests.py
#
....

Darn!  We've got a bunch of `.pyc` files in there, it's pointless to commit
those.  Let's remove them and add them to `.gitignore` (a special file that
tells git, um, what it should ignore)

....
$ git rm --cached awesomelists/*.pyc
rm 'awesomelists/__init__.pyc'
rm 'awesomelists/settings.pyc'
rm 'awesomelists/urls.pyc'
rm 'awesomelists/wsgi.pyc'

$ echo "*.pyc" > .gitignore
....

Now let's see where we are... You'll see I'm using `git status` a lot -- so
much so that I often alias it to `git st`, but I'll leave it for you to
discover the secrets of git aliases on your own.

....
$ git status
# On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use "git rm --cached <file>..." to unstage)
#
#       new file:   manage.py
#       new file:   awesomelists/__init__.py
#       new file:   awesomelists/settings.py
#       new file:   awesomelists/urls.py
#       new file:   awesomelists/wsgi.py
#       new file:   tests.py
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#       .gitignore
....

OK, we'll just add `.gitignore`, and then we're ready to do our first commit!


....
$ git add .gitignore
$ git commit
....

when you type "git commit", it will pop up an editor window for you to write
your commit message in.  Here's what mine looked like:

image:first_commit.png[Screenshot of git commit vi window]

(I hasten to add that I don't usually use a Mac -- I just happened to be 
borrowing my wife's today!)

(I do usually use vim with some hideous colour scheme though)

NOTE: Did vi just pop up for you and you had no idea what to do with it? I'll
resist the temptation to teach vi commands as part of this tutorial as well.  
Quit vi using `:q`, then change your git default editor using 
`git config --global core.editor your_editor_here`. `open` works on a mac, so
does `nano`.  In fact, this might be a good time to take a look at some 
http://git-scm.com/book/en/Customizing-Git-Git-Configuration[basic git configuration]

TODO: find out what to use on PC

OK that's it for the VCS lecture. So, congratulations!  You've written a
functional test using Selenium, and you've got Django installed and running, in
a certifiable, test-first, goat-approved TDD way.  Give yourself a
well-deserved pat on the back before moving onto Chapter 2.


