Finishing "my lists": Outside-In TDD
------------------------------------

In this chapter I'd like to talk about a technique called "outside-in" TDD.
It's pretty much what we've been doing all along. Our "double-loop" TDD
process, in which we write the functional test first and then the unit tests,
is already a manifestation of outside-in - we design the system from the
outside, and build up our code in layers. Now I'll make it explicit, and talk
about some of the common issues involved. //I thought we were going to work on saving the lists?


The alternative - "Inside out"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The alternative to "Outside In" is to work "Inside Out", which is the way most
people intuitively work before they encounter TDD. After
coming up with a design, the natural inclination is sometimes to implement it
starting with the innermost, lowest-level components first.

For example, when faced with our current problem, providing users with a
"My Lists" page of saved lists, the temptation is to start by adding an "owner"
attribute to the List model object, reasoning that an attribute like this is
"obviously" going to be required. Once that's in place, we would modify the
more peripheral layers of code, such as views and templates, taking advantage
of the new attribute, and then finally add URL routing to point to the new
view.

It feels comfortable because it means you're never working on a bit of code
which is dependent on something which haven't yet been implemented. Each bit of
work on the inside is a solid foundation on which to build the next layer out.

But working inside-out like this also has some weaknesses.

Why prefer "outside-in"?
~~~~~~~~~~~~~~~~~~~~~~~~

The most obvious problem with inside-out is that it requires us to stray from a
TDD workflow. Our functional test's first failure might be due to missing URL
routing, but we decide to ignore that and go off adding attributes to our
database model objects instead.

We might have ideas in our head about the new desired behaviour of our inner
layers like database models, and often these ideas will be pretty good, but
they are actually just speculation about what's really required, because
we haven't yet built the outer layers that will use them.

One problem that can result is to build inner components that are more
general or more capable than we actually need, which is a waste of time,
and an added source of complexity for your project. Another common problem
is that you create inner components with an API which is convenient for their
own internal design, but which later turns out to be inappropriate for the
calls your outer layers would like to make... Worse still, you might end up
with inner components which, you later realise, don't actually solve the
problem that your outer layers need solved.

In contrast, working outside-in in allows you to use each layer to imagine the
most convenient API you could want from the layer beneath it. Let's see it in 
action.


The FT for "My Lists"
~~~~~~~~~~~~~~~~~~~~~

As we work through the following functional test, we start with the most
outward-facing (presentation layer), through to the view functions (or
"controllers"), and lastly the innermost layers, which in this case will be
model code.

We know our `create_pre_authenticated_session` code works now, so we can just
write our FT to look for a "My Lists" page:


[role="sourcecode"]
.functional_tests/test_my_lists.py
[source,python]
----
    def test_logged_in_users_lists_are_saved_as_my_lists(self):
        # Edith is a logged-in user
        self.create_pre_authenticated_session('edith@example.com')

        # She goes to the home page and starts a list
        self.browser.get(self.server_url)
        self.get_item_input_box().send_keys('Reticulate splines\n')
        self.get_item_input_box().send_keys('Immanentize eschaton\n')
        first_list_url = self.browser.current_url

        # She notices a "My lists" link, for the first time.
        self.browser.find_element_by_link_text('My lists').click()

        # She sees that her list is in there, named according to its
        # first list item
        self.browser.find_element_by_link_text('Reticulate splines').click()
        self.assertEqual(self.browser.current_url, first_list_url)

        # She decides to start another list, just to see
        self.browser.get(self.server_url)
        self.get_item_input_box().send_keys('Click cows\n')
        second_list_url = self.browser.current_url

        # Under "my lists", her new list appears
        self.browser.find_element_by_link_text('My lists').click()
        self.browser.find_element_by_link_text('Click cows').click()
        self.assertEqual(self.browser.current_url, second_list_url)

        # She logs out.  The "My lists" option disappears
        self.browser.find_element_by_id('id_logout').click()
        self.assertEqual(
            self.browser.find_elements_by_link_text('My lists'),
            []
        )
----

If you run it, the first error should look like this:

----
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"link text","selector":"My lists"}' ; Stacktrace: 
----


The outside layer: presentation & templates
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The test is currently failing saying that it can't find a link saying "My
Lists". We can address that at the presentation layer, in 'base.html', in
our navigation bar. Here's the minimal code change:

[role="sourcecode"]
.lists/templates/base.html (ch18l002-1)
[source,html]
----
{% if user.email %}
    <ul class="nav navbar-nav">
        <li><a href="#">My lists</a></li>
    </ul>
    <a class="btn navbar-btn navbar-right" id="id_logout" href="{% url 'logout' %}">Log out</a>
[...]
----

Of course, that link doesn't actually go anywhere, but it does get us along to
the next failure:

----
    self.browser.find_element_by_link_text('Reticulate splines').click()
[...]
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"link text","selector":"Reticulate splines"}' ; Stacktrace:
----

Which is telling us we're going to have to build a page that lists all of a
user's lists by title.  Let's start with the basics -- a URL and a placeholder
template for it.

Again, we can go outside-in, starting at the presentation layer with just the 
URL and nothing else:


[role="sourcecode"]
.lists/templates/base.html (ch18l002-2)
[source,html]
----
    <ul class="nav navbar-nav">
        <li><a href="{% url 'my_lists' user.email %}">My lists</a></li>
    </ul>
----


Moving down one layer to view functions (the controller)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

That will cause a template error, so we'll start to move down from the
presentation layer and URLs down to the controller layer, Django's view
functions.

As always, we start with a test:

[role="sourcecode"]
.lists/tests/test_views.py (ch18l003)
[source,python]
----
class MyListsTest(TestCase):

    def test_my_lists_url_renders_my_lists_template(self):
        response = self.client.get('/lists/users/a@b.com/')
        self.assertTemplateUsed(response, 'my_lists.html')
----

That gives:

----
AssertionError: False is not true : Template 'my_lists.html' was not a template
used to render the response. Actual template(s) used: <Unknown Template>
----

And we fix it, still at the presentation level, in 'urls.py':


[role="sourcecode"]
.lists/urls.py
[source,python]
----
urlpatterns = patterns('',
    url(r'^(\d+)/$', 'lists.views.view_list', name='view_list'),
    url(r'^new$', 'lists.views.new_list', name='new_list'),
    url(r'^users/(.+)/$', 'lists.views.my_lists', name='my_lists'),
)
----
//004

That gives us a test failure, which informs us of what we should do as we
move down to the next level:

----
django.core.exceptions.ViewDoesNotExist: Could not import lists.views.my_lists.
View does not exist in module lists.views.
----

We move in from the presentation layer to the views layer, and create a
minimal placeholder:

[role="sourcecode"]
.lists/views.py (ch18l005)
[source,python]
----
def my_lists(request, email):
    return render(request, 'my_lists.html')
----

And, a minimal template:

[role="sourcecode"]
.lists/templates/my_lists.html
[source,html]
----
{% extends 'base.html' %}

{% block header_text %}My Lists{% endblock %}
----

That gets our unit tests passing, but our FT is still at the same point,
saying that the "My Lists" page doesn't yet show any lists.  It wants
them to be clickable links named after the first item:

----
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"link text","selector":"Reticulate splines"}' ; Stacktrace: 
----

Another pass, outside-in
~~~~~~~~~~~~~~~~~~~~~~~~

At each stage, we still let the FT drive what development we do.

Starting again at the outside layer, in the template, we begin to
write the template code we'd like to use to get the my lists page to
work the  way we want it to. As we do so, we start to specify the API
we want from the code at the layers below.


A quick re-structure of the template inheritance hierarchy
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Currently there's no place in our base template for us to put any new
content.  Also, the my lists page doesn't need the new item form, so
we'll put that into a block too, making it optional:

[role="sourcecode"]
.lists/templates/base.html (ch18l007-1)
[source,html]
----
    <div class="text-center">
        <h1>{% block header_text %}{% endblock %}</h1>

        {% block list_form %}
        <form method="POST" action="{% block form_action %}{% endblock %}">
            {{ form.text }}
            {% csrf_token %}
            {% if form.errors %}
                <div class="form-group has-error">
                    <div class="help-block">{{ form.text.errors }}</div>
                </div>
            {% endif %}
        </form>
        {% endblock %}

    </div>
----

[role="sourcecode"]
.lists/templates/base.html (ch18l007-2)
[source,html]
----
    <div class="row">
        <div class="col-md-6 col-md-offset-3">
            {% block table %}
            {% endblock %}
        </div>
    </div>

    <div class="row">
        <div class="col-md-6 col-md-offset-3">
            {% block extra_content %}
            {% endblock %}
        </div>
    </div>

</div>
<script src="http://code.jquery.com/jquery.min.js"></script>
[...]
----


Designing our API using the template
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now, 'my_lists.html' can override the `list_form` block, and make it empty.

[role="sourcecode"]
.lists/templates/my_lists.html
[source,html]
----
{% extends 'base.html' %}

{% block header_text %}My Lists{% endblock %}

{% block list_form %}{% endblock %}
----

And then we can just work in the new `extra_content` block:

[role="sourcecode"]
.lists/templates/my_lists.html
[source,html]
----
[...]
{% block list_form %}{% endblock %}

{% block extra_content %}
    <h2>{{ owner.email }}'s lists</h2> <1>
    <ul>
        {% for list in owner.list_set.all %} <2>
            <li><a href="{{ list.get_absolute_url }}">{{ list.name }}</a></li> <3>
        {% endfor %}
    </ul>
{% endblock %}
----

We've made several design decisions in this template which are going
to filter their way down through the code:

<1> We want a variable called `owner` to represent the user who owns the
    lists in our template.

<2> We want to be able to iterate through the lists created by the user using
    `owner.list_set.all` (I happen to know we get this for free from the Django
    ORM)

<3> We want to use `list.name` to print out the "name" of the list, which is
    currently specified as the text of its first element.

We can re-run our FTs, to check we didn't break anything, and to see whether
we've got any further:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests*]
[...]
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"link text","selector":"Reticulate splines"}' ; Stacktrace: 

 ---------------------------------------------------------------------
Ran 7 tests in 77.613s

FAILED (errors=1)
----

OK, no further, but at least nothing is broken. This is a good time for a
commit:

[subs="specialcharacters,quotes"]
----
$ *git add lists*
$ *git diff --staged*
$ *git commit -m "url, placeholder view, and first-cut template for my_lists"*
----


Moving down to the next layer: what the view passes to the template
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[role="sourcecode"]
.lists/tests/test_views.py (ch18l011)
[source,python]
----
from django.contrib.auth import get_user_model
User = get_user_model()
[...]
class MyListsTest(TestCase):

    def test_my_lists_url_renders_my_lists_template(self):
        [...]

    def test_passes_correct_owner_to_template(self):
        User.objects.create(email='wrong@owner.com')
        correct_user = User.objects.create(email='a@b.com')
        response = self.client.get('/lists/users/a@b.com/')
        self.assertEqual(response.context['owner'], correct_user)
----

Gives

----
KeyError: 'owner'
----

so

[role="sourcecode"]
.lists/views.py (ch18l012)
[source,python]
----
from django.contrib.auth import get_user_model
User = get_user_model()
[...]

def my_lists(request, email):
    owner = User.objects.get(email=email)
    return render(request, 'my_lists.html', {'owner': owner})
----

We'll then get an error which will require adding a user
to our other unit test



[role="sourcecode"]
.lists/tests/test_views.py (ch18l013)
[source,python]
----
    def test_my_lists_url_renders_my_lists_template(self):
        User.objects.create(email='a@b.com')
        [...]
----

And we get to an OK

----
OK
----


Moving down to the model layer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The design in our template layer wants to be able to get access to the
lists a user owns by using `.list_set.all`.   So we move down to write
a new test at the model layer:


[role="sourcecode"]
.lists/tests/test_models.py (ch18l018)
[source,python]
----
from django.contrib.auth import get_user_model
User = get_user_model()
[...]

class ListModelTest(TestCase):

    def test_get_absolute_url(self):
        [...]

    def test_lists_can_have_owners(self):
        user = User.objects.create(email='a@b.com')
        list_ = List.objects.create(owner=user)
        self.assertIn(list_, user.list_set.all())
----

And that gives us a new unit test failure:

----
    list_ = List.objects.create(owner=user)
    [...]
TypeError: 'owner' is an invalid keyword argument for this function
----

The naive implementation would be this:

[role="skipme"]
[source,python]
----
from django.conf import settings
[...]

class List(models.Model):
    owner = models.ForeignKey(settings.AUTH_USER_MODEL)
----

But we want to make sure the list owner is optional.  Explicit
is better than implicit, and tests are documentation, so let's have a test for
that too:


[role="sourcecode"]
.lists/tests/test_models.py (ch18l020)
[source,python]
----
    def test_list_owner_is_optional(self):
        List.objects.create()  # should not raise
----

The correct implementation is this:

[role="sourcecode"]
.lists/models.py
[source,python]
----
from django.conf import settings
[...]

class List(models.Model):
    owner = models.ForeignKey(settings.AUTH_USER_MODEL, blank=True, null=True)

    def get_absolute_url(self):
        return reverse('view_list', args=[self.id])
----
//21

Now running the tests gives a database error

----
    return Database.Cursor.execute(self, query, params)
django.db.utils.OperationalError: table lists_list has no column named owner_id
----


Because we need to do a schema migration

[subs="specialcharacters,quotes"]
----
$ *python3 manage.py schemamigration lists --auto*
+ Added field owner on lists.List
Created 0003_auto__add_field_list_owner.py. You can now apply this migration
with: ./manage.py migrate lists
----
//22


Fantastic.  We now have the ability, optionally, to assign owners to lists.


Another pass at the views layer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Before our FT will pass, we need the view that creates new lists to actually 
save the list owner, if the current user is actually logged-in.

[role="sourcecode"]
.lists/tests/test_views.py (ch18l014)
[source,python]
----
from django.http import HttpRequest
[...]
from lists.views import new_list
[...]

class NewListTest(TestCase):
    [...]

    def test_list_owner_is_saved_if_user_is_authenticated(self):
        request = HttpRequest()
        request.user = User.objects.create(email='a@b.com')
        request.POST['text'] = 'new list item'
        new_list(request)
        list_ = List.objects.first()
        self.assertEqual(list_.owner, request.user)
----

I've chosen to use the raw view function, and to manually construct an
`HttpRequest` because it's slightly easier to write the test that way. Although
the Django Test Client does have a helper function called `login`, but it
doesn't work well with external authentication services.  The alternative would
be to manually create a session object (like we do in the functional tests), or
to use mocks, and I think both of which would end up uglier than this version.
If you're curious, you could have a go at writing it differently.

The test fails as follows:

----
    self.assertEqual(list_.owner, request.user)
AssertionError: None != <User: User object>
----

To fix this, we can try writing code like this:

[role="sourcecode"]
.lists/views.py  
[source,python]
----
def new_list(request):
    form = ItemForm(data=request.POST)
    if form.is_valid():
        list_ = List.objects.create()
        list_.owner = request.user
        list_.save()
        form.save(for_list=list_)
        return redirect(list_)
    else:
        return render(request, 'home.html', {"form": form})
----
//021

That gets our new test passing, but two old tests now have errors:

----
ERROR: test_redirects_after_POST (lists.tests.test_views.NewListTest)
[...]
ValueError: Cannot assign "<SimpleLazyObject:
<django.contrib.auth.models.AnonymousUser object at 0x7f364795ef90>>":
"List.owner" must be a "User" instance.
ERROR: test_saving_a_POST_request (lists.tests.test_views.NewListTest)
[...]
ValueError: Cannot assign "<SimpleLazyObject:
<django.contrib.auth.models.AnonymousUser object at 0x7f364795ef90>>":
"List.owner" must be a "User" instance.
----

The problem is when the user is not logged in, we shouldn't be trying to save
them as the list owner. When they're not logged in, Django represents users
using a class called `AnonymousUser`:


[role="sourcecode"]
.lists/views.py (ch18l023)
[source,python]
----
from django.contrib.auth.models import AnonymousUser
[...]

    if form.is_valid():
        list_ = List.objects.create()
        if not isinstance(request.user, AnonymousUser):
            list_.owner = request.user
            list_.save()
        form.save(for_list=list_)
        [...]
----

And that gets us passing!
footnote:[The alternative way of checking whether a user is authenticated in
Django is to use `user.is_authenticated()` but, since we're using a custom
user model, we'd need to define that function on our User model manually.  That
feels like a distraction for this chapter, but by all means look into it.
The source of `AbstractBaseUser` in `django.contrib.auth.models` is a good
guide]

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
Creating test database for alias 'default'...
.......................................
 ---------------------------------------------------------------------
Ran 39 tests in 0.237s

OK
Destroying test database for alias 'default'...
----

This is a good time for a commit:

[subs="specialcharacters,quotes"]
----
$ *git add lists*
$ *git commit -m"lists can have owners, which are saved on creation."*
----



Final step: feeding through the .name API from the template
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The last thing our outside-in design wanted in the templates,
was to be able to access a list "name" based on the text of
its first item:

[role="sourcecode"]
.lists/tests/test_models.py (ch18l024)
[source,python]
----
    def test_list_name_is_first_item_text(self):
        list_ = List.objects.create()
        Item.objects.create(list=list_, text='first item')
        Item.objects.create(list=list_, text='second item')
        self.assertEqual(list_.name, 'first item')
----


[role="sourcecode"]
.lists/models.py (ch18l025)
[source,python]
----
    @property
    def name(self):
        return self.item_set.first().text
----

.The @property decorator in Python
*******************************************************************************
If you haven't seen it before, the `@property` decorator transforms a method
on a class to make it appear to the outside world like an attribute.

This is a powerful feature of the language, because it makes it easy to 
implement "duck typing", to change the implementation of a property without
changing the interface of the class.  In other words, if we decide to change
`.name` into being a "real" attribute on the model, which is stored as text in
the database, then we will be able to do so entirely transparently -- as far as
the rest of our code is concerned, they will still be able to just access
`.name` and get the list name, without needing to know about the
implementation.

Of course, in the Django template language, `.name` would still call the method
even if it didn't have `@property`, but that's a particularity of Django, and
doesn't apply to Python in general...
*******************************************************************************


And that, believe it or not, actually gets us a passing test, 
and a working "My Lists" page! (<<my-lists-page>>).

[[my-lists-page]]
.The "My Lists" page, in all its glory (and proof I did test on Windows)
image::images/my_lists_screenshot.png[Screenshot of new My Lists page]


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests*]
[...]
Ran 7 tests in 93.819s

OK
----

I'll tell you what though, those FTs are taking an annoyingly long time to 
run though.  I wonder if there's something we can do about that?

.Outside-In TDD
*******************************************************************************

Outside-in TDD::
    A methodology for building code, driven by tests, which proceeds by
    starting from the "outside" layers (presentation, GUI), and moving
    "inwards" step-by-step, via view/controller layers, down towards 
    the model layer.  The idea is to drive the design of your code from
    the use to which it is going to be put, rather than trying to anticipate
    requirements from the ground up.

Mocks and "London-Style" TDD::
    In the world of Object-Oriented software design, outside-in TDD is 
    associated with the use of Mock objects. At each stage, you're writing
    tests for classes defining how they will collaborate with other
    classes that don't exist yet, at the next level down.  The natural solution
    is to use mocks to represent them.
    +
    In simple Django applications, where our layers are simply
    template/view/model, I find mocks to be overkill.  Once  applications reach
    the next level of complexity, where business logic is represented by
    a set of classes and functions independent of the Django ORM and 
    presentation layer, then the wider use of Mocks may be a better approach.
    It's beyond the scope of this book (and beyond my abilities) to present
    a decent overview of OO mocking techniques, and the pros and cons of what's
    called "London-Style" TDD to distinguish it from the "Chicago School", so
    I leave you to discover that world on your own.  One book I do recommend is
    <<GOOSGBT, Growing Object-Oriented Software, Guided By Tests>> by Steve
    Freeman and Nat Pryce... but I warn you: you'll have to wade through a lot
    of Java!

*******************************************************************************

