The token social bit: list sharing
----------------------------------

Are jokes about how "everything has to be social now" slightly old hat?
Everything has to be all A/B tested big data get-more-clicks lists of 10 Things
This Inspiring Teacher Said That Will Make You Change Your Mind About Bla Bla
now. Anyway. Lists, be they Inspirational or otherwise, are often better
shared. Let's allow our users to share their lists with other users.

Along the way we'll improve our FTs by starting to implement the interact/wait
Selenium pattern that we learned in the last chapter.  We'll also experiment
with something called the Page Object pattern.

Once we get to the unit testing phase, we'll talk a bit about the concept
of "Outside-In" TDD.


An FT with multiple users, and addCleanup
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's get started -- we'll need two users for this FT:

[role="sourcecode"]
.functional_tests/test_sharing.py
[source,python]
----
from selenium import webdriver
from .base import FunctionalTest

def quit_if_possible(browser):
    try: browser.quit()
    except: pass


class SharingTest(FunctionalTest):

    def test_logged_in_users_lists_are_saved_as_my_lists(self):
        # Edith is a logged-in user
        self.create_pre_authenticated_session('edith@email.com')
        edith_browser = self.browser
        self.addCleanup(lambda: quit_if_possible(edith_browser))

        # Her friend Oniciferous is also hanging out on the lists site
        oni_browser = webdriver.Firefox()
        self.addCleanup(lambda: quit_if_possible(oni_browser))
        self.browser = oni_browser
        self.create_pre_authenticated_session('oniciferous@email.com')

        # Edith goes to the home page and starts a list
        self.browser = edith_browser
        self.browser.get(self.server_url)
        self.get_item_input_box().send_keys('Get help\n')

        # She notices a "Share this list" option
        share_box = self.browser.find_element_by_css_selector('input[name=email]')
        self.assertEqual(
            share_box.get_attribute('placeholder'),
            'your@friends-email.com'
        )
----
//TODO: rename Edith to Francis, as per ch. 6?

The interesting feature to note about this section is the `addCleanup`
function, whose documentation you can find 
http://docs.python.org/3/library/unittest.html#unittest.TestCase.addCleanup[here].
It can be used as an alternative to the `tearDown` function as a way of
cleaning up resources used during the test.  It's most useful when the resource
is only allocated half-way through a test.

`addCleanup` is run after `tearDown`, which is why we need that try/except
formulation for `quit_if_possible` -- whichever of `edith_browser` and 
`oni_browser` is also assigned to `self.browser` at the point at which the 
test end will already have been quit by the tearDown function.

We also need to change the way our pre-authenticated session creator works,
so that it can take an arbitrary email address for the user to create an
account and session for.  We start by moving the helper function out of
`MyListsTest` and into 'base.py', and changing its signature:


[role="sourcecode"]
.functional_tests/base.py
[source,diff]
----
    def create_pre_authenticated_session(self, email):
        if self.against_staging:
            session_key = create_session_on_server(self.server_host, email)
        else:
            session_key = create_pre_authenticated_session(email)
        ## to set a cookie we need to first visit the domain.
        ## 404 pages load the quickest!
        self.browser.get(self.server_url + "/404_no_such_url/")
        self.browser.add_cookie(dict(
            name=settings.SESSION_COOKIE_NAME,
            value=session_key,
            path='/',
        ))
----

(I'm sure you're capable of deleting the old version of this function from
'test_my_lists.py' and fixing up all the required imports.)


Passing arguments to management commands and fabric commands
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

As you may remember, `create_pre_authenticated_session` is defined in
our management command file, so that it can be called both locally and
against the staging server.  Here's how we adjust it to take an
email as an argument:

 
[role="sourcecode"]
.functional_tests/management/commands/create_session.py 
[source,diff]
----
 class Command(BaseCommand):
+    args = '<email>'
 
-    def handle(self, *_, **__):
-        session_key = create_pre_authenticated_session()
+    def handle(self, email, **__):
+        session_key = create_pre_authenticated_session(email)
         self.stdout.write(session_key)
 
 
-def create_pre_authenticated_session():
-    user = User.objects.create(email='edith@email.com')
+def create_pre_authenticated_session(email):
+    user = User.objects.create(email=email)
     session = SessionStore()
     session[SESSION_KEY] = user.pk
     session[BACKEND_SESSION_KEY] = settings.AUTHENTICATION_BACKENDS[0]
----


And now we change our fabfile and fabfile-caller for the case where we are
running against the server:

[role="sourcecode"]
.functional_tests/fabfile.py
[source,python]
----
def create_session_on_server(email):
    session_key = run('{manage_py} create_session {email}'.format(
        manage_py=_get_manage_dot_py(env.host),
        email=email
    ))
    print(session_key)
----

And the function that calls it in 'server_tools.py' also gets a slight tweak

[role="sourcecode"]
.functional_tests/server_tools.py
[source,diff]
----
-def create_session_on_server(host):
+def create_session_on_server(host, email):
     return subprocess.check_output(
         [
             'fab',
-            'create_session_on_server',
+            'create_session_on_server:email={}'.format(email),
             '--host={}'.format(host),
             '--hide=everything,status',
         ],
----

As you can see, the command-line syntax for arguments to fab functions is
quite simple, a colon and then a variable=argument syntax.

OK, let's just see if that all works:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.test_sharing*]
[...]
Traceback (most recent call last):
  File "/workspace/superlists/functional_tests/test_sharing.py", line 29, in
test_logged_in_users_lists_are_saved_as_my_lists
    share_box = self.browser.find_element_by_css_selector('input[name=email]')
[...]
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"css selector","selector":"input[name=email]"}' ;
----

Great! It seems to have got through creating the two user sessions, and
it gets onto an expected failure -- there is no input for an email address
of a person to share a list with on the page.

Let's do a commit at this point, because we've got at least a placeholder 
for our FT, we've got a useful modification of the
`create_pre_authenticated_session` function, and we're about to embark on
a bit of an FT refactor

[subs="specialcharacters,quotes"]
----
$ *git add functional_tests*
$ *git commit -m "New FT for sharing, adjust session creation code to take an email"
----


Implementing the Selenium interact/wait pattern
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Before we continue, let's take a closer look at our the interactions with the
site that we have in our FT so far:

[role="sourcecode"]
.functional_tests/test_sharing.py
[source,python]
----
    # Edith goes to the home page and starts a list
    self.browser = edith_browser
    self.browser.get(self.server_url)
    self.get_item_input_box().send_keys('Get help\n') #<1>

    # She notices a "Share this list" option
    share_box = self.browser.find_element_by_css_selector('input[name=email]') #<2>
    self.assertEqual(
        share_box.get_attribute('placeholder'),
        'your@friends-email.com'
    )
----

<1> Interaction with site

<2> Assumption about updated state of page

We learned in the last chapter that it's dangerous to assume too much about
the state of the browser after we do an interaction (like `send_keys`). In
theory, `implicitly_wait` will make sure that, if the call to
`find_element_by_css_selector` doesn't find our `input[name=email]` at first,
it will silently retry a few times.  But it can also go wrong -- imagine if
there was an input on the previous page, with the same `name=email`, but a
different placeholder text?  We'd get a strange failure.

So instead, it's always prudent to follow the "wait-for" pattern whenever we
want to check on the effects of an interaction that we've just triggered.
Something like this:


[role="sourcecode"]
.functional_tests/test_sharing.py
[source,python]
----
    self.get_item_input_box().send_keys('Get help\n')

    # She notices a "Share this list" option
    self.wait_for(
        lambda:  self.assertEqual(
            self.browser.find_element_by_css_selector(
                'input[name=email]'
            ).get_attribute('placeholder'),
            'your@friends-email.com'
        )
    )
----


The page pattern
~~~~~~~~~~~~~~~~

But do you know what would be even better?  This is an occasion for a "3
strikes and refactor".  This test, and many others, all begin off with the user
starting a new list.  What if we had a helper function called "start new list",
that would do the `wait_for` as well as the list item input?  

We've already seen how to use helper methods on the base `FunctionalTest`
class, but if we continue using too many of them, it's going to get very
crowded. I've worked on a base FT class that's was over 1,500 lines long, and
that got pretty unwieldy.

One accepted pattern for splitting up your FT helper code is called the 
http://www.seleniumhq.org/docs/06_test_design_considerations.jsp#page-object-design-pattern[Page
pattern], and it involves having objects to represent the different pages on
your site, and to be the single place to store information about how to 
interact with them.

Let's see how we would build a page object for the home page, and one for the
lists page.  Here's one for the home page



[role="sourcecode"]
.functional_tests/home_and_list_pages.py
[source,python]
----
LIST_ITEM_INPUT_ID = 'id_text'

class HomePage(object):

    def __init__(self, test):
        self.test = test #<1>

    def go_to_home_page(self): #<2>
        self.test.browser.get(self.test.server_url)
        self.test.wait_for(self.get_item_input)


    def get_item_input(self):
        return self.test.browser.find_element_by_id('id_text')


    def start_new_list(self, item_text): #<3>
        self.go_to_home_page()
        inputbox = self.get_item_input()
        inputbox.send_keys(item_text + '\n')
        list_page = ListPage(self.test) #<4>
        list_page.wait_for_new_item_in_list(item_text, 1) #<5>
        return list_page #<6>

----

<1> It's initialised with an object that represents the current test.  That
    gives us the ability to make assertions, access the browser instance via
    `self.test.browser`, and use the `wait_for` function

<2> Most Page objects have a "go to this page" function.  Notice that it
    implements the interaction/wait pattern -- first we `get` the page URL,
    then we wait for an element that we know is on the home page.
//TODO: consider the fact that the lists page has that too...

<3> Here's our function that starts a new list.  It goes to the home page,
    finds the input box, and sends the new item text to it, as well as a
    carriage return.  It also then uses a wait to check that the interaction
    has completed, but you'll see it actually uses a new Page object:

<4> The `ListPage`, which we'll see the code for shortly. It's initialized just
    like a `HomePage`.

<5> We use the `ListPage` to `wait_for_new_item_in_list`.  We specify the
    expected text of the item, and its expected position in the list.

<6> Finally, we return the `list_page` object to the caller, because they
    will probably find it useful (as we'll see shortly).


Here's how `ListPage` looks:

[role="sourcecode"]
.functional_tests/home_and_list_pages.py
[source,python]
----
[...]

class ListPage(object):

    def __init__(self, test):
        self.test = test

    def get_list_table_rows(self):
        return self.test.browser.find_elements_by_css_selector(
            '#id_list_table tr'
        )

    def wait_for_new_item_in_list(self, item_text, position):
        expected_row = '{}: {}'.format(position, item_text)
        self.test.wait_for(lambda: self.test.assertIn(
            expected_row,
            [row.text for row in self.get_list_table_rows()]
        ))
----


Let's see how to use it in our test:


[role="sourcecode"]
.functional_tests/test_sharing.py
[source,python]
----
        # Edith goes to the home page and starts a list
        self.browser = edith_browser
        HomePage(self).start_new_list('Get help')
----

Let's continue rewriting our test, using the Page object whenever
we want to access elements from the lists page:

[role="sourcecode"]
.functional_tests/test_sharing.py
[source,python]
----
        # She notices a "Share this list" option
        share_box = list_page.get_share_box()
        self.assertEqual(
            share_box.get_attribute('placeholder'),
            'your@friends-email.com'
        )

        # She shares her list.
        # The page updates to say that it's shared with Oniciferous:
        list_page.share_list_with('oniciferous@email.com')
----

We add the following three functions to our ListPage:


[role="sourcecode"]
.functional_tests/home_and_list_pages.py
[source,python]
----
    def get_share_box(self):
        return self.test.browser.find_element_by_css_selector(
            'input[name=email]'
        )


    def get_shared_with_list(self):
        return self.test.browser.find_elements_by_css_selector(
            'list-sharee'
        )


    def share_list_with(self, email):
        self.get_share_box().send_keys(email + '\n')
        self.test.wait_for(lambda: self.test.assertIn(
            email,
            [item.text for item in self.get_shared_with_list()]
        )
----

The idea behind the Page pattern is that it should capture all the information
about a particular page in your site, so that if, later, you want to go and
make changes to that page -- even just simple tweaks to its HTML layout for
example -- you have a single place to go and look for to adjust your functional
tests, rather than having to dig through dozens of FTs.

So the next step would be to pursue the refactor through our other tests. I'm
not going to show that here, but I'd recommend you spend a bit of time doing 
that now, to start getting a feel for how these things work. You can then
compare your results to the way I did it at 
TODO: insert github link.
Pull requests are always encouraged!


Extend the FT to a second user, and the My Lists page
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Next let's spec out just a little more detail of what we want our sharing user
story to be.  Edith has seen on her list page that the list is now "shared
with" Oniciferous, and then we can have Oni log in and see the list on his "My
Lists" page, maybe in a section called "lists shared with me".

[role="sourcecode"]
.functional_tests/test_sharing.py
[source,python]
----
    [...]
    list_page.share_list_with('oniciferous@email.com')

    # Oniciferous now goes to the lists page with his browser
    self.browser = oni_browser
    home_page = HomePage(self).go_to_home_page()
    home_page.go_to_my_lists_page()

    # He sees Edith's list in there!
    self.browser.find_element_by_link_text('Get help').click()
----

That means another function in our `HomePage` class:

[role="sourcecode"]
.functional_tests/home_and_list_pages.py
[source,python]
----
class HomePage(object):
    [...]

    def go_to_my_lists_page(self):
        self.test.browser.find_element_by_link_text('My lists').click()
        self.test.wait_for(self.test.assertEqual(
            self.test.browser.find_elements_by_tag_name('h1'),
            'My Lists'
        ))
----

Once again, this is a function which it would be good to carry across into
'test_my_lists.py', along with maybe a `MyListsPage` object. Exercise
for the reader!

        # On the list page, Oniciferous can see says that it's Edith's list
        self.wait_for(lambda: self.assertEqual(
            list_page.get_list_owner(),
            'edith@email.com'
        ))


Finally, Oniciferous can also add things to the list:

[role="sourcecode"]
.functional_tests/test_sharing.py
[source,python]
----
    # On the list page, Oniciferous can see says that it's Edith's list
    self.wait_for(lambda: self.assertEqual(
        list_page.get_list_owner(),
        'edith@email.com'
    ))

    # He adds an item to the list
    list_page.add_new_item('Hi Edith!')

    # When Edith refreshes the page, she sees Oniciferous's addition
    self.browser = edith_browser
    self.browser.refresh()
    list_page.wait_for_new_item_in_list('Hi Edith!', 2)
----

That's a couple more additions to our page object:

[role="sourcecode"]
.functional_tests/home_and_list_pages.py
[source,python]
----
ITEM_INPUT_ID = 'id_text'
[...]

class ListPage(object):

    def get_item_input(self):
        return self.test.browser.find_element_by_id(ITEM_INPUT_ID)

    [...]

    def add_new_item(self, item_text):
        current_pos = len(self.get_list_table_rows())
        self.get_item_input().send_keys(item_text + '\n')
        self.wait_for_new_item_in_list(item_text, current_pos + 1)


    def get_list_owner(self):
        return self.test.browser.find_element_by_id('id_list_owner').text
----

At this point we might run the FT to check all of this works!

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.test_sharing*]

    share_box = list_page.get_share_box()
    [...]
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"css selector","selector":"input[name=email]"}' ;
----

And then do a commit


[subs="specialcharacters,quotes"]
----
$ *git add functional_tests*
$ *git commit -m "Create Page objects for Home and List pages, use in sharing FT"
----


Outside-in TDD
~~~~~~~~~~~~~~

Let's proceed using a technique called "outside-in" TDD.  It's pretty much what
we've been doing all along, but now we'll make it explicit, and talk about some
of the common issues involved.

Our "double-loop" TDD process, in which we write the functional test first and
then the unit tests, is already a manifestation of outside-in TDD - we design
the system from the outside, and build up our code in layers. I'll point out
how we start with the most outward-facing (presentation layer), through to the
view functions (or "controllers"), and lastly the innermost layers, which in
this case will be model code.

The outside layer: presentation & templates
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


The test is currently failing saying that it can't find a field to input
the sharee email.  We can address that at the presentation layer, in
the 'list.html' template:

[role="sourcecode"]
.lists/templates/list.html
[source,html]
----
{% block more_content %}
<div class="row">
    <h3>Share this list:</h3>
    <form class="form-inline">
        <label for="email">Share this list:</label>
        <input name="email" placeholder="your@friends-email.com" />
    </form>
</div>
{% endblock %}
----

That gets the FT one step further:

----
AssertionError: 'oniciferous@email.com' not found in []
----

Let's add a "Shared with" section:

[role="sourcecode"]
.lists/templates/list.html
[source,html]
----
{% block more_content %}
<div class="row">

    <div class="col-md-6 col-md-offset-2">
        <h3>Shared with</h3>
        <ul>
            {% for sharee in list.shared_with.all %}
                <li class="list-sharee">{{ sharee.email }}</li>
            {% endfor %}
        </ul>
    </div>

    <div class="col-md-3">
        <h3>Share this list:</h3>
        <form class="form-inline">
            <input name="email" placeholder="your@friends-email.com" />
        </form>
    </div>

</div>
{% endblock %}
----

You can see that we're starting to do some outside-in design.  We've specified
that we want to be able to retrieve a list of people that a list is shared with
using an attribute on the list class called `shared_with`, and it's going to 
be a Django Queryset, so we'll use its `.all` method to retrieve all the shared
users.

Let's let our FT point us to the next thing we need to build:

[subs="specialcharacters,macros"]
----
AssertionError: 'oniciferous@email.com' not found in []
----

So the server isn't currently saving the addition of Oniciferous to the sharee
list.  To get it to do that, we'd need a view for the form to submit to. Once
again, we can start work in the template, and see where it guides us:


[role="sourcecode"]
.lists/templates/list.html
[source,html]
----
<form class="form-inline" method="POST" action="{% url 'share_list' list.id %}" >
----

That will cause a server error until we define the URL:

----
django.core.urlresolvers.NoReverseMatch: Reverse for 'share_list' with
arguments '(1,)' and keyword arguments '{}' not found. 0 pattern(s) tried: []
----

The middle layer: controller views, and urls
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[role="sourcecode"]
.lists/urls.py
[source,python]
----
urlpatterns = patterns('',
    url(r'^new$', 'lists.views.new_list', name='new_list'),
    url(r'^(\d+)/$', 'lists.views.view_list', name='view_list'),
    url(r'^(\d+)/share$', 'lists.views.share_list', name='share_list'),
)
----

And now we'll need to define at least a placeholder view:

----
django.core.exceptions.ViewDoesNotExist: Could not import
lists.views.share_list. View does not exist in module lists.views.
----

Something like this:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def share_list(request, list_id):
    pass
----

That'll get our unit tests happy again.

----
OK
----

Next we should start writing a new unit test for our list sharing view

[role="sourcecode"]
.lists/tests/test_views.py
[source,python]
----
class ShareListTest(TestCase):

    def test_sharing_a_list_via_post(self):
        sharee = User.objects.create(email='share.with@me.com')
        list_ = List.objects.create()
        self.client.post(
            '/lists/%d/share' % (list_.id),
            {'email': 'share.with@me.com'}
        )
        self.assertIn(list_.shared_with.all(), sharee)
-----

Gives

-----
ValueError: The view lists.views.share_list didn't return an HttpResponse object.
-----

.A more purist approach involving mocks
*******************************************************************************

Is this "pure" outside-in TDD? No.  A purist approach to outside-in TDD would
want you to use a mock at this point, and have unit tests that are more 
isolated from one level to another.  Something like this:

    @patch('lists.views.List')
    def test_post_leads_to_adding_to_shared_with(self, mockList):
        self.client.post('/lists/12/share', {'email': 'an email'})
        mock_list = mockList.objects.get.return_value
        mock_list.shared_with.add.assert_called_once_with('an email')

I'm don't like that sort of approach though.  Perfectly isolated tests are
best for an environment with no boundaries, and for a simple app like ours,
the database and the Django ORM are too prevalent in our code.  If we started
building an abstraction layer around the database, then it might make sense,
but with a simple database-driven site like ours, I don't think adding the 
extra layer of indirection is worth it.

TODO: demo this instead?

*******************************************************************************


That suggests another test:


[role="sourcecode"]
.lists/tests/test_views.py
[source,python]
----
    def test_redirects_after_POST(self):
        sharee = User.objects.create(email='share.with@me.com')
        list_ = List.objects.create()
        self.client.post(
            '/lists/%d/share' % (list_.id),
            {'email': 'share.with@me.com'}
        )
        self.assertRedirects(response, list_.get_absolute_url())
----


So we can start with a couple of boilerplate lines to do the redirect:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def share_list(request, list_id):
    list_ = List.objects.get(id=list_id)
    return redirect(list_)
----


And we get:

----
AttributeError: 'List' object has no attribute 'shared_with'
----

//TODO -- this might be a good place to jump off and talk about triangulation, test permissions


The inside layer: models
^^^^^^^^^^^^^^^^^^^^^^^^

And now we step down one more level to the model layer. 

[role="sourcecode"]
.lists/tests/test_models.py
[source,python]
----
class ListModelTest(TestCase):

    def test_get_absolute_url(self):
        [...]


    def test_can_optionally_set_owner(self):
        [...]


    def test_can_share_with_another_user(self):
        list_ = List.objects.create()
        user = User.objects.create(email='a@b.com')
        list_.shared_with.add('a@b.com')
        list_in_db = List.objects.get(id=list_.id)
        self.assertIn(user, list_in_db.shared_with.all())
----

Gives

----
AttributeError: 'List' object has no attribute 'shared_with'
AttributeError: 'List' object has no attribute 'shared_with'
----

We start fixing in models

[role="sourcecode"]
.lists/models.py
[source,python]
----
    shared_with = models.ManyToManyField(settings.AUTH_USER_MODEL)
----

That won't quite work:


----
CommandError: One or more models did not validate:
lists.list: Accessor for field 'owner' clashes with related m2m field
'User.list_set'. Add a related_name argument to the definition for 'owner'.
lists.list: Accessor for m2m field 'shared_with' clashes with related field
'User.list_set'. Add a related_name argument to the definition for
'shared_with'.
----

Adding the related_name field:

[role="sourcecode"]
.lists/models.py
[source,python]
----
    shared_with = models.ManyToManyField(
        settings.AUTH_USER_MODEL, related_name='shared_lists'
    )
----

Some database errors:

----
django.db.utils.OperationalError: no such table: lists_list_shared_with
----

We add a schema migration:

[role="sourcecode"]
.lists/tests.py
[source,python]
----
python3 manage.py schemamigration --auto lists
----

Now we're down to just one failure in our view tests:

----
FAIL: test_sharing_a_list_via_post (lists.tests.test_views.ShareListTest)
[...]
AssertionError: <User: User object> not found in []

Ran 36 tests in 0.156s

FAILED (failures=1)
----


[role="sourcecode"]
.lists/models.py
[source,python]
----
def share_list(request, list_id):
    list_ = List.objects.get(id=list_id)
    list_.shared_with.add(request.POST['email'])
    return redirect(list_)
----

Are we there?

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.test_sharing*]

AssertionError: 'Shared with' not found in 'Forbidden (403)\nCSRF verification failed. Request aborted.\nMore information is available with DEBUG=True.'
----


Ah, not quite.  One last thing:


[role="sourcecode"]
.lists/templates/list.html
[source,html]
----
        <form class="form-inline" method="POST" action="{% url 'share_list' list.id %}" >
            {% csrf_token %}
            <input name="email" placeholder="your@friends-email.com" />
        </form>
----

Now the Ft gets further, up to Oni trying to see the list:

----
    self.browser.find_element_by_link_text('Get help').click()
[...]
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"link text","selector":"Get help"}' ; Stacktrace: 
----

Fix that in my_lists.html


And one final thing:

----
AssertionError: 'List owner: edith@email.com' not found in 'Superlists\nMy lists\nLog out\nLogged in as oniciferous@email.com\nYour To-Do list\n1: Get help\nShared with\noniciferous@email.com\nShare this list:'
----

Identify list owners:

[role="sourcecode"]
.lists/templates/list.html
[source,html]
----
{% block table %}
    <table id="id_list_table">
        {% for item in list.item_set.all %}
            <tr><td>{{ forloop.counter }}: {{ item.text }}</td></tr>
        {% endfor %}
    </table>
    <p>List owner: {{ list.owner.email }}</p>
{% endblock %}
----

And we get to a pass!

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.test_sharing*]

Ran 1 test in 21.886s

OK
----



Possible things to include:
~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Introduce page pattern?
* Admin site?
* django notifications?
* email notifications?
* talk about security/perms testing -- checking negatives.
* error-handling, what if user doesn't exist


