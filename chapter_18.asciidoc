The token social bit: list sharing
----------------------------------

Are jokes about how "everything has to be social now" slightly old hat?
Everything has to be all A/B tested big data get-more-clicks lists of 10 Things
This Inspiring Teacher Said That Will Make You Change Your Mind About Bla Bla
now. Anyway. Lists, be they Inspirational or otherwise, are often better
shared. Let's allow our users to share their lists with other users.



An FT with multiple users, and addCleanup
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Here we go!  Ft:

[role="sourcecode"]
.functional_tests/test_sharing.py
[source,python]
----
from selenium import webdriver
from .base import FunctionalTest

def quit_if_possible(browser):
    try: browser.quit()
    except: pass


class SharingTest(FunctionalTest):

    def test_logged_in_users_lists_are_saved_as_my_lists(self):
        # Edith is a logged-in user
        self.create_pre_authenticated_session('edith@email.com')
        edith_browser = self.browser
        self.addCleanup(lambda: quit_if_possible(edith_browser))

        # Her friend Oniciferous is also hanging out on the lists site
        oni_browser = webdriver.Firefox()
        self.addCleanup(lambda: quit_if_possible(oni_browser))
        self.browser = oni_browser
        self.create_pre_authenticated_session('oniciferous@email.com')

        # Edith goes to the home page and starts a list
        self.browser = edith_browser
        self.browser.get(self.server_url)
        self.get_item_input_box().send_keys('Get help\n')

        # She notices a "Share this list" option
        share_box = self.browser.find_element_by_css_selector('input[name=email]')
        self.assertEqual(
            share_box.get_attribute('placeholder'),
            'your@friends-email.com'
        )
----
//TODO: rename Edith to Francis, as per ch. 6?

The interesting feature to note about this section is the `addCleanup`
function, whose documentation you can find 
http://docs.python.org/3/library/unittest.html#unittest.TestCase.addCleanup[here].
It can be used as an alternative to the `tearDown` function as a way of
cleaning up resources used during the test.  It's most useful when the resource
is only allocated half-way through a test.

`addCleanup` is run after `tearDown`, which is why we need that try/except
formulation for `quit_if_possible` -- whichever of `edith_browser` and 
`oni_browser` is also assigned to `self.browser` at the point at which the 
test end will already have been quit by the tearDown function.

We also need to change the way our pre-authenticated session creator works,
so that it can take an arbirtray email address for the user to create an
account and session for.  We start by moving the helper function out of
`MyListsTest` and into 'base.py', and changing its signature:


[role="sourcecode"]
.functional_tests/base.py
[source,diff]
----
    def create_pre_authenticated_session(self, email):
        if self.against_staging:
            session_key = create_session_on_server(self.server_host, email)
        else:
            session_key = create_pre_authenticated_session(email)
        ## to set a cookie we need to first visit the domain.
        ## 404 pages load the quickest!
        self.browser.get(self.server_url + "/404_no_such_url/")
        self.browser.add_cookie(dict(
            name=settings.SESSION_COOKIE_NAME,
            value=session_key,
            path='/',
        ))
----

(I'm sure you're capable of deleting the old version of this function from
'test_my_lists.py' and fixing up all the required imports.)


Passing arguments to management commands and fabric commands
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

As you may remember, `create_pre_authenticated_session` is defined in
our management command file, so that it can be called both locally and
against the staging server.  Here's how we adjust them to take an
email as an argument:

 
[role="sourcecode"]
.functional_tests/management/commands/create_session.py 
[source,diff]
----
 class Command(BaseCommand):
+    args = '<email>'
 
-    def handle(self, *_, **__):
-        session_key = create_pre_authenticated_session()
+    def handle(self, email, **__):
+        session_key = create_pre_authenticated_session(email)
         self.stdout.write(session_key)
 
 
-def create_pre_authenticated_session():
-    user = User.objects.create(email='edith@email.com')
+def create_pre_authenticated_session(email):
+    user = User.objects.create(email=email)
     session = SessionStore()
     session[SESSION_KEY] = user.pk
     session[BACKEND_SESSION_KEY] = settings.AUTHENTICATION_BACKENDS[0]
----


And now we adjust our fabfile and fabfile-caller for the case where we
are running this against the server:

[role="sourcecode"]
.functional_tests/fabfile.py
[source,python]
----
def create_session_on_server(email):
    session_key = run('{manage_py} create_session {email}'.format(
        manage_py=_get_manage_dot_py(env.host),
        email=email
    ))
    print(session_key)
----

And the function that calls it in 'server_tools.py' also gets a slight tweak

[role="sourcecode"]
.functional_tests/server_tools.py
[source,diff]
----
-def create_session_on_server(host):
+def create_session_on_server(host, email):
     return subprocess.check_output(
         [
             'fab',
-            'create_session_on_server',
+            'create_session_on_server:email={}'.format(email),
             '--host={}'.format(host),
             '--hide=everything,status',
         ],
----

As you can see, the command-line syntax for arguments to fab functions is
quite simple, a colon and then a variable=argument syntax.

OK, let's just see if that all works:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.test_sharing*]
[...]
Traceback (most recent call last):
  File "/workspace/superlists/functional_tests/test_sharing.py", line 29, in
test_logged_in_users_lists_are_saved_as_my_lists
    share_box = self.browser.find_element_by_css_selector('input[name=email]')
[...]
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"css selector","selector":"input[name=email]"}' ;
----

Great! It seems to have got through creating the two user sessions, and
it gets onto an expected failure -- there is no input for an email address
of a person to share a list with on the page.

Before we continue, let's spec out just a little more detail of what we want
our sharing user story to be.  Edith will see on her list page that the list
is now "shared with" Oniciferous, and then we can have Oni log in and see the
list on his "My Lists" page, maybe in a section called "lists shared with me".

[role="sourcecode"]
.functional_tests/test_sharing.py
[source,python]
----
        share_box.send_keys('oniciferous@email.com\n')

        # The page updates to say that it's shared with Oniciferous:
        body_text = self.browser.find_element_by_tag_name('body').text
        self.assertIn('Shared with', body_text)
        self.assertIn('oniciferous@email.com', body_text)

        # Oniciferous now goes to the lists page with his browser
        self.browser = oni_browser
        self.browser.get(self.server_url)
        self.browser.find_element_by_link_text('My lists').click()

        # He sees edith's list in there!
        self.browser.find_element_by_link_text('Get help').click()
----


And finally, Oniciferous can also add things to the list:

[role="sourcecode"]
.functional_tests/test_sharing.py
[source,python]
----
        # It says that it's edith's list
        self.wait_for(
            lambda: self.assertIn(
                'List owner: edith@email.com',
                self.browser.find_element_by_tag_name('body').text
            )
        )

        # He adds an item to the list
        self.get_item_input_box().send_keys('Hi Edith!\n')

        # When edith refreshes the page, she sees Oniciferous's addition
        self.browser = edith_browser
        self.browser.refresh()
        self.check_for_row_in_list_table('2: Hi Edith!')
----

At this point we might re-run the FT to check we haven't broken anything,
and then do a commit


[subs="specialcharacters,quotes"]
----
$ *git add functional_tests*
$ *git commit -m "New FT for sharing, adjust session creation code to take an email"
----


Outside-in TDD
~~~~~~~~~~~~~~

Let's proceed using a technique called "outside-in" TDD.  It's pretty much what
we've been doing all along, but now we'll make it explicit, and talk about some
of the common issues involved.

Our "double-loop" TDD process, in which we write the functional test first and
then the unit tests, is already a manifestation of outside-in TDD - we design
the system from the outside, and build up our code in layers. I'll point out
how we start with the most outward-facing (presentation layer), through to the
view functions (or "controllers"), and lastly the innermost layers, which in
this case will be model code.

The outside layer: presentation & templates
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


The test is currently failing saying that it can't find a field to input
the sharee email.  We can address that at the presentation layer, in
the 'list.html' template:

[role="sourcecode"]
.lists/templates/list.html
[source,html]
----
{% block more_content %}
<div class="row">
    <form class="form-inline">
        <label for="email">Share this list:</label>
        <input name="email" placeholder="your@friends-email.com" />
    </form>
</div>
{% endblock %}
----

That gets the FT one step further:

----
AssertionError: 'Shared with' not found in 'Superlists\nMy lists\nLog
out\nLogged in as edith@email.com\nYour To-Do list\n1: Get help\nShare this
list:'
----

Let's add a "Shared with" section:

[role="sourcecode"]
.lists/templates/list.html
[source,html]
----
{% block more_content %}
<div class="row">

    <div class="col-md-6 col-md-offset-2">
        <h3>Shared with</h3>
        <ul>
            {% for sharee in list.shared_with.all %}
                <li>{{ sharee.email }}</li>
            {% endfor %}
        </ul>
    </div>

    <div class="col-md-3">
        <h3>Share this list:</h3>
        <form class="form-inline">
            <input name="email" placeholder="your@friends-email.com" />
        </form>
    </div>

</div>
{% endblock %}
----

You can see that we're starting to do some outside-in design.  We've specified
that we want to be able to retrieve a list of people that a list is shared with
using an attribute on the list class called `shared_with`, and it's going to 
be a Django Queryset, so we'll use its `.all` method to retrieve all the shared
users.

Let's let our FT point us to the next thing we need to build:

[subs="specialcharacters,macros"]
----
AssertionError: 'oniciferous@email.com' not found in 'Superlists\nMy lists\nLog
out\nLogged in as edith@email.com\nYour To-Do list\n1: Get help\nShared
with\nShare this list:'
----

So the server isn't currently saving the addition of Oniciferous to the sharee
list.  To get it to do that, we'd need a view for the form to submit to. Once
again, we can start work in the template, and see where it guides us:


[role="sourcecode"]
.lists/templates/list.html
[source,html]
----
<form class="form-inline" method="POST" action="{% url 'share_list' list.id %}" >
----

That will cause a server error until we define the URL:

----
django.core.urlresolvers.NoReverseMatch: Reverse for 'share_list' with
arguments '(1,)' and keyword arguments '{}' not found. 0 pattern(s) tried: []
----

The middle layer: controller views, and urls
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[role="sourcecode"]
.lists/urls.py
[source,python]
----
urlpatterns = patterns('',
    url(r'^new$', 'lists.views.new_list', name='new_list'),
    url(r'^(\d+)/$', 'lists.views.view_list', name='view_list'),
    url(r'^(\d+)/share$', 'lists.views.share_list', name='share_list'),
)
----

And now we'll need to define at least a placeholder view:

----
django.core.exceptions.ViewDoesNotExist: Could not import
lists.views.share_list. View does not exist in module lists.views.
----

Something like this:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def share_list(request, list_id):
    pass
----

That'll get our unit tests happy again.

----
OK
----

Next we should start writing a new unit test for our list sharing view

[role="sourcecode"]
.lists/tests/test_views.py
[source,python]
----
class ShareListTest(TestCase):

    def test_sharing_a_list_via_post(self):
        sharee = User.objects.create(email='share.with@me.com')
        list_ = List.objects.create()
        self.client.post(
            '/lists/%d/share' % (list_.id),
            {'email': 'share.with@me.com'}
        )
        self.assertIn(list_.shared_with.all(), sharee)
-----

Gives

-----
ValueError: The view lists.views.share_list didn't return an HttpResponse object.
-----

That suggests another test:


[role="sourcecode"]
.lists/tests/test_views.py
[source,python]
----
    def test_redirects_after_POST(self):
        sharee = User.objects.create(email='share.with@me.com')
        list_ = List.objects.create()
        self.client.post(
            '/lists/%d/share' % (list_.id),
            {'email': 'share.with@me.com'}
        )
        self.assertRedirects(response, list_.get_absolute_url())
----


So we can start with a couple of boilerplate lines to do the redirect:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def share_list(request, list_id):
    list_ = List.objects.get(id=list_id)
    return redirect(list_)
----


And we get:

----
AttributeError: 'List' object has no attribute 'shared_with'
----

//TODO -- this might be a good place to jump off and talk about triangulation, test permissions


The inside layer: models
^^^^^^^^^^^^^^^^^^^^^^^^

And now we step down one more level to the model layer. 

[role="sourcecode"]
.lists/tests/test_models.py
[source,python]
----
class ListModelTest(TestCase):

    def test_get_absolute_url(self):
        [...]


    def test_can_optionally_set_owner(self):
        [...]


    def test_can_share_with_another_user(self):
        list_ = List.objects.create()
        user = User.objects.create(email='a@b.com')
        list_.shared_with.add('a@b.com')
        list_in_db = List.objects.get(id=list_.id)
        self.assertIn(user, list_in_db.shared_with.all())
----

Gives

----
AttributeError: 'List' object has no attribute 'shared_with'
AttributeError: 'List' object has no attribute 'shared_with'
----

We start fixing in models

[role="sourcecode"]
.lists/models.py
[source,python]
----
    shared_with = models.ManyToManyField(settings.AUTH_USER_MODEL)
----

That won't quite work:


----
CommandError: One or more models did not validate:
lists.list: Accessor for field 'owner' clashes with related m2m field
'User.list_set'. Add a related_name argument to the definition for 'owner'.
lists.list: Accessor for m2m field 'shared_with' clashes with related field
'User.list_set'. Add a related_name argument to the definition for
'shared_with'.
----

Adding the related_name field:

[role="sourcecode"]
.lists/models.py
[source,python]
----
    shared_with = models.ManyToManyField(
        settings.AUTH_USER_MODEL, related_name='shared_lists'
    )
----

Some database errors:

----
django.db.utils.OperationalError: no such table: lists_list_shared_with
----

We add a schema migration:

[role="sourcecode"]
.lists/tests.py
[source,python]
----
python3 manage.py schemamigration --auto lists
----

Now we're down to just one failure in our view tests:

----
FAIL: test_sharing_a_list_via_post (lists.tests.test_views.ShareListTest)
[...]
AssertionError: <User: User object> not found in []

Ran 36 tests in 0.156s

FAILED (failures=1)
----


[role="sourcecode"]
.lists/models.py
[source,python]
----
def share_list(request, list_id):
    list_ = List.objects.get(id=list_id)
    list_.shared_with.add(request.POST['email'])
    return redirect(list_)
----

Are we there?

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.test_sharing*]

AssertionError: 'Shared with' not found in 'Forbidden (403)\nCSRF verification failed. Request aborted.\nMore information is available with DEBUG=True.'
----


Ah, not quite.  One last thing:


[role="sourcecode"]
.lists/templates/list.html
[source,html]
----
        <form class="form-inline" method="POST" action="{% url 'share_list' list.id %}" >
            {% csrf_token %}
            <input name="email" placeholder="your@friends-email.com" />
        </form>
----

Now the Ft gets further, up to Oni trying to see the list:

----
    self.browser.find_element_by_link_text('Get help').click()
[...]
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"link text","selector":"Get help"}' ; Stacktrace: 
----

Fix that in my_lists.html


And one final thing:

----
AssertionError: 'List owner: edith@email.com' not found in 'Superlists\nMy lists\nLog out\nLogged in as oniciferous@email.com\nYour To-Do list\n1: Get help\nShared with\noniciferous@email.com\nShare this list:'
----

Identify list owners:

[role="sourcecode"]
.lists/templates/list.html
[source,html]
----
{% block table %}
    <table id="id_list_table">
        {% for item in list.item_set.all %}
            <tr><td>{{ forloop.counter }}: {{ item.text }}</td></tr>
        {% endfor %}
    </table>
    <p>List owner: {{ list.owner.email }}</p>
{% endblock %}
----

And we get to a pass!

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.test_sharing*]

Ran 1 test in 21.886s

OK
----



Possible things to include:
~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Introduce page pattern?
* Admin site?
* django notifications?
* email notifications?
* talk about security/perms testing -- checking negatives.
* error-handling, what if user doesn't exist


