[[chapter_making_deployment_production_ready]]
Getting to a Production-Ready Deployment
----------------------------------------

NOTE: 'Update on 2018-01-12' -- Have just made some changes to the order
    of things between this and the last chapter...


((("deployment", "getting to production-ready", id="DPprodready10")))In
this chapter we'll make some changes to our site to move to a configuration
that's more production-ready.  As we make each change, we'll use the tests to
tell us whether things are still working.


What's wrong with our hacky deployment?  A few things: we need to host
our app on the "normal" port 80 and we shouldn't use the Django dev server for
production; it's not designed for "real-life" loads.    Instead, we'll use the
popular combination of the Nginx web server and the Gunicorn Python/WSGI
server.

((("DEBUG settings")))Our
'settings.py' currently has also `DEBUG=True`, and that's strongly recommended
against for production (you don't want users staring at debug tracebacks of
your code when your site errors, for example).  

We want our site to start up automatically whenever the server reboots.
For that we'll write a Systemd config file.


Switching to Nginx
~~~~~~~~~~~~~~~~~~

Installation
^^^^^^^^^^^^


((("Nginx", "installation")))We'll
need a web server, and all the cool kids are using Nginx these days,
so we will too.  Having fought with Apache for many years, I can tell
you it's a blessed relief in terms of the readability of its config files,
if nothing else!

Installing Nginx on my server was a matter of doing an `apt install`, and I could
then see the default Nginx "Hello World" screen:

[role="server-commands"]
[subs="specialcharacters,quotes"]
----
elspeth@server:$ *sudo apt install nginx*
elspeth@server:$ *sudo systemctl start nginx*
----

Now you should be able to go to the normal port-80 URL address of your server, and see the
"Welcome to nginx" page at this point, as in <<nginx-it-works>>.

TIP: If you don't see it, it may be because your firewall does not open port 80
    to the world. On AWS, for example, you may need to configure the "security
    group" for your server to open port 80.

[[nginx-it-works]]
.Nginx--it works!
image::images/twp2_0901.png["The default 'Welcome to nginx!' page"]




Using the FT to Confirm the Domain Works and Nginx Is Running
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

((("Nginx", "confirming operation of")))We can also confirm that if
we run the FT without specifying port 8000, we see them fail again--one of them
in particular should now mention Nginx:

[role="small-code against-server"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*STAGING_SERVER=superlists-staging.ottg.eu python manage.py test functional_tests*]
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: [id="id_new_item"]
[...]
AssertionError: 'To-Do' not found in 'Welcome to nginx!'
----

Next we'll configure the Nginx web server to talk to Django
   

Simple Nginx Configuration
^^^^^^^^^^^^^^^^^^^^^^^^^^

((("Nginx", "configuring")))We
create an Nginx config file to tell it to send requests for our staging
site along to Django. A minimal config looks like this:

[role="sourcecode"]
.server: /etc/nginx/sites-available/superlists-staging.ottg.eu
====
[source,nginx]
----
server {
    listen 80;
    server_name superlists-staging.ottg.eu;

    location / {
        proxy_pass http://localhost:8000;
    }
}
----
====

This config says it will only listen for our staging domain, and will "proxy"
all requests to the local port 8000 where it expects to find Django
waiting to respond.

I saved this to a file called 'superlists-staging.ottg.eu' inside the
'/etc/nginx/sites-available' folder.

NOTE: Not sure how to edit a file on the server?  There's always vi, which I'll
    keep encouraging you to learn a bit of, but perhaps today is already too
    full of new things. Try the relatively beginner-friendly 
    http://www.howtogeek.com/howto/42980/the-beginners-guide-to-nano-the-linux-command-line-text-editor/[`nano`]
    instead. Note you'll also need to use `sudo` because the file is in a
    system folder.

We then add it to the enabled sites for the server by creating a symlink to it:

[role="server-commands small-code"]
[subs="specialcharacters,quotes"]
----
# check our env var is still there
elspeth@server:$ *echo $SITENAME*
superlists-staging.ottg.eu
elspeth@server:$ *sudo ln -s ../sites-available/$SITENAME /etc/nginx/sites-enabled/$SITENAME*

# check our symlink has worked:
elspeth@server:$ *readlink -f /etc/nginx/sites-enabled/$SITENAME*
/etc/nginx/sites-available/superlists-staging.ottg.eu
----

That's the Debian/Ubuntu preferred way of saving Nginx configurations--the real
config file in 'sites-available', and a symlink in 'sites-enabled'; the idea is
that it makes it easier to switch sites on or off.

We also may as well remove the default "Welcome to nginx" config, to avoid any
[keep-together]#confusion#:

[role="server-commands"]
[subs="specialcharacters,quotes"]
----
elspeth@server:$ *sudo rm /etc/nginx/sites-enabled/default*
----

And now to test it.  First we reload nginx and restart our server:

[role="server-commands"]
[subs="specialcharacters,quotes"]
----
elspeth@server:$ *sudo systemctl reload nginx*
elspeth@server:$ *pwd*
/home/elspeth/sites/superlists-staging.ottg.eu
elspeth@server:$ *./virtualenv/bin/python manage.py runserver 8000*
----

And then we try our FTs, again, without the port 8000:

[role="small-code"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*STAGING_SERVER=superlists-staging.ottg.eu ./manage.py test functional_tests --failfast*]
[...]
AssertionError: 'To-Do' not found in 'DisallowedHost at /'
----

Oops, something's gone wrong.  But once again, by running our FTs frequently,
we're able to identify the problem early, before we've changed too many things.
In this case all we've done is added Nginx into the loop, so we know it's the
cause of the problem.

The solution turns out to be that, by default, Nginx strips out the Host
headers from requests it forwards, and it makes it "look like" they came
from localhost after all.  We can tell it to forward on the original host
header by adding the `proxy_set_header` directive:


[role="sourcecode"]
.server: /etc/nginx/sites-available/superlists-staging.ottg.eu
====
[source,nginx]
----
server {
    listen 80;
    server_name superlists-staging.ottg.eu;

    location / {
        proxy_pass http://localhost:8000;
        proxy_set_header Host $host;
    }
}
----
====

Reload nginx once more:

[role="server-commands"]
[subs="specialcharacters,quotes"]
----
elspeth@server:$ *sudo systemctl reload nginx*
----

TIP: ((("Nginx", "troubleshooting")))((("troubleshooting", "Nginx operation")))If
    you ever find Nginx isn't behaving as expected, try the command
    `sudo nginx -t`, which does a config test, and will warn you of any 
    problems in your configuration files.


And then we try our FTs, again, without the port 8000:

[role="small-code"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*STAGING_SERVER=superlists-staging.ottg.eu ./manage.py test functional_tests --failfast*]
[...]

...
 ---------------------------------------------------------------------
Ran 3 tests in 10.718s

OK
----

Hooray!

NOTE: I also had to edit '/etc/nginx/nginx.conf' and uncomment a line saying
    `server_names_hash_bucket_size 64;` to get my long domain name to work.
    You may not have this problem; Nginx will warn you when you do a `reload`
    if it has any trouble with its config files.



Switching to Gunicorn
~~~~~~~~~~~~~~~~~~~~~

((("production-ready deployment", "using Gunicorn", secondary-sortas="Gunicorn")))((("Gunicorn", "switching to")))Do
you know why the Django mascot is a pony?  The story is that Django
comes with so many things you want: an ORM, all sorts of middleware,
the admin site... "What else do you want, a pony?" Well, Gunicorn stands
for "Green Unicorn", which I guess is what you'd want next if you already
had a pony...

[role="server-commands"]
[subs="specialcharacters,quotes"]
----
elspeth@server:$ *./virtualenv/bin/pip install gunicorn*
----

Gunicorn will need to know a path to a WSGI server, which is usually
a function called `application`.  Django provides one in 'superlists/wsgi.py':


[role="server-commands"]
[subs="specialcharacters,quotes"]
----
elspeth@server:$ *./virtualenv/bin/gunicorn superlists.wsgi:application*
2013-05-27 16:22:01 [10592] [INFO] Starting gunicorn 0.19.7.1
2013-05-27 16:22:01 [10592] [INFO] Listening at: http://127.0.0.1:8000 (10592)
[...]
----

But if we run the functional tests, once again you'll see that they are
warning us of a problem. The test for adding list items passes happily, but the
test for layout + styling fails.  Good job, tests!

[role="small-code"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*STAGING_SERVER=superlists-staging.ottg.eu python manage.py test functional_tests*]
[...]
AssertionError: 106.5 != 512 within 10 delta
FAILED (failures=1)
----

And indeed, if you take a look at the site, you'll find the CSS is all broken,
as in <<site-with-broken-css>>.

The reason that the CSS is broken is that although the Django dev server will
serve static files magically for you, Gunicorn doesn't.  Now is the time to
tell Nginx to do it instead.


[[site-with-broken-css]]
.Broken CSS
image::images/twp2_1001.png["The site is up, but CSS is broken"]


One step forward, one step backward, but once again we've identified the problem
nice and early. Moving on!

TIP: If you see a "502 - Bad Gateway", it's probably because you forgot to
    restart Gunicorn.



Getting Nginx to Serve Static Files
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

((("production-ready deployment", "serving static files with Nginx")))((("Nginx", "serving static files with")))((("static files", "serving with Nginx")))First
we run `collectstatic` to copy all the static files to a folder where 
Nginx can find them:

[role="server-commands"]
[subs="specialcharacters,macros"]
----
elspeth@server:$ pass:quotes[*./virtualenv/bin/python manage.py collectstatic --noinput*]
[...]
15 static files copied to '/home/elspeth/sites/superlists-staging.ottg.eu/static'
elspeth@server:$ pass:quotes[*ls static/*]
base.css  bootstrap
----

Now we tell Nginx to start serving those static files for us, by
adding a second `location` directive to the config:

[role="sourcecode"]
.server: /etc/nginx/sites-available/superlists-staging.ottg.eu
[source,nginx]
----
server {
    listen 80;
    server_name superlists-staging.ottg.eu;

    location /static {
        alias /home/elspeth/sites/superlists-staging.ottg.eu/static;
    }

    location / {
        proxy_pass http://localhost:8000;
        proxy_set_header Host $host;
    }
}
----

Reload Nginx and restart Gunicorn...

[role="server-commands"]
[subs="specialcharacters,quotes"]
----
elspeth@server:$ *sudo systemctl reload nginx*
elspeth@server:$ *./virtualenv/bin/gunicorn superlists.wsgi:application*
----

And if you take another manual look at your site, things should look much
healthier. Let's rerun our FTs:

[role="small-code"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*STAGING_SERVER=superlists-staging.ottg.eu python manage.py test functional_tests*]
[...]

...
 ---------------------------------------------------------------------
Ran 3 tests in 10.718s

OK
----

Phew.


Switching to Using Unix Sockets
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


((("production-ready deployment", "switching to Unix domain sockets")))((("Unix domain sockets")))((("Nginx", "switching to Unix domain sockets")))((("Gunicorn", "switching to Unix domain sockets")))When
we want to serve both staging and live, we can't have both servers trying
to use port 8000.  We could decide to allocate different ports, but that's a
bit arbitrary, and it would be dangerously easy to get it wrong and start
the staging server on the live port, or vice versa.

A better solution is to use Unix domain sockets--they're like files on disk,
but can be used by Nginx and Gunicorn to talk to each other.  We'll put our
sockets in '/tmp'.  Let's change the proxy settings in Nginx:

[role="sourcecode"]
.server: /etc/nginx/sites-available/superlists-staging.ottg.eu
====
[source,nginx]
----
server {
    listen 80;
    server_name superlists-staging.ottg.eu;

    location /static {
        alias /home/elspeth/sites/superlists-staging.ottg.eu/static;
    }

    location / {
        proxy_set_header Host $host;
        proxy_pass http://unix:/tmp/superlists-staging.ottg.eu.socket;
    }
}
----
====

Now we restart Gunicorn, but this time telling it to listen on a socket instead
of on the default port:

[role="server-commands"]
[subs="specialcharacters,quotes"]
----
elspeth@server:$ *sudo systemctl reload nginx*
elspeth@server:$ *./virtualenv/bin/gunicorn --bind \
    unix:/tmp/superlists-staging.ottg.eu.socket superlists.wsgi:application*
----


And again, we rerun the functional test again, to make sure things still pass:

[role="small-code"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*STAGING_SERVER=superlists-staging.ottg.eu python manage.py test functional_tests*]
[...]
OK
----

A couple more steps!


Switching DEBUG to False and Setting ALLOWED_HOSTS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~




((("DEBUG settings")))((("production-ready deployment", "DEBUG=false and ALLOWED_HOSTS")))((("ALLOWED_HOSTS")))((("security issues and settings", "ALLOWED_HOSTS")))((("tracebacks")))Django's
+DEBUG+ mode is all very well for hacking about on your own server, but
leaving those pages full of tracebacks available
http://bit.ly/SuvluV[isn't secure].

You'll find the `DEBUG` setting at the top of 'settings.py'. When we set this
to `False`
And, once again, we restart Gunicorn and run the FT to check that things still work.

NOTE: Don't commit these changes on the server. At the moment this is just a 
    hack to get things working, not a change we want to keep in our repo. In
    general, to keep things simple, I'm only going to do Git commits from the
    local PC, using `git push` and `git pull` when I need to sync them up to
    the server.


One more test run to reassure ourselves that things still work?

[role="small-code"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*STAGING_SERVER=superlists-staging.ottg.eu python manage.py test functional_tests*]
[...]
OK
----

Good.



Using Systemd to Make Sure Gunicorn Starts on Boot
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


((("production-ready deployment", "using Systemd for automatic booting/reloading")))((("Systemd")))((("Gunicorn", "automatic booting/reloading of")))Our
final step is to make sure that the server starts up Gunicorn automatically
on boot, and reloads it automatically if it crashes.  On Ubuntu, the way to do
this is using Systemd:

[role="sourcecode"]
.server: /etc/systemd/system/gunicorn-superlists-staging.ottg.eu.service
====
[source,bash]
----
[Unit]
Description=Gunicorn server for superlists-staging.ottg.eu

[Service]
Restart=on-failure  <1>
User=elspeth  <2>
WorkingDirectory=/home/elspeth/sites/superlists-staging.ottg.eu  <3>
ExecStart=/home/elspeth/sites/superlists-staging.ottg.eu/virtualenv/bin/gunicorn \
    --bind unix:/tmp/superlists-staging.ottg.eu.socket \
    superlists.wsgi:application  <4>

[Install]
WantedBy=multi-user.target <5>
----
====

Systemd is joyously simple to configure (especially if you've ever had the
dubious pleasure of writing an `init.d` script), and is fairly
self-explanatory. 

<1> `Restart=on-failure` will restart the process automatically if it crashes.

<2> `User=elspeth` makes the process run as the "elspeth" user.

<3> `WorkingDirectory` sets the current working directory.

<4> `ExecStart` is the actual process to execute.  We use the ++\++ line
    continuation characters to split the full command over multiple lines,
    for readability, but it could all go on one line.

<5> `WantedBy` in the `[Install]` section is what tells Systemd we want this
    service to start on boot.


Systemd scripts live in '/etc/systemd/system', and their names must end in
'.service'. 

Now we tell Systemd to start Gunicorn with the `systemctl` command:

[role="server-commands"]
[subs="specialcharacters,quotes"]
----
# this command is necessary to tell Systemd to load our new config file
elspeth@server:$ *sudo systemctl daemon-reload*
# this command tells Systemd to always load our service on boot
elspeth@server:$ *sudo systemctl enable gunicorn-superlists-staging.ottg.eu*
# this command actually starts our service
elspeth@server:$ *sudo systemctl start gunicorn-superlists-staging.ottg.eu*
----

(You should find the `systemctl` command responds to tab completion, including
of the service name, by the way.)

Now we can rerun the FTs to see that everything still works. You can even test
that the site comes back up if you reboot the server!


.More Debugging Tips
*******************************************************************************

- ((("debugging", "Systemd")))Check
the Systemd logs for using 
  `sudo journalctl -u gunicorn-superlists-staging.ottg.eu`.

- You can ask Systemd to check the validity of your service configuration:
  `systemd-analyze verify /path/to/my.service`.

- Remember to restart both services whenever you make changes.

- If you make changes to the Systemd config file, you need to 
  run `daemon-reload` before `systemctl restart` to see the effect
  of your changes.

*******************************************************************************


Saving Our Changes: Adding Gunicorn to Our requirements.txt
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

((("requirements.txt")))((("Gunicorn", "adding to requirements.txt")))Back
in the 'local' copy of your repo, we should add Gunicorn to the list
of packages we need in our virtualenvs:

[subs="specialcharacters,quotes"]
----
$ *pip install gunicorn*
$ *pip freeze | grep gunicorn >> requirements.txt*
$ *git commit -am "Add gunicorn to virtualenv requirements"*
$ *git push* 
----


NOTE: ((("Windows", "Gunicorn support")))On
    Windows, at the time of writing, Gunicorn would `pip install` quite
    happily, but it wouldn't actually work if you tried to use it.  Thankfully
    we only ever run it on the server, so that's not a problem. And, Windows
    support is
    http://stackoverflow.com/questions/11087682/does-gunicorn-run-on-windows[being discussed]...


There are a few more debugging tips in the sidebar that follows.


.Server Debugging Tips
*******************************************************************************
((("server provisioning")))((("debugging", "server provisioning")))Deployments
are tricky!  If ever things don't go exactly as expected, here are
a few tips and things to look out for:


- I'm sure you already have, but double-check that each file is exactly where
  it should be and has the right contents--a single stray character can make
  all the difference.

- Nginx error logs go into '/var/log/nginx/error.log'.

- You can ask Nginx to "check" its config using the `-t` flag: `nginx -t`

- Make sure your browser isn't caching an out-of-date response.  Use
  Ctrl-Refresh, or start a new private browser window.

- This may be clutching at straws, but I've sometimes seen inexplicable
  behaviour on the server that's only been resolved when I fully restarted it
  with a `sudo reboot`.

((("", startref="SScode09")))If
you ever get completely stuck, there's always the option of blowing away
your server and starting again from scratch!  It should go faster the second
time...

*******************************************************************************

Thinking About Automating
~~~~~~~~~~~~~~~~~~~~~~~~~




((("production-ready deployment", "preparing for automation", id="PRDauto10")))((("automated deployment", "preparing for")))Let's
recap our provisioning and deployment procedures:

Provisioning::
1. Assume we have a user account and home folder
2. `add-apt-repository ppa:deadsnakes/ppa && apt update`
3. `apt install nginx git python3.6 python3.6-venv`
4. Add Nginx config for virtual host
5. Add Systemd job for Gunicorn


Deployment::
1. Create directory structure in '~/sites'
2. Pull down source code.
3. Start virtualenv in 'virtualenv'
4. `pip install -r requirements.txt`
5. `manage.py migrate` for database
6. `collectstatic` for static files
7. Set `DEBUG = False` and `ALLOWED_HOSTS` in 'settings.py'
8. Restart Gunicorn job
9. Run FTs to check everything works


Assuming we're not ready to entirely automate our provisioning process, how
should we save the results of our investigation so far?  I would say that 
the Nginx and Systemd config files should probably be saved somewhere, in
a way that makes it easy to reuse them later.  Let's save them in a new
subfolder in our repo.


Saving Templates for Our Provisioning Config Files
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

((("templates", "saving for provisioning config files", id="TMPprovision10")))First, we create the subfolder:

[subs="specialcharacters,quotes"]
----
$ *mkdir deploy_tools*
----

[role="pagebreak-before"]
Here's a generic template for our Nginx config:

[role="sourcecode"]
.deploy_tools/nginx.template.conf
====
[source,nginx]
----
server {
    listen 80;
    server_name SITENAME;

    location /static {
        alias /home/elspeth/sites/SITENAME/static;
    }

    location / {
        proxy_set_header Host $host;
        proxy_pass http://unix:/tmp/SITENAME.socket;
    }
}
----
====

And here's one for the Gunicorn Sytemd service:

[role="sourcecode"]
.deploy_tools/gunicorn-systemd.template.service
====
[source,bash]
----
[Unit]
Description=Gunicorn server for SITENAME

[Service]
Restart=on-failure
User=elspeth
WorkingDirectory=/home/elspeth/sites/SITENAME/source
ExecStart=/home/elspeth/sites/SITENAME/virtualenv/bin/gunicorn \
    --bind unix:/tmp/SITENAME.socket \
    superlists.wsgi:application

[Install]
WantedBy=multi-user.target
----
====

Now it's easy for us to use those two files to generate
a new site, by doing a find and replace on  `SITENAME`.

For the rest, just keeping a few notes is OK. Why not keep
them in a file in the repo too?

[role="sourcecode"]
.deploy_tools/provisioning_notes.md
====
[source,rst]
----
Provisioning a new site
=======================

## Required packages:

* nginx
* Python 3.6
* virtualenv + pip
* Git

eg, on Ubuntu:

    sudo add-apt-repository ppa:deadsnakes/ppa
    sudo apt update
    sudo apt install nginx git python36 python3.6-venv

## Nginx Virtual Host config

* see nginx.template.conf
* replace SITENAME with, e.g., staging.my-domain.com

## Systemd service

* see gunicorn-systemd.template.service
* replace SITENAME with, e.g., staging.my-domain.com

## Folder structure:
Assume we have a user account at /home/username

/home/username
└── sites
    └── SITENAME
         ├── database
         ├── source
         ├── static
         └── virtualenv
----
====

We can do a commit for those:

[subs="specialcharacters,quotes"]
----
$ *git add deploy_tools*
$ *git status* # see three new files
$ *git commit -m "Notes and template config files for provisioning"*
----

[role="pagebreak-before"]
((("", startref="PRDauto10")))((("", startref="TMPprovision10")))Our
source tree will now look something like this:

[subs=""]
----
.
├── deploy_tools
│   ├── gunicorn-systemd.template.service
│   ├── nginx.template.conf
│   └── provisioning_notes.md
├── functional_tests
│   ├── [...]
├── lists
│   ├── __init__.py
│   ├── models.py
│   ├── [...]
│   ├── static
│   │   ├── base.css
│   │   └── bootstrap
│   │       ├── [...]
│   ├── templates
│   │   ├── base.html
│   │   ├── [...]
│   ├── tests.py
│   ├── urls.py
│   └── views.py
├── manage.py
├── requirements.txt
├── static
│   ├── [...]
├── superlists
│   ├── [...]
└── virtualenv
    ├── [...]

----



Saving Our Progress
~~~~~~~~~~~~~~~~~~~


Being able to run our FTs against a staging server can be very reassuring.
But, in most cases, you don't want to run your FTs against your "real" server.
In order to "save our work", and reassure ourselves that the production server
will work just as well as the real server, we need to make our deployment
process repeatable.((("", startref="DPprodready10")))

Automation is the answer, and it's the topic of the next chapter.

[role="pagebreak-before less_space"]
.Production-Readiness for Server Deployments
*******************************************************************************

((("production-ready deployment", "best practices for")))A
few things to think about when trying to build a production-ready server [keep-together]#environment#:

Don't use the Django dev server in production::
    ((("Gunicorn", "benefits of")))Something
like Gunicorn or uWSGI is a better tool for running Django; they
    will let you run multiple workers, for example.

Don't use Django to serve your static files::
    ((("static files", "serving with Nginx")))There's
no point in using a Python process to do the simple job of serving
    static files. Nginx can do it, but so can other web servers like Apache or
    uWSGI.


Check your settings.py for dev-only settings::
    `DEBUG=True` and `ALLOWED_HOSTS` are the two we looked at, but you will
    probably have others (we'll see more when we start to send emails from the
    server).

Security::
    ((("security issues and settings", "server security")))((("Platform-As-A-Service (PaaS)")))A
serious discussion of server security is beyond the scope of this book,
    and I'd warn against running your own servers without learning a good bit
    more about it. (One reason people choose to use a PaaS to host their
    code is that it means a slightly fewer security issues to worry about.)
    If you'd like a place to start, here's as good a place as any:
    https://plusbryan.com/my-first-5-minutes-on-a-server-or-essential-security-for-linux-servers[My first 5 minutes on a server].
    I can definitely recommend the eye-opening experience of installing
    fail2ban and watching its logfiles to see just how quickly it picks up on
    random drive-by attempts to brute force your SSH login.  The internet is a
    dangerous place!
    
*******************************************************************************

