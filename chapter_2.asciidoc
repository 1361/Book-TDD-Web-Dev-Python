Chapter 2 - A basic front page for our site
-------------------------------------------

Let's adapt our test, which currently checks for the default Django "it worked"
page, and check instead for some of the things we want to see on the front
page.

Oh, it's probably time to reveal what kind of web app we're building. Well, I
thought we'd go for... a "to-do" list site!  In doing so I'm very much
following fashion - a few years ago all web tutorials were about building a
blog.  Then it was forums and polls, nowadays it's to-do lists.

The reason is that a to-do list is a really nice example. At its most basic
it is very simple indeed -- just a list of text strings -- so it's easy to
get a "minimum viable" todo app up and running.  But it can be extended in all
sorts of ways -- different persistence models, adding deadlines, reminders,
sharing with other users, and improving the client-side UI. It should allow
me to demonstrate all of the main aspects of web programming^*^, and how you
apply TDD to them.

`*` 'With the possible exception of payments integration.  But that's a world
of pain whose discovery I prefer to leave you, dear readers, to enjoy on your
own.  Let's concentrate on phase 1, "collect underpants", first.'


Using the FT to scope out a minimum viable app
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Tests that use Selenium let us drive a real web browser, so they really let
us see how the application functions from the user's point of view. That's 
why they're called ``Functional tests'' -- although different people can get
a bit precious about terminology, and might prefer the terms 'Acceptance tests'
or 'Integration tests'.  The main point is that we're looking at how the
application functions from the outside.

This means that Functional can form a sort of specification for your
application -- they tend to track what you might call a 'User Story' -- and
follow how the user might work with a particular feature and how the app
should respond to them.

So FTs should have a human-readable story that we can follow, in the shape of
comments that accompany the test code.  When creating a new FT, we can write
the comments first, to capture the key points of the User Story.

Let's do that for our minimum viable to-do list -- all it needs to do is let
the user enter items, and remember them for them for their next visit.

Open up tests.py and write a story a bit like this one:


[source,python]
----

from selenium import webdriver

browser = webdriver.Firefox()

# Edith has heard about a cool new online to-do app. She goes
# to check out its homepage
browser.get('http://localhost:8000')

# She notices the page title and header mention to-do lists
assert 'To-Do' in browser.title

# She is invited to enter a to-do item straight away

# She types "Buy peacock feathers" into a text box (Edith's hobby
# is tying fly-fishing lures)

# When she hits enter, the page updates, and now the page lists
# "1: Buy peacock feathers" as an item in a to-do list

# There is still a text box inviting her to add another item. She
# enters "Use peacock feathers to make a fly" (Edith is very methodical)

# The page updates again, and now shows both items on her list

# Edith wonders whether the site will remember her list. Then she sees
# that the site has generate a unique URL for her -- there is some
# explanatory text to that effect.

# She visits that URL - her to-do list is still there.

browser.quit()
----

You'll notice that, apart from writing the test out as comments, I've
updated the `assert` to look for the word ``To-Do'' instead of ``Django''.
That means we expect the test to fail now.  Let's try running it

First, start up the server:

....
python manage.py runserver
....

And then, in another shell, run the tests:
....
$ python tests.py 
[09/Feb/2013 11:22:21] "GET / HTTP/1.1" 200 1957
Traceback (most recent call last):
  File "tests.py", line 10, in <module>
    assert 'To-Do' in browser.title
AssertionError
....

That's what we call an ``expected fail'', which is actually good news - not
quite as good as a test that passes, but at least it's failing for the right
reason; we can have some confidence we've at least written the test correctly.

The Python standard library's unittest module
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

But there's a couple of little annoyances we should probably deal with.
Firstly, the message "AssertionError" isn't very helpful - it would be nice
if the test told us what it actually found as the browser title.  Also, it's
left a Firefox window hanging around the desktop, it would be nice if it would
clear them up for us automatically.

One option would be to use the second parameter to the `assert` keyword,
something like

[source,python]
----
assert 'To-Do' in browser.title, "To-Do not found in browser title, it was " + browser.title
----

And we could also use a `try/finally` to clean up the old Firefox window. But
these sorts of problems are quite common in testing, and there are some ready-
made solutions for us in the standard library's `unittest` module. Let's use
that!

[source,python]
----

import unittest
from selenium import webdriver

class NewVisitorTest(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()

    def tearDown(self):
        self.browser.quit()

    def test_can_start_a_todo_list_and_get_a_url_for_it(self):

        # Edith has heard about a cool new online to-do app. She goes
        # to check out its homepage
        self.browser.get('http://localhost:8000')

        # She notices the page title and header mention to-do lists
        self.assertIn('To-Do', self.browser.title)

        # She is invited to enter a to-do item straight away
        self.fail('Finish the test!')


        # When she hits enter, the page updates, and now the page lists
        [...rest of comments as before]
----

Things to note:

* Tests are organised into classes, which inherit from `unittest.TestCase`.

* The main body of the test is in a method called 
  `test_can_start_a_todo_list_and_get_a_url_for_it` -- any method
  whose name starts with `test_` is a test method, and will be run by the test
  runner

* The `setUp` and `tearDown` methods.  These are special methods which get run
  before and after each test.  I'm using them to start and stop our browser --
  note that they're a bit like a try/except, in that tearDown will get run even
  if there's an error during the test itself.  No more Firefox windows left
  lying around!

* We use `self.assertIn` instead of just `assert` to make our test assertions.
  `unittest` provides lots helper functions like this to make test assertions,
  like `assertEqual`, `assertTrue`, `assertFalse`, and lots more.

* Finally, in the `if __name__ == '__main__'` clause (if you've not seen it
  before, that's how a Python script checks if it's been executed from the
  command-line, rather than just imported by another script), we call 
  `unittest.main()`, which launches the unittest test runner, which will
  automatically find test classes and methods and run them

Let's try it!
....
$ python tests.py 
F
======================================================================
FAIL: test_can_start_a_todo_list_and_get_a_url_for_it (__main__.NewVisitorTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "tests.py", line 19, in test_can_start_a_todo_list_and_get_a_url_for_it
    self.assertIn('To-Do', self.browser.title)
AssertionError: 'To-Do' not found in u'Welcome to Django'

----------------------------------------------------------------------
Ran 1 test in 4.747s

FAILED (failures=1)
....

That's a bit nicer isn't it? It tidied up our Firefox window, it gives us a
nicely formatted report of how many tests were run and how many failed, and
the `assertIn` has given us a helpful error message with useful debugging info.
Bonzer!

This is a nice point to do a commit - it's a nicely self-contained change.

TODO: add commmit message




    raise ImproperlyConfigured("settings.DATABASES is improperly configured. "
django.core.exceptions.ImproperlyConfigured: settings.DATABASES is improperly configured. Please supply the ENGINE value. Check settings documentation for more details.
....

OK, so we got a load of ugly traceback, but at least there were no syntax
errors.  That's good enough for a commit:

....
git diff
git add fts/tests.py
git rm tests.py
git commit -m"Migrate functional test into Django FT app"
....

The tests drive our development, so let's look into this `ImproperlyConfigured`
error. It's telling to us to look at settings, which is the
`mysite/settings.py` file.  Open it up and scroll to the line which defines
`DATABASES` and `ENGINE`:

[source,python]
----
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.', # Add 'postgresql_psycopg2', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': '',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}
----

Helpful comments!  Let's use `sqlite3`, which is the quickest to set up.  We can
always change it later.

[source,python]
----
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', 
        'NAME': '',                      # Or path to database file if using sqlite3.
----

And let's try running the tests again:
....
$ python manage.py test
Creating test database for alias 'default'...
..........................................................................................................................................................................................................................................................................................................................................................s........................................................................
----------------------------------------------------------------------
Ran 419 tests in 17.679s

OK (skipped=1)
Destroying test database for alias 'default'...
(book)51:mysite harry$ 
....

419 tests!  We didn't write that many!  Well, with the generic `manage.py test`
command, Django runs all the test for every app you have installed, including
all of its core modules.  Let's get it to run just the test that we've put in
our new `fts` app:

....
$ python manage.py test fts
Traceback (most recent call last):
  File "manage.py", line 10, in <module>
    execute_from_command_line(sys.argv)

    [...lots more traceback]

    raise ImproperlyConfigured("App with label %s could not be found" % app_label)
django.core.exceptions.ImproperlyConfigured: App with label fts could not be found
....

BUT IT'S RIGHT THERE! Unfortunately, just running the `startapp` command and putting
what is obviously an app into your project folder isn't quite enough for Django to
automatically recognise your app.  You have to tell it that you really mean it,
and add it to `settings.py`. Open it up and look for a variable called
`INSTALLED_APPS`:


[source,python]
----
INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Uncomment the next line to enable the admin:
    # 'django.contrib.admin',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
    'fts',
)
----

We'll add `fts` to the bottom of the list.  Don't forget the trailing comma - it may
not be required, but one day you'll be really annoyed when you forget it and Python
concatenates two strings on different lines...

[source,python]
----
INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Uncomment the next line to enable the admin:
    # 'django.contrib.admin',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
    'fts',
)
----

oh balls. undebuggable 'problem loading page' crap
