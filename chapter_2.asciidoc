Chapter 2 - A basic home page with a unit test
-------------------------------------------~~~

Let's adapt our test, which currently checks for the default Django "it worked"
page, and check instead for some of the things we want to see on the front
page.

Oh, it's probably time to reveal what kind of web app we're building. Well, I
thought we'd go for... a "to-do" list site!  In doing so I'm very much
following fashion - a few years ago all web tutorials were about building a
blog.  Then it was forums and polls, nowadays it's to-do lists.

The reason is that a to-do list is a really nice example. At its most basic
it is very simple indeed -- just a list of text strings -- so it's easy to
get a "minimum viable" todo app up and running.  But it can be extended in all
sorts of ways -- different persistence models, adding deadlines, reminders,
sharing with other users, and improving the client-side UI. It should allow
me to demonstrate all of the main aspects of web programming^*^, and how you
apply TDD to them.

`*` 'With the exception of payments integration.  That's a world
of pain whose discovery I prefer to leave you, dear readers, to enjoy on your
own.  Let's concentrate on phase 1, "collect underpants", first.'


Using the FT to scope out a minimum viable app
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Tests that use Selenium let us drive a real web browser, so they really let
us see how the application functions from the user's point of view. That's 
why they're called ``Functional tests'' -- although different people can get
a bit precious about terminology, and might prefer the terms 'Acceptance tests'
or 'Integration tests'.  The main point is that we're looking at how the
application functions from the outside.

This means that Functional can form a sort of specification for your
application -- they tend to track what you might call a 'User Story' -- and
follow how the user might work with a particular feature and how the app
should respond to them.

So FTs should have a human-readable story that we can follow, in the shape of
comments that accompany the test code.  When creating a new FT, we can write
the comments first, to capture the key points of the User Story.

Let's do that for our minimum viable to-do list -- all it needs to do is let
the user enter items, and remember them for them for their next visit.

Open up 'functional_tests.py' and write a story a bit like this one:


[source,python]
----

from selenium import webdriver

browser = webdriver.Firefox()

# Edith has heard about a cool new online to-do app. She goes
# to check out its homepage
browser.get('http://localhost:8000')

# She notices the page title and header mention to-do lists
assert 'To-Do' in browser.title

# She is invited to enter a to-do item straight away

# She types "Buy peacock feathers" into a text box (Edith's hobby
# is tying fly-fishing lures)

# When she hits enter, the page updates, and now the page lists
# "1: Buy peacock feathers" as an item in a to-do list

# There is still a text box inviting her to add another item. She
# enters "Use peacock feathers to make a fly" (Edith is very methodical)

# The page updates again, and now shows both items on her list

# Edith wonders whether the site will remember her list. Then she sees
# that the site has generate a unique URL for her -- there is some
# explanatory text to that effect.

# She visits that URL - her to-do list is still there.

browser.quit()
----

You'll notice that, apart from writing the test out as comments, I've
updated the `assert` to look for the word ``To-Do'' instead of ``Django''.
That means we expect the test to fail now.  Let's try running it

First, start up the server:

....
python manage.py runserver
....

And then, in another shell, run the tests:
....
$ python functional_tests.py 
[09/Feb/2013 11:22:21] "GET / HTTP/1.1" 200 1957
Traceback (most recent call last):
  File "functional_tests.py", line 10, in <module>
    assert 'To-Do' in browser.title
AssertionError
....

That's what we call an ``expected fail'', which is actually good news - not
quite as good as a test that passes, but at least it's failing for the right
reason; we can have some confidence we've at least written the test correctly.


Our first Django app, and our first unit test
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Django encourages you to structure your code into ``apps'': one project can
have many apps, you might re-use the same app in different projects, and you
can use third-party apps developed by other people.

So, let's start an app for our lists:

....
$ python manage.py startapp lists
....

That will create a folder at 'awesomelists/lists', next to
'awesomelists/awesomelists', and within it a number of placeholder files for
models, views and, of immediate interest to us, tests.

....
$ tree -I *.pyc
.
├── awesomelists
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
├── lists
│   ├── __init__.py
│   ├── models.py
│   ├── tests.py
│   └── views.py
├── manage.py
└── functional_tests.py
....


Unit tests, and how they differ from Functional tests
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As so often, the line between unit tests and functional tests can become a
little blurry.  The basic distinction, though, is that functional tests test
the application from the outside, from point of view of the user, whereas unit
tests test the application from the inside, from the point of view of the
programmer.

The TDD methodology I'm trying to teach then, follows this sort of a pattern:

1.  Start by writing a **functional test**, describing the new functionality
    from the point of view of the user

2.  Once we have a functional test that fails, we start to think about how
    to write code that can get it to pass (or at least to get past its current
    failure)

3.  We now use one or more **unit tests** to define how we want our code to
    behave -- the idea is that each line of production code we write should be 
    tested by (at least) one of our unit tests

4.  Once we have a failing unit test, we can write our application code.  We
    may iterate between steps 3 and 4 a few times

5.  Now we can re-run our functional tests and see if they pass, or get a
    little further.  That may prompt us to write some new unit tests, and
    some new code, and so on.

I would draw you a flowchart, but it really feels like over-egging the pudding!
Best to explain through demonstration.

You can see that, all the way through, the functional tests are driving what 
development we do from a high level, while the unit tests drive what we do
at a low level.

Now that may seem slightly redundant, and sometimes it can seem that way, but
functional tests and unit tests do really have very different objectives, and
they will usually end up looking quite different.  Functional tests should help
you build an application with the right functionality, and guarantee you never
accidentally break it.  Unit tests should help you to write code that's clean
and bug free.

Enough theory for now, let's see how it looks in practice.


Unit testing in Django
~~~~~~~~~~~~~~~~~~~~~~

Let's see how to write a unit test for our homepage view then. Open up
'lists/tests.py', and you'll see something like this:

[source,python]
----
"""
This file demonstrates writing tests using the unittest module. These will pass
when you run "manage.py test".

Replace this with more appropriate tests for your application.
"""

from django.test import TestCase


class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.assertEqual(1 + 1, 2)
----

Django has helpfully put a little place-holder in there for us to write tests
with.  You'll see it's using a special class `TestCase`, and a special method
`self.assertEqual`. These are based on the Python standard library `unittest`,
which I'll talk more about later, but in essence it's no different from the
straightforward kind of test we wrote for our functional test.

Let's use that as a starting point to work from.  You've already seen that the
TDD cycle involves starting with a test that fails, then writing code to get it
to pass. Refining this idea, even before we can write a test for our code, we
want to know that the test we're writing is definitely being run.  So let's
start by making a test that we know will fail, by deliberately breaking the
default addition test.

[source,python]
----
        self.assertEqual(1 + 1, 3)
----

Now let's invoke Django's test runner - as usual, it's a 'manage.py' command,
`python manage.py test`:

....
$ python manage.py test
Creating test database for alias 'default'...
Traceback (most recent call last):
  File "manage.py", line 10, in <module>
    execute_from_command_line(sys.argv)

    [...lots more traceback]

    raise ImproperlyConfigured("settings.DATABASES is improperly configured. "
django.core.exceptions.ImproperlyConfigured: settings.DATABASES is improperly
configured. Please supply the ENGINE value. Check settings documentation for
more details.
....

Yuk, some pretty ugly traceback, but the message is actually quite helpful -
the test runner is complaining that it can't run tests until we set up some
kind of database. Let's do that, in the 'mysite/settings.py' file.  Open it up
and scroll to the line which defines `DATABASES` and `ENGINE`:

[source,python]
----
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.', # Add 'postgresql_psycopg2', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': '',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}
----

Helpful comments!  Let's use `sqlite3`, which is the quickest to set up.  We
can always change it later.

[source,python]
----
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', 
        'NAME': '',                      # Or path to database file if using sqlite3.
----

And let's try running the tests again:
....
$ python manage.py test
Creating test database for alias 'default'...
..........................................................................................................................................................................................................................................................................................................................................................s........................................................................
----------------------------------------------------------------------
Ran 419 tests in 17.679s

OK (skipped=1)
Destroying test database for alias 'default'...
....


419 tests!  We didn't write that many!  Well, with the generic `manage.py test`
command, Django runs all its own unit tests, as well as any tests for your
apps.

More worryingly though, we didn't see a test failure.  Assuming there have been
no changes in the fundamental properties of mathematics, 1 + 1 should not equal 3.
Where is our failing test?

Django will let you run tests for an individual app, by specifying it as a
command-line parameter. Let's try running just the tests for our app, `lists`:


....
Traceback (most recent call last):
  File "source/chapter_3/awesomelists/manage.py", line 10, in <module>
    execute_from_command_line(sys.argv)
    [lots of traceback]
    raise ImproperlyConfigured("App with label %s could not be found" % app_label)
django.core.exceptions.ImproperlyConfigured: App with label lists could not be found
....


BUT IT'S RIGHT THERE! Unfortunately, just running the `startapp` command and
having what is obviously an app in your project folder isn't quite enough
for Django to automatically recognise your app.  You have to tell it that you
really mean it, and add it to 'settings.py' as well. Open it up and look for a
variable called `INSTALLED_APPS`, to which we'll add `lists`:


[source,python]
----
INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Uncomment the next line to enable the admin:
    # 'django.contrib.admin',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
    'lists',
)
----

You can see there's lots of apps already in there by default (they're some of
the apps that caused all those 419 tests earlier).  We just need to add ours,
`lists`, to the bottom of the list.  Don't forget the trailing comma - it may
not be required, but one day you'll be really annoyed when you forget it and
Python concatenates two strings on different lines...

Now we can try running the tests for `lists` again:

....
$ python manage.py test lists
Creating test database for alias 'default'...
F
======================================================================
FAIL: test_basic_addition (lists.tests.SimpleTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/harry/Dropbox/book/source/chapter_3/awesomelists/lists/tests.py", line 16, in test_basic_addition
    self.assertEqual(1 + 1, 3)
AssertionError: 2 != 3

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (failures=1)
Destroying test database for alias 'default'...
....

That's more like it!  You can reassure yourself that it gets run as part of the
general command, `manage.py test` as well, and you should see it now runs 420
tests instead of 419.

This is a good point for a commit:

....
git status 
# should show you awesomelists/settings.py has changed and lists/ is untracked

git add awesomelists/settings.py
git add lists
git diff --cached # will show you the diff that you're about to commit
git commit -m"Add app for lists, with deliberately failing unit test"
....



Django's MVC, urls and view functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Django is broadly structured along a classic 'Model-View-Controller (MVC)'
pattern.  Well, broadly.  It definitely has models, but its views are more like
a controller, and it's the templates that are actually the view part, but the
general idea is there.  If you're interested, you can look up the finer points of
the discussion in the Django documentation.

But, irrespective of any of that, like any website, Django's main job is to
decide what to do when a user asks for a particular URL on our site.  Django's
workflow goes something like this:

* A **request** comes in for a particular **URL**
* Django uses some rules to decide which **view** function should deal with the
  request (this is referred to as 'resolving' the URL)
* The view function processes the request and returns an HTTP **response**

So we want to test two thing:

1.  Can we resolve the URL for the root of the site (``/'') to a particular view
    function we've made?
2.  Can we make this view function return some HTML which will get the 
    functional test to pass?

So let's write tests for those two things.  We can start with the second,
because it's slightly more straightforward.  Open up 'lists/tests.py', and
change the addition test to something like this:


[source,python]
----
from django.test import TestCase
from django.http import HttpRequest

from lists.views import home_page


class HomePageViewTest(TestCase):

    def test_home_page_returns_correct_html(self):
        request = HttpRequest()
        response = home_page(request)
        self.assertIn(response.content, '<title>To-Do lists</title>')
----

What's going on in this test?  We create an `HttpRequest` object and pass it to
a function called `home_page`, which we're expecting to find in `lists.views`. We
get a response from the view (you won't be surprised to hear that this object
is of a class called `HttpResponse`).  Then, we assert that the `content` of
the response -- which is the HTML that we send to the user -- contains a
particular `<title>` tag, with the word ``To-Do'' in -- because that's what we
specified in our functional test.

Does that make sense?  If not, sometimes it helps to work through tests backwards:

* Our functional test wants a home page with "To-Do" in the title
* So, we look at our response content, and say that it has the correct HTML tag
  to make that work
* To get the response, we call a our view function with an HTTP request, simulating
  what the user would do
* Finally, we're expecting to find that view function inside 'lists/views.'

You can see how the unit test is driven by the functional test, but it's also
much closer to the actual code -- we're thinking like programmers now, rather than
thinking like users.  We're also much more closely tied into our implementation - 
we're using Django's own classes, as well as functions we're planning to write.

Let's run the tests now and see how we get on:

....
$ python manage.py test lists

Traceback (most recent call last):
  File "source/chapter_2/awesomelists/manage.py", line 10, in <module>
    execute_from_command_line(sys.argv)
    [... lots of traceback]
    from lists.views import home_page
ImportError: cannot import name home_page
....

It's a very predictable failure, we tried to import something we haven't even
written yet, but it's still good news. Now that we have both a failing
functional test and a failing unit test, we have the testing goat's full
blessing to code away.


At last!  We actually write some application code!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


The django module that takes care of resolving URLs is called `urlresolvers`, and
it contains a function called `reverse`, whose job is 

Now let's







Things to note:

* Tests are organised into classes, which inherit from `unittest.TestCase`.

* The main body of the test is in a method called 
  `test_can_start_a_todo_list_and_get_a_url_for_it` -- any method
  whose name starts with `test_` is a test method, and will be run by the test
  runner

* The `setUp` and `tearDown` methods.  These are special methods which get run
  before and after each test.  I'm using them to start and stop our browser --
  note that they're a bit like a try/except, in that tearDown will get run even
  if there's an error during the test itself.  No more Firefox windows left
  lying around!

* We use `self.assertIn` instead of just `assert` to make our test assertions.
  `unittest` provides lots helper functions like this to make test assertions,
  like `assertEqual`, `assertTrue`, `assertFalse`, and so on.  `self.fail` just
  fails no matter what, producing the error message given. I'm using it as
  a reminder to finish the test

* Finally, in the `if __name__ == '__main__'` clause (if you've not seen it
  before, that's how a Python script checks if it's been executed from the
  command-line, rather than just imported by another script), we call 
  `unittest.main()`, which launches the unittest test runner, which will
  automatically find test classes and methods and run them

Let's try it!
....
$ python functional_tests.py 
F
======================================================================
FAIL: test_can_start_a_todo_list_and_get_a_url_for_it (__main__.NewVisitorTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "functional_tests.py", line 19, in test_can_start_a_todo_list_and_get_a_url_for_it
    self.assertIn('To-Do', self.browser.title)
AssertionError: 'To-Do' not found in u'Welcome to Django'

----------------------------------------------------------------------
Ran 1 test in 4.747s

FAILED (failures=1)
....

That's a bit nicer isn't it? It tidied up our Firefox window, it gives us a
nicely formatted report of how many tests were run and how many failed, and
the `assertIn` has given us a helpful error message with useful debugging info.
Bonzer!

This is a nice point to do a commit - it's a nicely self-contained change. Do
a `git status` -- that should assure you that the only file that has changed is
'functional_tests.py'.  Then do a `git diff`, which should tell you that 'test.py' has
changed quite substantially:
....
$ git diff
diff --git a/functional_tests.py b/functional_tests.py
index d333591..b0f22dc 100644
--- a/functional_tests.py
+++ b/functional_tests.py
@@ -1,5 +1,43 @@
+import unittest
 from selenium import webdriver
-browser = webdriver.Firefox()
-browser.get('http://localhost:8000')
-assert 'Django' in browser.title
-browser.quit()
+
+class NewVisitorTest(unittest.TestCase):
+
+    def setUp(self):
+        self.browser = webdriver.Firefox()
+
+    def tearDown(self):
+        self.browser.quit()
[...]
....

Now let's do a `git commit -a`, and add a sensible commit message, like 
``First FT specced out in comments, and now uses unittest''.



The root 'urls.py' for the whole site is in the 'awesomelists/awesomelists'
folder. Let's go take a look:


[source,python]
----
from django.conf.urls import patterns, include, url

# Uncomment the next two lines to enable the admin:
# from django.contrib import admin
# admin.autodiscover()

urlpatterns = patterns('',
    # Examples:
    # url(r'^$', 'awesomelists.views.home', name='home'),
    # url(r'^awesomelists/', include('awesomelists.foo.urls')),

    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    # url(r'^admin/', include(admin.site.urls)),
)
----


A `url` entry starts with a regular expression that defines which urls it
applies to, and goes on to say where it should send those request -- either to
a dot-notation encoded function like `awesomelists.views.home`, or maybe to another
`urls.py` file somewhere else using `include`.

Let's hijack the first entry, `'r^$'`, which basically means an empty URL,
AKA the root of the site. Instead of the dot-notation, let's define a real 
function to handle that request.  For now, all we want to do is return
some basic HTML, so let's do that:

[source,python]
----
from django.conf.urls import patterns, include, url
from django.http import HttpResponse

# Uncomment the next two lines to enable the admin:
# from django.contrib import admin
# admin.autodiscover()

HOME_PAGE = '''
<html>
    <head><title>To-Do App</title></head>
</html>'''

def get_home_page(request):
    return HttpResponse(HOME_PAGE)

urlpatterns = patterns('',
    # Examples:
    url(r'^$', get_home_page),
    # url(r'^awesomelists/', include('awesomelists.foo.urls')),

    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    # url(r'^admin/', include(admin.site.urls)),
)
----

That's a minimal homepage view function -- it takes a one argument called
request, and returns an `HttpResponse` containing some HTML text.  Some pretty
minimal HTML text in this case, but in TDD we only ever write enough code to
fix the current failing test, which in this case is about the browser `title`.

Let's see if it worked:

....
$ python functional_tests.py 
F
======================================================================
FAIL: test_can_start_a_todo_list_and_get_a_url_for_it (__main__.NewVisitorTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "functional_tests.py", line 20, in test_can_start_a_todo_list_and_get_a_url_for_it
    self.fail('Finish the test!')
AssertionError: Finish the test!

----------------------------------------------------------------------
Ran 1 test in 1.675s

FAILED (failures=1)
....

Looks like it, that's another 'expected fail'.

Not too bad! We converted our tests to using `unittest`, learnt about
`urls.py`, and we wrote a minimal view function to render some HTML for our
front page.  We can probably call that a Chapter -- as soon as we've done
a commit, of course.

....
git status # should show urls.py has changed
git diff # review the changed lines in urls.py
git commit -a # will automatically add those changes to your commit
....

