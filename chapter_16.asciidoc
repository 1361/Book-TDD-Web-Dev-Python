[[python-mocks-chapter]]
Testing external dependencies using mocks
-----------------------------------------

In this chapter we'll start testing the parts of our code that send emails.
In the FT, you saw that Django gives us a way of retrieving any emails it
sends by using the `mail.outbox` attribute.  But in this chapter, I want
to demonstrate a very important testing technique called 'mocking', so for
the purpose of these unit tests, we'll pretend that this nice Django shortcut
doesn't exist.

NOTE: Am I telling you not to use django's `mail.outbox`.  No, use it, it's a 
    neat shortcut.  But I want to teach mocks because they're a useful
    general-purpose tool for unit testing external dependencies.  You
    may not always be using Django! And even if you are, you may not
    be sending email -- any interaction with a third-party API is a good
    candidate for testing with mocks.


Before we start: getting the basic plumbing in
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's just get a basic view and url set up first.  We can do so with a simple
test that our new URL for sending the login email should eventually redirect
back to the home page:


[role="dofirst-ch15l001"]
.accounts/tests/test_views.py
[source,python]
----
from django.test import TestCase


class SendLoginEmailViewTest(TestCase):

    def test_redirects_to_home_page(self):
        response = self.client.post('/accounts/send_login_email', data={
            'email': 'edith@example.com'
        })
        self.assertRedirects(response, '/')
----
//ch16l003


Wire up the `include` in 'superlists/urls.py', plus the url to
'accounts/urls.py', and get the test passing with something a bit like this:


[role="dofirst-ch15l002"]
.accounts/views.py
[source,python]
----
from django.core.mail import send_mail
from django.shortcuts import redirect

def send_login_email(request):
    return redirect('/')
----
//ch16l003


I've added the import of the `send_mail` function as a placeholder for now.

[subs="specialcharacters,quotes"]
----
$ *python manage.py test accounts*
[...]
Ran 1 test in 0.015s

OK
----

OK now we have a starting point, let's get mocking!


Mocking manually, aka monkey-patching
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When we call `send_mail` in real life we expect Django to be making a
connection to our email provider, and sending an actual email across
the public Internet.  That's not something we want to happen in our tests.
It's a similar problem whenever you have code that has external side-effects
-- calling an API, sending out a tweet or an SMS or whatever it may be. In
our unit tests, we don't want to be sending out real tweets or API calls across
the internet.  But we would still like a way of testing that our code is
correct. Mocksfootnote:[I'm using the generic term "mock", but testing enthusiasts
like to distinguish other types of a general class of test tools called "Test
Doubles", including spies, fakes and stubs.  The differences don't really
matter for this book, but if you want to get into the nitty-gritty, check out
this article by Martin Fowler:
http://martinfowler.com/articles/mocksArentStubs.html#TheDifferenceBetweenMocksAndStubs["Mocks aren't stubs"]]
are the answer.



((("monkeypatching")))
Actually one of the great things about Python is that its dynamic nature makes
it very easy to do things like mocking, or what's sometimes called
monkey-patching.  Let's suppose that, as a first step,
we want to get to some code that invokes `send_mail` with the right subject
line, from address, and to address.  That would look something like this:


[role="sourcecode skipme"]
.accounts/views.py
[source,python]
----
def send_login_email(request):
    email = request.POST['email']
    '''
    send_mail(
        'Your login link for Superlists',
        'body text tbc',
        'noreply@superlists',
        [email],
    )
    '''
    return redirect('/')
----


How can we test this, without calling the 'real' `send_mail` function?  The
answer is that we can tell Python to replace the `send_mail` function with
a fake version of it, at runtime, before we invoke the `send_login_email` view.
Check this out:


[role="sourcecode"]
.accounts/tests/test_views.py (ch16l005)
[source,python]
----
from django.test import TestCase
import accounts  #<2>

class SendLoginEmailViewTest(TestCase):
    [...]

    def test_sends_mail_to_address_from_post(self):
        self.send_mail_called = False

        def fake_send_mail(subject, body, from_email, to_list):  #<1>
            self.send_mail_called = True
            self.subject = subject
            self.body = body
            self.from_email = from_email
            self.to_list = to_list

        accounts.views.send_mail = fake_send_mail  # <2>

        self.client.post('/accounts/send_login_email', data={
            'email': 'edith@example.com'
        })


        self.assertTrue(self.send_mail_called)
        self.assertEqual(self.subject, 'Your login link for Superlists')
        self.assertEqual(self.from_email, 'noreply@superlists')
        self.assertEqual(self.to_list, ['edith@example.com'])
----

<1> We define a `fake_send_mail` function, which looks like the real
    `send_mail` function, but all it does is save some information
    about how it was called, using some variables on `self`.


<2> Then, before we execute the code under test by doing the `self.client.post`,
    we swap out the real `accounts.views.send_mail` with our fake version --
    it's as simple as just assigning it.  


It's important to realise that there isn't really anything magical going on here,
we're just taking advantage of Python's dynamic nature and scoping rules.

Up until we actually invoke a function, we can modify the variables it has
access to, as long as we get into the right namespace (that's why we import the
top-level accounts module, to be able to get down to the `acccounts.views` module,
which is the scope that the `accounts.views.send_login_email` function will run
in).

This isn't even something that only works inside unit tests.  You can do this
kind of "monkey-patching" in any kind of Python code!


That may take a little time to sink in.  See if you can convince yourself that
it's not all totally crazy, before reading a couple of bits of further detail.

* Why do we use `self` as a way of passing information around? It's just a 
    convenient variable that's available both inside the scope of the
    `fake_send_mail` function and outside of it.   We could use any mutable
    object, like a list or a dictionary, as long as we are making in-place 
    changes to an existing variable that exists outside our fake function.
    (feel free to have a play around with different ways of doing this, if
    you're curious, and see what works and doesn't work.)
    
* The "before" is critical! I can't tell you how many times I've sat
    there, wondering why a mock isn't working, only to realise that I didn't
    mock before I called the code under test.



Let's see if our hand-rolled mock object will let us test-drive some code:

[subs="specialcharacters,quotes"]
----
$ *python manage.py test accounts*
[...]
    self.assertTrue(self.send_mail_called)
AssertionError: False is not true
----

So let's call send_mail, naively:


[role="sourcecode"]
.accounts/views.py
[source,python]
----
def send_login_email(request):
    send_mail()
    return redirect('/')
----


That gives:

[subs="specialcharacters,macros"]
----
TypeError: fake_send_mail() missing 4 required positional arguments: 'subject',
'body', 'from_email', and 'to_list'
----

Looks like our monkeypatch is working!  We've called `send_mail`, and it's gone
into our `fake_send_mail` function, which wants more arguments.  Let's try
this:


[role="sourcecode"]
.accounts/views.py
[source,python]
----
def send_login_email(request):
    send_mail('subject', 'body', 'from_email', ['to email'])
    return redirect('/')
----

That gives:

----
    self.assertEqual(self.subject, 'Your login link for Superlists')
AssertionError: 'subject' != 'Your login link for Superlists'
----

That's working pretty well.  And now we can work all the way through to
something like this:


[role="sourcecode"]
.accounts/views.py
[source,python]
----
def send_login_email(request):
    email = request.POST['email']
    send_mail(
        'Your login link for Superlists',
        'body text tbc',
        'noreply@superlists',
        [email]
    )
    return redirect('/')
----
//006


and passing tests!


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test accounts*]

Ran 2 tests in 0.016s

OK
----




The Python Mock Library
~~~~~~~~~~~~~~~~~~~~~~~

The popular 'mock' package was added to the standard library as part of Python
3.3.footnote:[If you're using Python 3.2, upgrade!  Or if you're stuck with it,
`pip3 install mock`, and use `from mock` instead of `from unittest.mock`.]
It provides a magical object called a `Mock`, which is a bit like the Sinon
mock objects we saw in the last chapter, only much cooler.  Try this out
in a Python shell:


[role='skipme']
----
>>> from unittest.mock import Mock
>>> m = Mock()
>>> m.any_attribute
<Mock name='mock.any_attribute' id='140716305179152'>
>>> type(m.any_attribute)
<class 'unittest.mock.Mock'>
>>> m.any_method()
<Mock name='mock.any_method()' id='140716331211856'>
>>> m.foo()
<Mock name='mock.foo()' id='140716331251600'>
>>> m.called
False
>>> m.foo.called
True
>>> m.bar.return_value = 1
>>> m.bar(42, var='thing')
1
>>> m.bar.call_args
call(42, var='thing')
----

A magical object, that responds to any request for an attribute or method call
with other mocks, that you can configure to return specific values for its
calls, and that allows you to inspect what it was called with?  Sounds like a
useful thing to be able to use in our unit tests!


Using unittest.mock to our email-sending view
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

And as if that weren't enough, the `mock` module also provides a helper
function called `patch`, which we can use to do the monkeypatching we did
by hand earlier.


[role="sourcecode"]
.accounts/tests/test_views.py (ch16l007)
[source,python]
----
from django.test import TestCase
from unittest.mock import patch
[...]

    @patch('accounts.views.send_mail')
    def test_sends_mail_to_address_from_post(self, mock_send_mail):
        self.client.post('/accounts/send_login_email', data={
            'email': 'edith@example.com'
        })

        self.assertEqual(mock_send_mail.called, True)
        (subject, body, from_email, to_list), kwargs = mock_send_mail.call_args
        self.assertEqual(subject, 'Your login link for Superlists')
        self.assertEqual(from_email, 'noreply@superlists')
        self.assertEqual(to_list, ['edith@example.com'])

----

If you re-run the tests, you'll see they still pass.  And since we're always
suspicious of any test that still passes after a big change, let's deliberately
break it just to see:



[role="sourcecode"]
.accounts/tests/test_views.py (ch16l008)
[source,python]
----
        self.assertEqual(to_list, ['schmedith@example.com'])
----

And let's add a little debug print to our view

[role="sourcecode"]
.accounts/views.py (ch16l009)
[source,python]
----
def send_login_email(request):
    email = request.POST['email']
    print(type(send_mail))
    send_mail(
        [...]
----

And run the tests again:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test accounts*]
Creating test database for alias 'default'...
<class 'function'>
.<class 'unittest.mock.MagicMock'>
F
======================================================================
FAIL: test_sends_mail_to_address_from_post
(accounts.tests.test_views.SendLoginEmailViewTest)
 ---------------------------------------------------------------------
[...]
    self.assertEqual(to_list, ['schmedith@example.com'])
AssertionError: Lists differ: ['edith@example.com'] != ['schmedith@example.com']
[...]

Ran 2 tests in 0.024s

FAILED (failures=1)
----

Sure enough, the tests fail.  And we can see just before the failure 
message, that when we print the `type` of the `send_mail` function,
in the first unit test it's a normal function, but in the second unit
test we're seeing a mock object.

Let's reset our code back to where it was and do a little recap:

[role="sourcecode dofirst-ch16l010"]
.accounts/tests/test_views.py (ch16l011)
[source,python]
----
@patch('accounts.views.send_mail')  #<1>
def test_sends_mail_to_address_from_post(self, mock_send_mail):  #<2>
    self.client.post('/accounts/send_login_email', data={
        'email': 'edith@example.com'  #<3>
    })

    self.assertEqual(mock_send_mail.called, True)  #<4>
    (subject, body, from_email, to_list), kwargs = mock_send_mail.call_args  #<5>
    self.assertEqual(subject, 'Your login link for Superlists')
    self.assertEqual(from_email, 'noreply@superlists')
    self.assertEqual(to_list, ['edith@example.com'])
----

<1> the `patch` decorator takes a dot-notation name of an object to monkeypatch.
    That's the equivalent of manually replacing the `send_mail` in
    `accounts.views`.  The advantage of the decorator is that, firstly, it
    automatically replaces the target with a mock.  And secondly, it
    automatically puts the original object back at the end!  (otherwise, the
    object stays monkeypatched for the rest of the test run, which might cause
    problems in other tests) 

<2> `patch` then injects the mocked object into the test as an argument to
    the test method.  We can choose whatever name we want for it, but I
    usually use a convention of `mock_` plus the original name of the 
    object.

<3> We call our function under test as usual, but everything inside this
    test method has our mock applied to it, so the view won't call the
    real `send_mail` object, it'll be seeing `mock_send_mail` instead.

<4> And we can now make assertions about what happened to that mock object
    during the test.  We can see it was called...

<5> And we can also unpack its various positional and keyword call arguments,
    and examine what it was called with.


All crystal-clear? No? Don't worry, we'll do a couple more tests with mocks, to
see if they start to make more sense as we use them more.


Getting the FT a little farther along
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


First let's get back to our FT and see where it's failing.

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.test_login*]
[...]
AssertionError: 'Check your email' not found in 'Superlists\nEnter email to log in:\nStart a new To-Do list'
----

Submitting the email address currently has no effect, because the form isn't
sending the data anywhere.  Let's wire it up in 'base.html'


[role="sourcecode small-code"]
.lists/templates/base.html
[source,html]
----
<form class="navbar-form navbar-right" method="POST" action="{% url 'send_login_email' %}">
----

Does that help?  Nope, same error.  Why?  Because we're not actually displaying
a success message after we send the user an email.   Let's add a test for that:


Testing the Django messages framework
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


We'll use Django's "messages framework", which is often used to display
ephemeral "success" or "warning" messages to show the results of an action.
Have a look at the 
https://docs.djangoproject.com/en/1.9/ref/contrib/messages/[django messages docs]
if you haven't come across it already.

.TODO: sidebar on the Django Messages Framework
**************************************************
bla

**************************************************

Testing Django messages is a bit contorted (so much so that, at work, we used
to test them with mocks.  You can test anything with mocks!  But, as we'll
learn from <<isolation-chapter,later chapters>>, Mocks come at a price, so
it's often worth trying to test without mocks whenever you can).  We have to
pass `follow=True` to the test client to tell it to get the page after the 
302-redirect, and examine its context for a list of messages.  Here's what it
looks like:


[role="sourcecode"]
.accounts/tests/test_views.py (ch16l013)
[source,python]
----
    def test_adds_success_message(self):
        response = self.client.post('/accounts/send_login_email', data={
            'email': 'edith@example.com'
        }, follow=True)

        message = list(response.context['messages'])[0]
        self.assertEqual(
            message.message,
            "Check your email, we've sent you a link you can use to log in."
        )
        self.assertEqual(message.tags, "success")
----

That gives:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test accounts*]
[...]
    message = list(response.context['messages'])[0]
IndexError: list index out of range
----

And we can get it passing with:


[role="sourcecode"]
.accounts/views.py (ch16l014)
[source,python]
----
from django.contrib import messages
[...]

def send_login_email(request):
    [...]
    messages.success(
        request,
        "Check your email, we've sent you a link you can use to log in."
    )
    return redirect('/')
----


What happens next in the functional test?  Ah.  Still nothing.  We
need to actually add the messages to the page.  Something like this:


[role="sourcecode"]
.lists/templates/base.html (ch16l015)
[source,html]
----
      [...]
      </nav>

      {% if messages %}
        <div class="row">
          <div class="col-md-8">
            <ul class="messages">
              {% for message in messages %}
                {% if message.tags == 'success' %}
                  <li class="alert alert-success">
                {% else %}
                  <li class="alert alert-warning">
                {% endif %}"
                  {{ message }}
                </li>
              {% endfor %}
            </ul>
          </div>
        </div>
      {% endif %}
----


Now do we get a little further?  Yes!

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test accounts*]
[...]
Ran 5 tests in 0.023s

OK

$ pass:quotes[*python3 manage.py test functional_tests.test_login*]
[...]
AssertionError: 'Use this link to log in' not found in 'body text tbc'
----


We need to fill out the body text of the email, with a link that the
user can use to log in.

Let's just cheat for now though, by changing the value in the view:


[role="sourcecode"]
.accounts/views.py
[source,python]
----
    send_mail(
        'Your login link for Superlists',
        'Use this link to log in',
        'noreply@superlists',
        [email]
    )
----

That gets the FT a little further,


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.test_login*]
[...]
AssertionError: Could not find url in email body:
Use this link to log in
----


We're going to have to build some kind of URL!  Let's build one that, again,
just cheats:


Start on the login view
^^^^^^^^^^^^^^^^^^^^^^^

[role="sourcecode"]
.accounts/tests/test_views.py (ch16l017)
[source,python]
----
class LoginViewTest(TestCase):

    def test_redirects_to_home_page(self):
        response = self.client.get('/accounts/login?token=abcd123')
        self.assertRedirects(response, '/')
----

We're imaging we'll pass the token in as a GET parameter, after the `?`.
It doesn't need to do anything for now.


I'm sure you can find your way through to getting a basic URL and view in, via
errors like these:

no URL:

----
AssertionError: 404 != 302 : Response didn't redirect as expected: Response
code was 404 (expected 302)
----


No view:

----
AttributeError: module 'accounts.views' has no attribute 'login'
----


Broken view:

----
ValueError: The view accounts.views.login didn't return an HttpResponse object.
It returned None instead.
----

OK!

----
Ran 6 tests in 0.029s

OK
----



Checking we send the user a token
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We've tested the email subject, from and to fields.  The body is the part that
will have to include a token or URL they can use to log in.  Let's spec out
two tests for that:





# TODO - merge up stuff from old 16 to new one

old content follows...


Checking the View Actually Logs the User In
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

((("authentication", "login view", id="ix_authenticationlogin", range="startofrange")))
But our `authenticate` view also needs to actually log the user in by
calling the Django `auth.login` function, if `authenticate` returns a user. 
Then it needs to return something other than an empty response--since this is
an Ajax view, it doesn't need to return HTML, just an "OK" string will do:


[role="sourcecode"]
.accounts/tests/test_views.py (ch16l011)
[source,python]
----
from django.contrib.auth import get_user_model
from django.test import TestCase
from unittest.mock import patch
User = get_user_model()  #<1>


class LoginViewTest(TestCase):
    @patch('accounts.views.authenticate')
    def test_calls_authenticate_with_assertion_from_post(
        [...]

    @patch('accounts.views.authenticate')
    def test_returns_OK_when_user_found(
        self, mock_authenticate
    ):
        user = User.objects.create(email='a@b.com')
        user.backend = ''  # required for auth_login to work
        mock_authenticate.return_value = user
        response = self.client.post('/accounts/login', {'assertion': 'a'})
        self.assertEqual(response.content.decode(), 'OK')
----

<1> I should explain this use of `get_user_model` from `django.contrib.auth`.
    Its job is to find the project's user model, and it works whether you're
    using the standard user model or a custom one (like we will be).

That test covers the desired response.  Now test that the user actually gets
logged in correctly.  We can do that by inspecting the Django test client, to
see if the session cookie has been set correctly.

TIP: Check out the 
https://docs.djangoproject.com/en/1.8/topics/auth/default/#how-to-log-a-user-in[Django 
docs on authentication] at this point.


[role="sourcecode"]
.accounts/tests/test_views.py (ch16l012)
[source,python]
----
from django.contrib.auth import get_user_model, SESSION_KEY
[...]

    @patch('accounts.views.authenticate')
    def test_gets_logged_in_session_if_authenticate_returns_a_user(
        self, mock_authenticate
    ):
        user = User.objects.create(email='a@b.com')
        user.backend = ''  # required for auth_login to work
        mock_authenticate.return_value = user
        self.client.post('/accounts/login', {'assertion': 'a'})
        self.assertEqual(self.client.session[SESSION_KEY], str(user.pk))  #<1>


    @patch('accounts.views.authenticate')
    def test_does_not_get_logged_in_if_authenticate_returns_None(
        self, mock_authenticate
    ):
        mock_authenticate.return_value = None
        self.client.post('/accounts/login', {'assertion': 'a'})
        self.assertNotIn(SESSION_KEY, self.client.session)  #<2>
----

<1> The Django test client keeps track of the session for its user.  For
    the case where the user gets authenticated successfully, we check that
    their user ID (the primary key, or pk) is associated with their session.

<2> In the case where the user should not be authenticated, the `SESSION_KEY`
    should not appear in their session.


.Django Sessions: How a User's Cookies Tell the Server She Is pass:[<span class="keep-together">Authenticated</span>]
**********************************************************************

'Being an attempt to explain sessions, cookies, and authentication in Django.'
((("sessions")))
((("cookies")))
((("authentication","in Django", sortas="Django")))
((("Django", "authentication in")))

Because HTTP is stateless, servers need a way of recognising different clients
with 'every single request'. IP addresses can be shared, so the usual
solution is to give each client a unique session ID, which it will store in a
cookie, and submit with every request.  The server will store that ID somewhere
(by default, in the database), and then it can recognise each request that
comes in as being from a particular client.

If you log in to the site using the dev server, you can actually take a look at
your session ID by hand if you like.  It's stored under the key `sessionid` by
default. See <<session-cookie-screenshot>>.

[[session-cookie-screenshot]]
.Examining the session cookie in the Debug toolbar
image::images/twdp_1601.png[scale="80"]

These session cookies are set for all visitors to a Django site, whether
they're logged in or not.

When we want to recognise a client as being a logged-in and authenticated user,
again, rather asking the client to send their username and password with every
single request, the server can actually just mark that client's session as
being an authenticated session, and associate it with a user ID in its
database.

A session is a dictionary-like data structure, and the user ID is stored under
the key given by `django.contrib.auth.SESSION_KEY`.  You can check this out
in a `manage.py` console if you like:

[role="skipme small-code"]
[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py shell*]
[...]
In [1]: from django.contrib.sessions.models import Session

# substitute your session id from your browser cookie here
In [2]: session = Session.objects.get(
    session_key="8u0pygdy9blo696g3n4o078ygt6l8y0y"
)

In [3]: print(session.get_decoded())
{'_auth_user_id': 'harry@mockmyid.com', '_auth_user_backend':
'accounts.authentication.PersonaAuthenticationBackend'}
----

You can also store any other information you like on a user's session,
as a way of temporarily keeping track of some state. This works for
non-logged-in users too.  Just use `request.session` inside any
view, and it works as a dict. There's more information in the 
https://docs.djangoproject.com/en/1.8/topics/http/sessions/[Django docs on
sessions].

**********************************************************************

That gives us two failures:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test accounts*]
[...]
    self.assertEqual(self.client.session[SESSION_KEY], str(user.pk))
KeyError: '_auth_user_id'

[...]
AssertionError: '' != 'OK'
+ OK
----

The Django function that takes care of logging in a user, by marking their
session, is available at `django.contrib.auth.login`. So we go through another
couple of TDD cycles, until:

[role="sourcecode"]
.accounts/views.py
[source,python]
----
from django.contrib.auth import authenticate, login
from django.http import HttpResponse

def persona_login(request):
    user = authenticate(assertion=request.POST['assertion'])
    if user:
        login(request, user)
    return HttpResponse('OK')
----
//ch16l015

...

----
OK
----

We now have a working login view.
(((range="endofrange", startref="ix_mockingpython")))
(((range="endofrange", startref="ix_authenticationlogin")))

.Testing Login with Mocks
**********************************************************************
((("mocks/mocking", "testing Django login")))
An alternative way of testing that the Django login function was called
correctly would be to mock it out too:

[role="sourcecode skipme"]
.accounts/tests/test_views.py
[source,python]
----
from django.http import HttpRequest
from accounts.views import persona_login
[...]

    @patch('accounts.views.login')
    @patch('accounts.views.authenticate')
    def test_calls_auth_login_if_authenticate_returns_a_user(
        self, mock_authenticate, mock_login
    ):
        request = HttpRequest()
        request.POST['assertion'] = 'asserted'
        mock_user = mock_authenticate.return_value
        persona_login(request)
        mock_login.assert_called_once_with(request, mock_user)
----

The upside of this version of the test is that it doesn't need to
rely on the magic of the Django test client, and it doesn't need to
know anything about how Django sessions work--all you need to know
is the name of the function you're supposed to call.

Its downside is that it is very much testing implementation, rather
than testing behaviour--it's tightly coupled to the particular
name of the Django login function and its API.  

**********************************************************************


De-spiking Our Custom Authentication Backend: Mocking Out an Internet Request
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


((("authentication", "backend", id="ix_authbackend", range="startofrange")))
((("De-spiking", id="ix_despiking", range="startofrange")))
((("mocks/mocking", "Internet requests", id="ix_mockinternet", range="startofrange")))
Our custom authentication backend is next.  Here's how it looked in the spike:


[role="skipme small-code"]
[source,python]
----
class PersonaAuthenticationBackend(object):

    def authenticate(self, assertion):
        # Send the assertion to Mozilla's verifier service.
        data = {'assertion': assertion, 'audience': 'localhost'}
        print('sending to mozilla', data, file=sys.stderr)
        resp = requests.post('https://verifier.login.persona.org/verify', data=data)
        print('got', resp.content, file=sys.stderr)

        # Did the verifier respond?
        if resp.ok:
            # Parse the response
            verification_data = resp.json()

            # Check if the assertion was valid
            if verification_data['status'] == 'okay':
                email = verification_data['email']
                try:
                    return self.get_user(email)
                except ListUser.DoesNotExist:
                    return ListUser.objects.create(email=email)


    def get_user(self, email):
        return ListUser.objects.get(email=email)

----

Decoding this:

* We take an assertion and send it off to Mozilla using `requests.post`.
* We check its response code (`resp.ok`), and then check for a `status=okay` in
  the response JSON.
* We then extract an email address, and either find an existing user with that 
  address, or create a new one.


1 if = 1 More Test
^^^^^^^^^^^^^^^^^^

A rule of thumb for these sorts of tests:  any `if` means an extra test, and
any `try/except` means an extra test, so this should be about four tests.  Let's
start with one:


[role="sourcecode"]
.accounts/tests/test_authentication.py
[source,python]
----
from unittest.mock import patch
from django.test import TestCase

from accounts.authentication import (
    PERSONA_VERIFY_URL, DOMAIN, PersonaAuthenticationBackend
)

class AuthenticateTest(TestCase):

    @patch('accounts.authentication.requests.post')
    def test_sends_assertion_to_mozilla_with_domain(self, mock_post):
        backend = PersonaAuthenticationBackend()
        backend.authenticate('an assertion')
        mock_post.assert_called_once_with(
            PERSONA_VERIFY_URL,
            data={'assertion': 'an assertion', 'audience': DOMAIN}
        )
----

//IDEA: change "audience" to "http://localhost" instead of just "localhost".
// According to persona dev list, this is best practice...

In 'authenticate.py' we'll just have a few placeholders:
 
[role="sourcecode"]
.accounts/authentication.py
[source,python]
----
import requests

PERSONA_VERIFY_URL = 'https://verifier.login.persona.org/verify'
DOMAIN = 'localhost'


class PersonaAuthenticationBackend(object):

    def authenticate(self, assertion):
        pass
----

At this point we'll need to:

[role="dofirst-ch16l018"]
[subs="specialcharacters,quotes"]
----
(virtualenv)$ *pip install requests*
----


NOTE: Don't forget to add `requests` to 'requirements.txt' too, or the 
next deploy won't work...

//IDEA: consider making all tests (virtualenv) ones?

Then let's see how the tests get on!

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test accounts*]
[...]
AssertionError: Expected 'post' to be called once. Called 0 times.
----

And we can get that to passing in three steps (make sure the Goat sees you doing each
one individually!):

[role="sourcecode"]
.accounts/authentication.py
[source,python]
----
    def authenticate(self, assertion):
        requests.post(
            PERSONA_VERIFY_URL,
            data={'assertion': assertion, 'audience': DOMAIN}
        )
----


Grand:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test accounts*]
[...]

Ran 5 tests in 0.023s

OK
----

Next let's check that `authenticate` should return `None` if it sees an error from
the request:

[role="sourcecode"]
.accounts/tests/test_authentication.py (ch16l020)
[source,python]
----
    @patch('accounts.authentication.requests.post')
    def test_returns_none_if_response_errors(self, mock_post):
        mock_post.return_value.ok = False
        backend = PersonaAuthenticationBackend()

        user = backend.authenticate('an assertion')
        self.assertIsNone(user)
----

And that passes straight away--we currently return `None` in all cases! 


Patching at the Class Level
^^^^^^^^^^^^^^^^^^^^^^^^^^^

((("patching")))
Next we want to check that the response JSON has `status=okay`. Adding this
test would involve a bit of duplication--let's apply the "three strikes"
rule:


[role="sourcecode"]
.accounts/tests/test_authentication.py (ch16l021)
[source,python]
----
@patch('accounts.authentication.requests.post')  #<1>
class AuthenticateTest(TestCase):

    def setUp(self):
        self.backend = PersonaAuthenticationBackend()  #<2>


    def test_sends_assertion_to_mozilla_with_domain(self, mock_post):
        self.backend.authenticate('an assertion')
        mock_post.assert_called_once_with(
            PERSONA_VERIFY_URL,
            data={'assertion': 'an assertion', 'audience': DOMAIN}
        )


    def test_returns_none_if_response_errors(self, mock_post):
        mock_post.return_value.ok = False  #<3>
        user = self.backend.authenticate('an assertion')
        self.assertIsNone(user)


    def test_returns_none_if_status_not_okay(self, mock_post):
        mock_post.return_value.json.return_value = {'status': 'not okay!'}  #<3>
        user = self.backend.authenticate('an assertion')
        self.assertIsNone(user)
----

<1> You can apply a `patch` at the class level as well, and that has the effect
    that every test method in the class will have the patch applied, and the
    mock injected.

<2> We can now use the `setUp` function to prepare any useful variables which
    we're going to use in all of our tests.  

<3> Now each test is only adjusting the setup variables 'it' needs, rather than
    setting up a load of duplicated boilerplate--it's more readable.


And that's all very well, but everything still passes!  

----
OK
----

Time to test for the positive case where `authenticate` should return a user
object. We expect this to fail:


[role="sourcecode small-code"]
.accounts/tests/test_authentication.py (ch16l022-1)
[source,python]
----
from django.contrib.auth import get_user_model
User = get_user_model()
[...]

    def test_finds_existing_user_with_email(self, mock_post):
        mock_post.return_value.json.return_value = {'status': 'okay', 'email': 'a@b.com'}
        actual_user = User.objects.create(email='a@b.com')
        found_user = self.backend.authenticate('an assertion')
        self.assertEqual(found_user, actual_user)
----

Indeed, a fail:

----
AssertionError: None != <User: >
----

Let's code. We'll start with a "cheating" implementation, where we just get
the first user we find in the database:

[role="sourcecode"]
.accounts/authentication.py (ch16l023)
[source,python]
----
import requests
from django.contrib.auth import get_user_model
User = get_user_model()
[...]

    def authenticate(self, assertion):
        requests.post(
            PERSONA_VERIFY_URL,
            data={'assertion': assertion, 'audience': DOMAIN}
        )
        return User.objects.first()
----

That gets our new test passing, but still, none of the other tests
are failing:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test accounts*]
[...]

Ran 8 tests in 0.030s

OK
----

They're passing because `objects.first()` returns `None` if there are
no users in the database.  Let's make our other cases more realistic,
by making sure there's always at least one user in the database for all
our tests:

[role="sourcecode"]
.accounts/tests/test_authentication.py (ch16l022-2)
[source,python]
----
    def setUp(self):
        self.backend = PersonaAuthenticationBackend()
        user = User(email='other@user.com')
        user.username = 'otheruser'  #<1> 
        user.save()
----

<1> By default, Django's users have a `username` attribute, which has to
    be unique, so this value is just a placeholder to allow us to create
    multiple users. Later on, we'll get rid of usernames in favour of using
    emails as the primary key.  

That gives us three failures:

----
FAIL: test_finds_existing_user_with_email
AssertionError: <User: otheruser> != <User: >
[...]
FAIL: test_returns_none_if_response_errors
AssertionError: <User: otheruser> is not None
[...]
FAIL: test_returns_none_if_status_not_okay
AssertionError: <User: otheruser> is not None
----

Let's start building our guards for cases where authentication should fail--if
the response errors, or if the status is not `okay`.  Suppose we start with this:

[role="sourcecode"]
.accounts/authentication.py (ch16l024-1)
[source,python]
----
def authenticate(self, assertion):
    response = requests.post(
        PERSONA_VERIFY_URL,
        data={'assertion': assertion, 'audience': DOMAIN}
    )
    if response.json()['status'] == 'okay':
        return User.objects.first()
----

That actually fixes two of the tests, slightly surprisingly:

----
AssertionError: <User: otheruser> != <User: >

FAILED (failures=1)
----

Let's get the final test passing by retrieving the right user, and then we'll
have a look at that surprise pass:


[role="sourcecode"]
.accounts/authentication.py (ch16l024-2)
[source,python]
----
    if response.json()['status'] == 'okay':
        return User.objects.get(email=response.json()['email'])
----

...

----
OK
----


Beware of Mocks in Boolean Comparisons
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

So how come our `test_returns_none_if_response_errors` isn't failing?  

Because we've mocked out `requests.post`, the `response` is a Mock object,
which as you remember, returns all attributes and properties as more
Mocks.footnote:[Actually, this is only happening because we're using the `patch` 
decorator, which returns a `MagicMock`, an even mockier version of `mock` that
can also behave like a dictionary. More info in the
https://docs.python.org/3/library/unittest.mock-magicmethods.html[docs].] So, when we do: 

[role="sourcecode currentcontents"]
.accounts/authentication.py
[source,python]
----
    if response.json()['status'] == 'okay':
----

`response` is actually a mock, `response.json()` is a mock, and 
`response.json()['status']` is a mock too! We end up comparing a mock with the
string "okay", which evaluates to False, and so we return None by default.
Let's make our test more explicit, by saying that the response JSON will 
be an empty dict:


[role="sourcecode"]
.accounts/tests/test_authentication.py (ch16l025)
[source,python]
----
    def test_returns_none_if_response_errors(self, mock_post):
        mock_post.return_value.ok = False
        mock_post.return_value.json.return_value = {}
        user = self.backend.authenticate('an assertion')
        self.assertIsNone(user)
----

That gives:

----
    if response.json()['status'] == 'okay':
KeyError: 'status'
----

And we can fix it like this:


[role="sourcecode"]
.accounts/authentication.py (ch16l026)
[source,python]
----
    if response.ok and response.json()['status'] == 'okay':
        return User.objects.get(email=response.json()['email'])
----

...

----
OK
----

Great!  Our `authenticate` function is now working the way we want it to.


Creating a User if Necessary
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

((("user creation")))
Next we should check that, if our `authenticate` function has
a valid assertion from Persona, but we don't have a user record for
that person in our database, we should create one.  Here's the test
for that:


[role="sourcecode small-code"]
.accounts/tests/test_authentication.py (ch16l027)
[source,python]
----
def test_creates_new_user_if_necessary_for_valid_assertion(self, mock_post):
    mock_post.return_value.json.return_value = {'status': 'okay', 'email': 'a@b.com'}
    found_user = self.backend.authenticate('an assertion')
    new_user = User.objects.get(email='a@b.com')
    self.assertEqual(found_user, new_user)
----

That fails in our application code when we try find an existing user
with that email:

----
    return User.objects.get(email=response.json()['email'])
django.contrib.auth.models.DoesNotExist: User matching query does not exist.
----

So we add a `try/except`, returning an "empty" user at first:


[role="sourcecode"]
.accounts/authentication.py (ch16l028)
[source,python]
----
    if response.ok and response.json()['status'] == 'okay':
        try:
            return User.objects.get(email=response.json()['email'])
        except User.DoesNotExist:
            return User.objects.create()
----

And that fails, but this time it fails when the 'test' tries to find the
new user by email:

----
    new_user = User.objects.get(email='a@b.com')
django.contrib.auth.models.DoesNotExist: User matching query does not exist.
----

And so we fix it by assigning the correct email addresss:


[role="sourcecode"]
.accounts/authentication.py (ch16l029)
[source,python]
----
    if response.ok and response.json()['status'] == 'okay':
        email = response.json()['email']
        try:
            return User.objects.get(email=email)
        except User.DoesNotExist:
            return User.objects.create(email=email)
----

That gets us to passing tests:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test accounts*]
[...]
Ran 9 tests in 0.019s
OK
----



The get_user Method 
^^^^^^^^^^^^^^^^^^^


((("get_user")))
The next thing we have to build is a `get_user` method for our authentication
backend.  This method's job is to retrieve a user based on their email address,
or to return `None` if it can't find one. (That last wasn't well documented at
the time of writing, but that is the interface we have to comply with. See 
http://bit.ly/SuECDa[the source] for details.)


Here's a couple of tests for those two requirements:


[role="sourcecode"]
.accounts/tests/test_authentication.py (ch16l030)
[source,python]
----
class GetUserTest(TestCase):

    def test_gets_user_by_email(self):
        backend = PersonaAuthenticationBackend()
        other_user = User(email='other@user.com')
        other_user.username = 'otheruser'
        other_user.save()
        desired_user = User.objects.create(email='a@b.com')
        found_user = backend.get_user('a@b.com')
        self.assertEqual(found_user, desired_user)


    def test_returns_none_if_no_user_with_that_email(self):
        backend = PersonaAuthenticationBackend()
        self.assertIsNone(
            backend.get_user('a@b.com')
        )
----

Here's our first failure:

----
AttributeError: 'PersonaAuthenticationBackend' object has no attribute
'get_user'
----

Let's create a placeholder one then:


[role="sourcecode"]
.accounts/authentication.py (ch16l031)
[source,python]
----
class PersonaAuthenticationBackend(object):

    def authenticate(self, assertion):
        [...]

    def get_user(self):
        pass
----

Now we get:


----
TypeError: get_user() takes 1 positional argument but 2 were given
----

So:

[role="sourcecode"]
.accounts/authentication.py (ch16l032)
[source,python]
----
    def get_user(self, email):
        pass
----

Next:

----
    self.assertEqual(found_user, desired_user)
AssertionError: None != <User: >
----

And (step by step, just to see if our test fails the way we think it will):

[role="sourcecode"]
.accounts/authentication.py (ch16l033)
[source,python]
----
    def get_user(self, email):
        return User.objects.first()
----

That gets us past the first assertion, and onto 

----
    self.assertEqual(found_user, desired_user)
AssertionError: <User: otheruser> != <User: >

----

And so we call `get` with the email as an argument:


[role="sourcecode"]
.accounts/authentication.py (ch16l034)
[source,python]
----
    def get_user(self, email):
        return User.objects.get(email=email)
----

That gets us to passing tests:

Now our test for the None case fails:

----
ERROR: test_returns_none_if_no_user_with_that_email
[...]
django.contrib.auth.models.DoesNotExist: User matching query does not exist.
----

Which prompts us to finish the method like this:


[role="sourcecode"]
.accounts/authentication.py (ch16l035)
[source,python]
----
    def get_user(self, email):
        try:
            return User.objects.get(email=email)
        except User.DoesNotExist:
            return None #<1>
----

<1> You could just use `pass` here, and the function would return `None`
    by default.  However, because we specifically need the function to return
    `None`, explicit is better than implicit here.

That gets us to passing tests:

----
OK
----


And we have a working authentication backend!

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test accounts*]
[...]
Ran 11 tests in 0.020s
OK
----

Now we can define our custom user model.
(((range="endofrange", startref="ix_mockinternet")))
(((range="endofrange", startref="ix_despiking")))
(((range="endofrange", startref="ix_authbackend")))

A Minimal Custom User Model
~~~~~~~~~~~~~~~~~~~~~~~~~~~

((("authentication", "minimum custom user model", id="ix_authentusermodel", range="startofrange")))
((("Django", "custom user model", id="ix_Djangousermodel", range="startofrange")))
Django's built-in user model makes all sorts of assumptions about what
information you want to track about users, from explicitly recording
first name and last name, to forcing you to use a username.   I'm a great
believer in not storing information about users unless you absolutely must,
so a user model that records an email address and nothing else sounds good to
me!

[role="sourcecode"]
.accounts/tests/test_models.py
[source,python]
----
from django.test import TestCase
from django.contrib.auth import get_user_model

User = get_user_model()

class UserModelTest(TestCase):

    def test_user_is_valid_with_email_only(self):
        user = User(email='a@b.com')
        user.full_clean()  # should not raise
----
//37

That gives us an expected failure:

----
django.core.exceptions.ValidationError: {'username': ['This field cannot be
blank.'], 'password': ['This field cannot be blank.']}
----

Password?  Username?  Bah!  How about this?


[role="sourcecode"]
.accounts/models.py
[source,python]
----
from django.db import models

class User(models.Model):
    email = models.EmailField()
----
//38

And we wire it up inside 'settings.py' using a variable called
`AUTH_USER_MODEL`.  While we're at it, we'll add our new authentication backend
too:

[role="sourcecode"]
.superlists/settings.py (ch16l039)
[source,python]
----
AUTH_USER_MODEL = 'accounts.User'
AUTHENTICATION_BACKENDS = (
    'accounts.authentication.PersonaAuthenticationBackend',
)
----


The next error is a database error:

----
django.db.utils.OperationalError: no such table: accounts_user
----

That prompts us, as usual, to do a migration... When we try, Django complains
that our custom user model is missing a couple of bits of metadata:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py makemigrations*]
Traceback (most recent call last):
[...]
    if not isinstance(cls.REQUIRED_FIELDS, (list, tuple)):
AttributeError: type object 'User' has no attribute 'REQUIRED_FIELDS'
----


Sigh.  Come on, Django, it's only got one field, you should be able to figure
out the answers to these questions for yourself.  Here you go:

[role="sourcecode"]
.accounts/models.py
[source,python]
----
class User(models.Model):
    email = models.EmailField()
    REQUIRED_FIELDS = ()
----

Next silly question?footnote:[You might ask, if I think Django is so silly, why
don't I submit a pull request to fix it?  Should be quite a simple fix.  Well,
I promise I will, as soon as I've finished writing the book.  For now, snarky
comments will have to suffice.]

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py makemigrations*]
[...]
AttributeError: type object 'User' has no attribute 'USERNAME_FIELD'
----

So:

[role="sourcecode"]
.accounts/models.py
[source,python]
----
class User(models.Model):
    email = models.EmailField()
    REQUIRED_FIELDS = ()
    USERNAME_FIELD = 'email'
----
//41


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py makemigrations*]
System check identified some issues:

WARNINGS:
accounts.User: (auth.W004) 'User.email' is named as the 'USERNAME_FIELD', but
it is not unique.
        HINT: Ensure that your authentication backend(s) can handle non-unique
usernames.
Migrations for 'accounts':
  0001_initial.py:
    - Create model User
----

Let's hold that thought, and see if we can get the tests passing again.


A Slight Disappointment
^^^^^^^^^^^^^^^^^^^^^^^

Meanwhile, we have a couple of weird unexpected failures:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test accounts*]
[...]
ERROR: test_gets_logged_in_session_if_authenticate_returns_a_user
[...]
ERROR: test_returns_OK_when_user_found
[...]
    user.save(update_fields=['last_login'])
[...]
ValueError: The following fields do not exist in this model or are m2m fields:
last_login

----

It looks like Django is going to insist on us having a `last_login` field on
our user model too.  Oh well.  My pristine, single-field user model is
despoiled. I still love it though.

[role="sourcecode"]
.accounts/models.py
[source,python]
----
from django.db import models
from django.utils import timezone

class User(models.Model):
    email = models.EmailField()
    last_login = models.DateTimeField(default=timezone.now)
    REQUIRED_FIELDS = ()
    USERNAME_FIELD = 'email'
----
//42

We get another database error, so let's clear down the migration and 
re-create it:
[subs="specialcharacters,macros"]
----
$ pass:quotes[*rm accounts/migrations/0001_initial.py*]
$ pass:quotes[*python3 manage.py makemigrations*]
System check identified some issues:
[...]
Migrations for 'accounts':
  0001_initial.py:
    - Create model User
----

That gets the tests passing:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test accounts*]
[...]

Ran 12 tests in 0.041s

OK
----


Tests as Documentation
^^^^^^^^^^^^^^^^^^^^^^

((("tests, as documentation")))
((("authentication", "tests as documentation")))
((("documentation, tests as")))
Let's go all the way and make the email field into the primary
keyfootnote:[Emails may not be the perfect primary key IRL. One reader, clearly
deeply emotionally scarred, wrote me a tearful email about how much they've
suffered for over a decade from trying to deal with the effects email primary
keys, due to their making multi-user account management impossible. So, as
ever, YMMV.],
and thus implicitly remove the auto-generated `id` column.

Although that warning is probably enough of a justification to go ahead
and make the change, it would be better to have a specific test:

[role="sourcecode"]
.accounts/tests/test_models.py (ch16l043)
[source,python]
----
    def test_email_is_primary_key(self):
        user = User()
        self.assertFalse(hasattr(user, 'id'))
----

It'll help us remember if we ever come back and look at the code again
in future.

----
    self.assertFalse(hasattr(user, 'id'))
AssertionError: True is not false
----

NOTE: Your tests can be are a form of documentation for your code--they
express what your requirements are of a particular class or function.
Sometimes, if you forget why you've done something a particular way, going back
and looking at the tests will give you the answer.  That's why it's important
to give your tests explicit, verbose method names.

And here's the implementation (feel free to check what happens with
`unique=True` first):

[role="sourcecode"]
.accounts/models.py (ch16l044)
[source,python]
----
    email = models.EmailField(primary_key=True)
----

That works:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test accounts*]
[...]
Ran 13 tests in 0.021s
OK
----


One final cleanup of migrations to make sure we've got everything there:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*rm accounts/migrations/0001_initial.py*]
$ pass:quotes[*python3 manage.py makemigrations*]
Migrations for 'accounts':
  0001_initial.py:
    - Create model User
----

No warnings now!


Users Are Authenticated
^^^^^^^^^^^^^^^^^^^^^^^

Our user model needs one last property before it's complete:  standard Django
users have an API which includes 
https://docs.djangoproject.com/en/1.8/ref/contrib/auth/#methods[several
methods], most of which we won't need, but there is one that will come in
useful: `.is_authenticated()`:

[role="sourcecode"]
.accounts/tests/test_models.py (ch16l045)
[source,python]
----
    def test_is_authenticated(self):
        user = User()
        self.assertTrue(user.is_authenticated())
----

Which gives:

----
AttributeError: 'User' object has no attribute 'is_authenticated'
----

And so, the ultra-simple:

[role="sourcecode"]
.accounts/models.py
[source,python]
----
class User(models.Model):
    email = models.EmailField(primary_key=True)
    last_login = models.DateTimeField(default=timezone.now)
    REQUIRED_FIELDS = ()
    USERNAME_FIELD = 'email'

    def is_authenticated(self):
        return True
----
//45-1

And that works:
(((range="endofrange", startref="ix_authentusermodel")))
(((range="endofrange", startref="ix_Djangousermodel")))

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test accounts*]
[...]
Ran 14 tests in 0.021s
OK
----


The Moment of Truth:  Will the FT Pass?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

I think we're just about ready to try our functional test!  Let's just wire 
up our base template.  Firstly, it needs to show a different message for
logged-in and non-logged-in users:

[role="sourcecode small-code"]
.lists/templates/base.html
[source,html]
----
<nav class="navbar navbar-default" role="navigation">
    <a class="navbar-brand" href="/">Superlists</a>
    {% if user.email %}
        <a class="btn navbar-btn navbar-right" id="id_logout" href="#">Log out</a>
        <span class="navbar-text navbar-right">Logged in as {{ user.email }}</span>
    {% else %}
        <a class="btn navbar-btn navbar-right" id="id_login" href="#">Sign in</a>
    {% endif %}
</nav>
----
//47

Lovely.  Then we wire up our various context variables for the call to
`initialize`:

[role="sourcecode"]
.lists/templates/base.html
[source,html]
----
<script>
    /*global $, Superlists, navigator */
    $(document).ready(function () {
        var user = "{{ user.email }}" || null;
        var token = "{{ csrf_token }}";
        var urls = {
            login: "{% url 'persona_login' %}",
            logout: "TODO",
        };
        Superlists.Accounts.initialize(navigator, user, token, urls);
    });
</script>
----
//48

So how does our FT get along?

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.test_login*]
Creating test database for alias 'default'...
[...]
Ran 1 test in 26.382s

OK
----

Woohoo!

I've been waiting to do a commit up until this moment, just to make sure
everything works.  At this point, you could make a series of separate 
commits--one for the login view, one for the auth backend, one for 
the user model, one for wiring up the template.  Or you could decide that,
since they're all interrelated, and none will work without the others,
you may as well just have one big commit:

[subs="specialcharacters,quotes"]
----
$ *git status*
$ *git add .*
$ *git diff --staged*
$ *git commit -m "Custom Persona auth backend + custom user model"*
----


Finishing Off Our FT, Testing Logout
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

((("authentication", "testing logout")))
We'll extend our FT to check that the logged-in status persists, ie it's 
not just something we set in JavaScript on the client side, but the server
knows about it too and will maintain the logged-in state if she refreshes
the page. We'll also test that she can log out.

I started off writing code a bit like this:

[role="sourcecode skipme"]
.functional_tests/test_login.py
[source,python]
----
    # Refreshing the page, she sees it's a real session login,
    # not just a one-off for that page
    self.browser.refresh()
    self.wait_for_element_with_id('id_logout')
    navbar = self.browser.find_element_by_css_selector('.navbar')
    self.assertIn('edith@mockmyid.com', navbar.text)
----
//49

And, after four repetitions of very similar code, a couple of helper functions
suggested themselves:


[role="sourcecode"]
.functional_tests/test_login.py (ch16l050)
[source,python]
----
    def wait_to_be_logged_in(self):
        self.wait_for_element_with_id('id_logout')
        navbar = self.browser.find_element_by_css_selector('.navbar')
        self.assertIn('edith@mockmyid.com', navbar.text)

    def wait_to_be_logged_out(self):
        self.wait_for_element_with_id('id_login')
        navbar = self.browser.find_element_by_css_selector('.navbar')
        self.assertNotIn('edith@mockmyid.com', navbar.text)
----
//50

And I extended the FT like this:

[role="sourcecode"]
.functional_tests/test_login.py (ch16l049)
[source,python]
----
        [...]
        # The Persona window closes
        self.switch_to_new_window('To-Do')

        # She can see that she is logged in
        self.wait_to_be_logged_in()

        # Refreshing the page, she sees it's a real session login,
        # not just a one-off for that page
        self.browser.refresh()
        self.wait_to_be_logged_in()

        # Terrified of this new feature, she reflexively clicks "logout"
        self.browser.find_element_by_id('id_logout').click()
        self.wait_to_be_logged_out()

        # The "logged out" status also persists after a refresh
        self.browser.refresh()
        self.wait_to_be_logged_out()
----

I also found that improving the failure message in the
`wait_for_element_with_id` function helped to see what was going on:


[role="sourcecode"]
.functional_tests/test_login.py
[source,python]
----
    def wait_for_element_with_id(self, element_id):
        WebDriverWait(self.browser, timeout=30).until(
            lambda b: b.find_element_by_id(element_id),
            'Could not find element with id {}. Page text was:\n{}'.format(
                element_id, self.browser.find_element_by_tag_name('body').text
            )
        )
----
//52


With that, we can see that the test is failing because the logout button
doesn't work:

[subs="specialcharacters,quotes"]
----
$ *python3 manage.py test functional_tests.test_login*
  File "/workspace/superlists/functional_tests/test_login.py", line 36, in
wait_to_be_logged_out
[...]
selenium.common.exceptions.TimeoutException: Message: Could not find element
with id id_login. Page text was:
Superlists
Log out
Logged in as edith@mockmyid.com
Start a new To-Do list
----

Implementing a logout button is actually very simple:  we can use Django's 
http://bit.ly/SuI0hA[built-in
logout view], which clears down the user's session and redirects them
to a page of our choice:

[role="sourcecode small-code"]
.accounts/urls.py
[source,python]
----
from django.contrib.auth.views import logout
[...]

urlpatterns = [
    url(r'^login$', views.persona_login, name='persona_login'),
    url(r'^logout$', logout, {'next_page': '/'}, name='logout'),
]
----

And in 'base.html', we just make the logout into a normal URL link:

[role="sourcecode small-code"]
.lists/templates/base.html
[source,python]
----
<a class="btn navbar-btn navbar-right" id="id_logout" href="{% url 'logout' %}">Log out</a>
----


And that gets us a fully passing FT--indeed, a fully passing test suite:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.test_login*]
[...]
OK
$ pass:quotes[*python3 manage.py test*]
[...]
Ran 54 tests in 78.124s

OK
----
//54

NOTE: I'm actually glossing over a small problem here.  You may notice, if you
    test the site manually, that Persona sometimes re-logs you in automatically
    after you hit logout. Many thanks to Daniel G who finally prompted me with
    a fix for this. You can find it
    https://github.com/hjwp/book-example/commits/chapter_16_fix_auto_relogin_bug[here]
    if you're curious.

In the next chapter, we'll start trying to put our login system to good use.
In the meantime, do a commit, and enjoy this recap:

.On Mocking in Python
*******************************************************************************

Mocking::
    We use mocking in unit tests when we have an external dependency that we
    don't want to actually use in our tests.  A mock is used to simulate the 
    third-party API.   Whilst it is possible to "roll your own" mocks in
    Python, a mocking framework like the mock module provides a lot of helpful
    shortcuts which will make it easier to write (and more importantly, read)
    your tests.
    ((("mocking")))


Monkeypatching::
    Replacing an object in a namespace at run-time.  We use it in our unit tests
    to replace a real function which has undesirable side-effects with a mock
    object, using the `patch` decorator.
    ((("monkeypatching")))


The Mock library::
    Michael Foord (who used to work for the company that spawned
    PythonAnywhere, just before I joined) wrote the excellent "Mock"
    library that's now been integrated into the standard library of Python 3.
    It contains most everything you might need for mocking in Python.
    ((("mocks/mocking", "mock library")))

The patch decorator::
    `unittest.mock` provides a function called `patch`, which can be used
    to "mock out" any object from the module you're testing.  It's commonly
    used as a decorator on a test method, or even at the class level, where
    it's applied to all the test methods of that class.
    ((("patch decorator")))

Mocks are truthy and can mask errors::
    Be aware that mocking things out can cause counterintuitive behaviour
    in `if` statements.  Mocks are truthy, and they can also mask errors,
    because they have all attributes and methods.

Too many mocks are a code smell::
    Overly mocky tests end up very tightly coupled to their implementation.
    Sometimes this is unavoidable.  But, in general, try to find ways
    of organising your code so that you don't need too many mocks.
    ((("code smell")))

*******************************************************************************

