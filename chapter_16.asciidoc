De-duplication in FTs: test fixtures
------------------------------------

Now that we have a functional authentication system, let's build out our
site to be able to show users lists they have created.

Along the way, we'll talk about ways of avoiding duplication in FTs, test
fixtures, and start building some tools to manage them both in local tests and
on our staging server.


Skipping the login process by pre-creating a session
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

From now on, we're probably going to have a lot of tests that are going to
require having a logged-in user.  Rather than making each test go through
the (time-consuming) Persona dialog, it would be good to be able to skip that
part.

This is about separation of concerns.  Functional tests aren't like unit tests,
in that they don't usually have a single assertion. But, conceptually, they
should be testing a single thing.  There's no need for every single FT to test
the login/logout mechanisms. If we can figure out a way to "cheat" and skip
that part, we'll spend less time waiting for duplicated test paths.

TIP: Don't overdo de-duplication in FTs.  One of the benefits of an FT is that
it can catch strange and unpredictable interactions between different parts of
your application.

It's quite common for a user to return to a site and still have a cookie that
means they are "pre-authenticated", so this isn't an unrealistic cheat at all.
Here's how you can set it up:

[role="sourcecode"]
.functional_tests/test_my_lists.py
[source,python]
----
from django.conf import settings
from django.contrib.auth import BACKEND_SESSION_KEY, SESSION_KEY, get_user_model
User = get_user_model()
from django.contrib.sessions.backends.db import SessionStore

from .base import FunctionalTest


class MyListsTest(FunctionalTest):

    def create_pre_authenticated_session(self):
        user = User.objects.create(email='edith@email.com')
        session = SessionStore()
        session[SESSION_KEY] = user.pk #<1>
        session[BACKEND_SESSION_KEY] = settings.AUTHENTICATION_BACKENDS[0]
        session.save()
        ## to set a cookie we need to first visit the domain.
        ## 404 pages load the quickest!
        self.browser.get(self.server_url + "/404_no_such_url/")
        self.browser.add_cookie(dict(
            name=settings.SESSION_COOKIE_NAME,
            value=session.session_key, #<2>
            path='/',
        ))
----

<1> We create a session object in the database.  The session key is the
    primary key of the user object (which is actually their email address).

<2> We then add a cookie to the browser that matches the session on the
    server -- on our next visit to the site, the server should recognise
    us as a logged-in user.

Note that, as it is, this will only work because we're using
`LiveServerTestCase`, so the User and Session objects we create will end up in
the same database as the test server.  Later we'll need to modify it so that it
works against the database on the staging server too.


.JSON test fixtures considered harmful
*******************************************************************************
When we pre-populate the database with test data, as we've done here with the
User object and its associated Session object, what we're doing is setting up
a "test fixture".

Django comes with built-in support for saving database objects as JSON (using
the `manage.py dumpdata`), and automatically loading them in your test runs 
using the `fixtures` class attribute on `TestCase`.

More and more people are starting 
http://blog.muhuk.com/2012/04/09/carl-meyers-testing-talk-at-pycon-2012.html[to
say]: don't use JSON fixtures.  They're a nightmare to maintain when your model
changes.  Instead, if you can, load data directly using the Django ORM, or look
into a tool like https://factoryboy.readthedocs.org/en/latest/[factory_boy]
*******************************************************************************

Now we can create the main body of the FT for the "my lists" page:

[role="sourcecode"]
.functional_tests/test_my_lists.py
[source,python]
----
    def test_logged_in_users_lists_are_saved_as_my_lists(self):
        # Edith is a logged-in user
        self.create_pre_authenticated_session()

        # She goes to the home page and starts a list
        self.browser.get(self.server_url)
        self.get_item_input_box().send_keys('Reticulate splines\n')
        self.get_item_input_box().send_keys('Immanentize eschaton\n')
        first_list_url = self.browser.current_url

        # She notices a "My lists" link, for the first time.
        self.browser.find_element_by_link_text('My lists').click()

        # She sees that her list is in there, named according to its
        # first list item
        self.browser.find_element_by_link_text('Reticulate splines').click()
        self.assertEqual(self.browser.current_url, first_list_url)

        # She decides to start another list, just to see
        self.browser.get(self.server_url)
        self.get_item_input_box().send_keys('Click cows\n')
        second_list_url = self.browser.current_url

        # Under "my lists", her new list appears
        self.browser.find_element_by_link_text('My lists').click()
        self.browser.find_element_by_link_text('Click cows').click()
        self.assertEqual(self.browser.current_url, second_list_url)

        # She logs out.  The "My lists" option disappears
        self.browser.find_element_by_id('id_logout').click()
        self.assertEqual(
            self.browser.find_elements_by_link_text('My lists'),
            []
        )
----

That gets us:

----
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"link text","selector":"My lists"}' ; Stacktrace: 
----

TODO: double-check we really are logged in, then commit.

TODO: use `assert_logged_in` to confirm our thing works

TODO: wrap-up

