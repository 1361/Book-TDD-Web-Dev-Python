Finishing "my lists": test fixtures, in dev and staging
-------------------------------------------------------

Now that we have a functional authentication system, let's build out our
site to be able to show users lists they have created.

Along the way, we'll talk about ways of avoiding duplication in FTs, test
fixtures, and start building some tools to manage them both in local tests and
on our staging server.


Skipping the login process by pre-creating a session
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

From now on, we're probably going to have a lot of tests that are going to
require having a logged-in user.  Rather than making each test go through
the (time-consuming) Persona dialog, it would be good to be able to skip that
part.

This is about separation of concerns.  Functional tests aren't like unit tests,
in that they don't usually have a single assertion. But, conceptually, they
should be testing a single thing.  There's no need for every single FT to test
the login/logout mechanisms. If we can figure out a way to "cheat" and skip
that part, we'll spend less time waiting for duplicated test paths.

TIP: Don't overdo de-duplication in FTs.  One of the benefits of an FT is that
it can catch strange and unpredictable interactions between different parts of
your application.

It's quite common for a user to return to a site and still have a cookie that
means they are "pre-authenticated", so this isn't an unrealistic cheat at all.
Here's how you can set it up:

[role="sourcecode"]
.functional_tests/test_my_lists.py
[source,python]
----
from django.conf import settings
from django.contrib.auth import BACKEND_SESSION_KEY, SESSION_KEY, get_user_model
User = get_user_model()
from django.contrib.sessions.backends.db import SessionStore

from .base import FunctionalTest


class MyListsTest(FunctionalTest):

    def create_pre_authenticated_session(self):
        user = User.objects.create(email='edith@email.com')
        session = SessionStore()
        session[SESSION_KEY] = user.pk #<1>
        session[BACKEND_SESSION_KEY] = settings.AUTHENTICATION_BACKENDS[0]
        session.save()
        ## to set a cookie we need to first visit the domain.
        ## 404 pages load the quickest!
        self.browser.get(self.server_url + "/404_no_such_url/")
        self.browser.add_cookie(dict(
            name=settings.SESSION_COOKIE_NAME,
            value=session.session_key, #<2>
            path='/',
        ))
----

<1> We create a session object in the database.  The session key is the
    primary key of the user object (which is actually their email address).

<2> We then add a cookie to the browser that matches the session on the
    server -- on our next visit to the site, the server should recognise
    us as a logged-in user.

Note that, as it is, this will only work because we're using
`LiveServerTestCase`, so the User and Session objects we create will end up in
the same database as the test server.  Later we'll need to modify it so that it
works against the database on the staging server too.


.JSON test fixtures considered harmful
*******************************************************************************
When we pre-populate the database with test data, as we've done here with the
User object and its associated Session object, what we're doing is setting up
a "test fixture".

Django comes with built-in support for saving database objects as JSON (using
the `manage.py dumpdata`), and automatically loading them in your test runs 
using the `fixtures` class attribute on `TestCase`.

More and more people are starting 
http://blog.muhuk.com/2012/04/09/carl-meyers-testing-talk-at-pycon-2012.html[to
say]: don't use JSON fixtures.  They're a nightmare to maintain when your model
changes.  Instead, if you can, load data directly using the Django ORM, or look
into a tool like https://factoryboy.readthedocs.org/en/latest/[factory_boy]
*******************************************************************************

Now we can create the main body of the FT for the "my lists" page:

[role="sourcecode"]
.functional_tests/test_my_lists.py
[source,python]
----
    def test_logged_in_users_lists_are_saved_as_my_lists(self):
        # Edith is a logged-in user
        self.create_pre_authenticated_session()

        # She goes to the home page and starts a list
        self.browser.get(self.server_url)
        self.get_item_input_box().send_keys('Reticulate splines\n')
        self.get_item_input_box().send_keys('Immanentize eschaton\n')
        first_list_url = self.browser.current_url

        # She notices a "My lists" link, for the first time.
        self.browser.find_element_by_link_text('My lists').click()

        # She sees that her list is in there, named according to its
        # first list item
        self.browser.find_element_by_link_text('Reticulate splines').click()
        self.assertEqual(self.browser.current_url, first_list_url)

        # She decides to start another list, just to see
        self.browser.get(self.server_url)
        self.get_item_input_box().send_keys('Click cows\n')
        second_list_url = self.browser.current_url

        # Under "my lists", her new list appears
        self.browser.find_element_by_link_text('My lists').click()
        self.browser.find_element_by_link_text('Click cows').click()
        self.assertEqual(self.browser.current_url, second_list_url)

        # She logs out.  The "My lists" option disappears
        self.browser.find_element_by_id('id_logout').click()
        self.assertEqual(
            self.browser.find_elements_by_link_text('My lists'),
            []
        )
----

That gets us:

----
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate element: {"method":"link text","selector":"My lists"}' ; Stacktrace: 
----

TODO: double-check we really are logged in, then commit.

An exercise for the reader
~~~~~~~~~~~~~~~~~~~~~~~~~~

To implement this, we'll need:

* A new template 'my_lists.html', and some tweaks to 'base.html'
* An optional foreign key on the List model
* To change the `new_list` view, with optional addition of `list_.owner` from
  `request.user`. 
* And/or change `ItemForm.save` to take the `request.user`
    * A possible refactor could be: rename `ItemForm` to `NewListItemForm`.
    Maybe its `save` method doesn't need the `for_list` arg after all?
* A new view + urls entry in 'accounts', `my_lists`.

Rather than spell everything out exactly for you, I thought I would just show
you the new unit tests I had to write:

[role="sourcecode"]
.unit test class and method names
[source,python]
----
class MyListsViewTest(TestCase):
    def test_uses_my_lists_template(self):
    def test_passes_user_in_context(self):
    def test_template_displays_lists_using_first_item_text(self):

class ItemFormTest(TestCase):
    def test_form_save_sets_owner_if_real_user(self):
    def test_form_save_ignores_anon_user(self):

class ListModelTest(TestCase):
    def test_get_absolute_url(self):
    def test_can_optionally_set_owner(self):

class NewListTest(TestCase):
    def test_POST_from_real_user_sets_owner_on_list(self):
----

Can you come up with an implementation on your own?  The FT should tell
you once everything works OK.  Then, compare yourself against my implementation
https://github.com/hjwp/book-example/tree/chapter_15[on GitHub]

Here's a couple of tips:

* You can't really use `self.client.login` in the view tests.  I called the 
  raw view function instead

* You'll probably find the `AnonymousUser` class useful, it's at
  `django.contrib.auth.models`

* You'll probably need to add a new `{% block %}` to the 'base.html' template.


NOTE: I really need feedback about this section.  Did you find it too hard?
Are there any specific extra hints could I have given you that would have kept
you on the right track? 
//TODO: remove me


Deployment and fixing our database migration code
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Assuming you have a passing test suite for the last section, let's see how we
get on with deploying our code to the server...

[subs="specialcharacters,quotes"]
----
$ *fab deploy --host=superlists-staging.ottg.eu*
[...]
----

And restart gunicorn...

[subs="specialcharacters,quotes"]
----
user@server: *sudo restart gunicorn-superlists-staging.ottg.eu*
----


The tests discover a bug!
~~~~~~~~~~~~~~~~~~~~~~~~~

Here's what happens when we run the functional tests:

----
======================================================================
ERROR: test_logged_in_users_lists_are_saved_as_my_lists
(functional_tests.test_my_lists.MyListsTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/worskpace/functional_tests/test_my_lists.py", line 39, in
test_logged_in_users_lists_are_saved_as_my_lists
[...]
NoSuchElementException: Message: u'Unable to locate element: {"method":"link
text","selector":"My lists"}' ; Stacktrace: 

======================================================================
ERROR: test_login_with_persona (functional_tests.test_login.LoginTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/worskpace/functional_tests/test_login.py", line 56, in
test_login_with_persona
    self.assert_logged_in()
[...]
TimeoutException: Message: '' 
----

That was unexpected.  It looks like the Personal login system isn't working in
staging.  It turns out it's because I overlooked an important part of the
Persona system, which is that authentications are only valid for particular
domains.  We've left the domain hard-code as "localhost" in
'accounts/authentication.py':

----
PERSONA_VERIFY_URL = 'https://verifier.login.persona.org/verify'
DOMAIN = 'localhost'
User = get_user_model()
----

I had considered just going back and fixing this in the previous chapter,
and pretending it never happened, but I think leaving it in teaches a better
lesson:  first off, I'm not that smart, and second: this is exactly the point
of running tests against a staging environment.  It would have been pretty 
embarrassing if we'd deployed this bug straight to our live site.

Here's how we go about fixing it, starting by moving the definition for the
`DOMAIN` variable into 'settings.py', where we can later use the deploy script
to override it:

[role="sourcecode"]
.superlists/settings.py
[source,python]
----
# This setting is changed by the deploy script
DOMAIN = "localhost"

ALLOWED_HOSTS = [DOMAIN]
----

We feed that change back through the tests:

[role="sourcecode"]
.accounts/test_authentication.py
[source,diff]
----
@@ -1,9 +1,9 @@
 from unittest.mock import Mock, patch
+from django.conf import settings
 from django.test import TestCase
 
 from accounts.authentication import (
-    PERSONA_VERIFY_URL, DOMAIN,
+    PERSONA_VERIFY_URL,
     PersonaAuthenticationBackend, User
 )
 
@@ -28,7 +28,7 @@ class AuthenticateTest(TestCase):
         self.backend.authenticate('an assertion')
         mock_post.assert_called_once_with(
             PERSONA_VERIFY_URL,
-            data={'assertion': 'an assertion', 'audience': DOMAIN}
+            data={'assertion': 'an assertion', 'audience': settings.DOMAIN}
         )
----

And then we change the implementation:

[role="sourcecode"]
.accounts/authenticate.py
[source,diff]
----
@@ -1,8 +1,8 @@
 import requests
 from django.contrib.auth import get_user_model
+from django.conf import settings
 
 PERSONA_VERIFY_URL = 'https://verifier.login.persona.org/verify'
-DOMAIN = 'localhost'
 User = get_user_model()
 
 
@@ -11,7 +11,7 @@ class PersonaAuthenticationBackend(object):
     def authenticate(self, assertion):
         response = requests.post(
             PERSONA_VERIFY_URL,
-            data={'assertion': assertion, 'audience': DOMAIN}
+            data={'assertion': assertion, 'audience': settings.DOMAIN}
         )
         if not response.ok:
             return
----

Re-running the tests just to be sure:

----
$ python3 manage.py test accounts
[...]
Ran 18 tests in 0.053s
OK
----

Next we update our fabfile to make it adjust the domain in settings.py:


[role="sourcecode"]
.deploy_tools/fabfile.py
[source,python]
----
def _update_settings(source_folder, site_name):
    settings_path = path.join(source_folder, 'superlists/settings.py')
    sed(settings_path, "DEBUG = True", "DEBUG = False")
    sed(settings_path, 'DOMAIN = "localhost"', 'DOMAIN = "%s"' % (site_name,))
    secret_key_file = path.join(source_folder, 'superlists/secret_key.py')
    if not exists(secret_key_file):
        [...]
----

We re-deploy, and spot the `sed` in the output:

[subs="specialcharacters,quotes"]
----
$ *fab deploy --host=superlists-staging.ottg.eu*
[...]
[superlists-staging.ottg.eu] run: sed -i.bak -r -e 's/DOMAIN =
"localhost"/DOMAIN = "superlists-staging.ottg.eu"/g' "$(echo
/home/harry/sites/superlists-staging.ottg.eu/source/superlists/settings.py)"
[...]
----

Now we can re-run our FTs, and get to the bug we were fearing might happen: 
our attempt to create pre-authenticated sessions doesn't work, so the 
"My lists" test fails:

----
$ python3 manage.py test functional_tests --liveserver=superlists-staging.ottg.eu

ERROR: test_logged_in_users_lists_are_saved_as_my_lists
(functional_tests.test_my_lists.MyListsTest)
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"link text","selector":"My lists"}' ; Stacktrace: 

Ran 7 tests in 72.742s

FAILED (errors=1)
----

Let's find out how to manage the database on the server.



Creating a Django management command to create sessions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To do things on the server, we'll need to build a self-contained script that
can be run from the command-line on the server, most probably via Fabric.

When trying to build standalone scripts that work with the Django environment,
can talk to the database and so on, there are some fiddly issues you need to
get right, like setting the `DJANGO_SETTINGS_MODULE` environment variable
correctly, and getting the `sys.path` right.  Instead of messing about with all
that, Django lets you create your own "management commands" (commands you can
run with `python manage.py`), which will do all that path mangling for you.
They live in a folder called 'management/commands' inside your apps.

[subs="specialcharacters,quotes"]
----
$ *mkdir -p functional_tests/management/commands*
$ *touch functional_tests/management/__init__.py*
$ *touch functional_tests/management/commands/__init__.py*
----

The boilerplate in a management command is a class that inherits from 
`django.core.management.BaseCommand`, and that defines a method called
`handle`:

[role="sourcecode"]
.functional_tests/management/commands/create_session.py
[source,python]
----
from django.conf import settings
from django.contrib.auth import BACKEND_SESSION_KEY, SESSION_KEY, get_user_model
User = get_user_model()
from django.contrib.sessions.backends.db import SessionStore
from django.core.management.base import BaseCommand


class Command(BaseCommand):

    def handle(self, *_, **__):
        session_key = create_pre_authenticated_session()
        self.stdout.write(session_key)


def create_pre_authenticated_session():
    user = User.objects.create(email='edith@email.com')
    session = SessionStore()
    session[SESSION_KEY] = user.pk
    session[BACKEND_SESSION_KEY] = settings.AUTHENTICATION_BACKENDS[0]
    session.save()
    return session.session_key
----

We've taken the code for `create_pre_authenticated_session` code from
'test_my_lists.py'.  The function returns the session key that we'll 
want to add to our browser cookies, and the management command prints
it out at the command-line. Try it out:

----
$ python3 manage.py create_session
Unknown command: 'create_session'
----

Ah, one last step: we need to add `functional_tests` to our 'settings.py'
for it to recognise it as a real app that might have management commands as
well as tests:

[role="sourcecode"]
.superlists/settings.py
[source,python]
----
+++ b/superlists/settings.py
@@ -42,6 +42,7 @@ INSTALLED_APPS = (
     'lists',
     'south',
     'accounts',
+    'functional_tests',
 )
----

Now it works:

----
$ python3 manage.py create_session
qnslckvp2aga7tm6xuivyb0ob1akzzwl
----

Next we need to adjust `test_my_lists` so that it runs the local function
when we're on the local server, and make it run the management command
on the staging server if we're on that:

[role="sourcecode"]
.functional_tests/test_my_lists.py
[source,python]
----
from django.conf import settings
from .base import FunctionalTest
from .server_tools import create_session_on_server
from ..management.commands.create_session import create_pre_authenticated_session

class MyListsTest(FunctionalTest):

    def create_pre_authenticated_session(self):
        if self.against_staging:
            session_key = create_session_on_server(self.server_host)
        else:
            session_key = create_pre_authenticated_session()
        ## to set a cookie we need to first visit the domain.
        ## 404 pages load the quickest!
        self.browser.get(self.server_url + "/404_no_such_url/")
        self.browser.add_cookie(dict(
            name=settings.SESSION_COOKIE_NAME,
            value=session_key,
            path='/',
        ))

    [...]
----

First let's see how we know whether or not we're working against the 
staging server. `self.against_staging` gets populated in 'base.py':


[role="sourcecode"]
.functional_tests/base.py
[source,python]
----
from .server_tools import reset_database

class FunctionalTest(LiveServerTestCase):

    @classmethod
    def setUpClass(cls):
        for arg in sys.argv:
            if 'liveserver' in arg:
                cls.server_host = arg.split('=')[1] #<1>
                cls.server_url = 'http://' + cls.server_host
                cls.against_staging = True #<1>
                return
        LiveServerTestCase.setUpClass()
        cls.against_staging = False
        cls.server_url = cls.live_server_url

    @classmethod
    def tearDownClass(cls):
        if not self.against_staging:
            LiveServerTestCase.tearDownClass()

    def setUp(self):
        if self.against_staging:
            reset_database(self.server_host) #<2>
        self.browser = webdriver.Firefox()
        self.browser.implicitly_wait(3)
----

<1> Instead of just storing `cls.server_url`, we also store the `server_host` 
    and `against_staging` attributes if we detect the `liveserver` command-line
    argument

<2> We also need a way of resetting the server database in between each test.

It's time to take a look at 'server_tools':

[role="sourcecode"]
.functional_tests/server_tools.py
[source,python]
----
from os import path
import subprocess
THIS_FOLDER = path.abspath(path.dirname(__file__))

def reset_database(host):
    subprocess.check_call(
        ['fab', 'reset_database', '--host={}'.format(host)],
        cwd=THIS_FOLDER
    )


def create_session_on_server(host):
    return subprocess.check_output(
        [
            'fab',
            'create_session_on_server',
            '--host={}'.format(host),
            '--hide=everything,status', #<1>
        ],
        cwd=THIS_FOLDER
    ).decode().strip() #<1>
----

Here we use the `subprocess` module to call some fabric functions using the
`fab` command. We have to use `subprocess` because fabric is currently only
available in Python 2. Otherwise we could have called fabric functions directly
within the test process.

<1> Because of all the hopping around via fabric and subprocesses, we're forced
    to be quite careful about extracting the session key from the output of the
    command as it gets run on the server.

NOTE: By the time you read this book, Fabric for Python 3 may well be
available.  You should check, and if it is, use the fabric API instead of
the hop via `subprocess.check_output`.  Lucky you!

Finally, let's look at the fabfile that defines those two commands we want to
run server-side, to reset the database or setup the session:


[role="sourcecode"]
.functional_tests/fabfile.py
[source,python]
----
from fabric.api import env, run


def _get_base_folder(host):
    return '~/sites/' + host

def _get_manage_dot_py(host):
    return '{path}/virtualenv/bin/python {path}/source/manage.py'.format(
        path=_get_base_folder(host)
    )


def reset_database():
    run('rm -f {path}/database/database.sqlite'.format(
        path=_get_base_folder(env.host)
    ))
    run('{manage_py} syncdb --migrate --noinput'.format(
        manage_py=_get_manage_dot_py(env.host)
    ))


def create_session_on_server():
    session_key = run('{manage_py} create_session'.format(
        manage_py=_get_manage_dot_py(env.host)
    ))
    print(session_key)
----

Does that make a reasonable amount of sense?  We've got a function that
can create a session in the database.  If we detect we're running locally,
we call it directly.  If we're against the server, there's a couple of hops:
we use `subprocess` to use fabric via `fab`, which lets us run a management
command that calls that function on the server.

Let's see if it works...

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.MyListsTest \
--liveserver=superlists-staging.ottg.eu*]
Creating test database for alias 'default'...
[superlists-staging.ottg.eu] Executing task 'reset_database'
[superlists-staging.ottg.eu] run: rm -f
~/sites/superlists-staging.ottg.eu/database/database.sqlite
[superlists-staging.ottg.eu] run:
~/sites/superlists-staging.ottg.eu/virtualenv/bin/python
~/sites/superlists-staging.ottg.eu/source/manage.py syncdb --migrate --noinput
[superlists-staging.ottg.eu] out: Syncing...
[superlists-staging.ottg.eu] out: Creating tables ...
[...]
.
 ---------------------------------------------------------------------
Ran 1 test in 25.701s

OK
----

Looking good!  We can re-run all the tests to make sure...

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests --liveserver=superlists-staging.ottg.eu*]
Creating test database for alias 'default'...
[superlists-staging.ottg.eu] Executing task 'reset_database'
[...]
Ran 7 tests in 89.494s

OK
Destroying test database for alias 'default'...
----

Hooray!

Now we can safely deploy our live site.

I'll tell you what though, those FTs are taking an annoyingly long time to 
run though.  I wonder if there's something we can do about that?


