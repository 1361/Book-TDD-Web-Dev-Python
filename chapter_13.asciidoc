Dipping our toes, very tentatively, into JavaScript
---------------------------------------------------

[quote, 'John Calvin (as portrayed in http://onemillionpoints.blogspot.co.uk/2008/08/calvin-and-chipmunks.html[Calvin and the Chipmunks])']
______________________________________________________________
If the Good Lord had wanted us to enjoy ourselves, he wouldn't have granted us
his precious gift of relentless misery.
______________________________________________________________

Our new validation logic is good, but wouldn't it be nice if the error messages
disappeared once the user started fixing the problem? For that we'd need a
teeny-tiny bit of JavaScript.

We are utterly spoiled by programming every day in such a joyful language as
Python.  JavaScript is our punishment. So let's dip our toes in, very gingerly.

WARNING: I'm going to assume you know the basics of JavaScript syntax. If you
haven't read <<jsgoodparts,JavaScript: The Good Parts>>, go and get yourself
a copy right away!  It's not a very long book.


Starting with an FT
~~~~~~~~~~~~~~~~~~~

Let's add a new functional test to the `ItemValidationTest` class:

[role="sourcecode"]
.lists/functional_tests/test_list_item_validation.py
[source,python]
----
def test_error_messages_are_cleared_on_input(self):
    # Edith starts a new list in a way that causes a validation error:
    self.browser.get(self.server_url)
    self.get_item_input_box().send_keys('\n')
    error = self.browser.find_element_by_css_selector('.has-error')
    self.assertTrue(error.is_displayed()) #<1>

    # She starts typing in the input box to clear the error
    self.get_item_input_box().send_keys('a')

    # She is pleased to see that the error message disappears
    error = self.browser.find_element_by_css_selector('.has-error')
    self.assertFalse(error.is_displayed()) #<1>
----

<1> `is_displayed()` tells you whether an element is visible or not. We
can't just rely on checking whether the element is present in the DOM,
because now we're starting to hide elements.

That fails appropriately, but before we move on:  three strikes and refactor! 
We've got several places where we find the error element using CSS. Let's 
move it to a helper function:

[role="sourcecode"]
.lists/functional_tests/test_list_item_validation.py
[source,python]
----
    def get_error_element(self):
        return self.browser.find_element_by_css_selector('.has-error')
----

//TODO: why is the helper function in here not in base? Explain

And we then make 5 replacements in 'test_list_item_validation', including
these:

[role="sourcecode"]
.lists/functional_tests/test_list_item_validation.py
[source,python]
----
    error = self.get_error_elements()[0]

    # She starts typing in the input box to clear the error
    self.get_item_input_box().send_keys('a')

    # She is pleased to see that the error message disappears
    self.assertEqual(self.get_error_elements(), [])
----

We have an expected failure:

----
    self.assertFalse(error.is_displayed())
AssertionError: True is not false
----

And we can commit this as the first cut of our FT. (I trust you to do this
without needing me to show you how any more!)


Setting up a basic JavaScript test runner
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Choosing your testing tools in the Python and Django world is fairly
straightforward.  The standard library `unittest` module is perfectly
adequate, and the Django test runner also makes a good default choice. 
There are some alternatives out there --
http://nose.readthedocs.org/en/latest/[nose] is popular, and I've personally
found http://pytest.org/[py.test] to be very impressive.  But there is
a clear default option, and it's just fine.
footnote:[Admittedly once you start looking for Python BDD tools, things are a
little more confusing.]

Not so in the JavaScript world!  We use YUI at work, but I thought I'd go out
and see whether there were any new tools out there.  I was overwhelmed with
options -- jsUnit, Qunit, Mocha, Chutzpah, Karma, Testacular, Jasmine, and many
more.  And it doesn't end there either: as I had settled on one of them Mocha
footnote:[purely because it features the
http://visionmedia.github.io/mocha/#nyan-reporter[NyanCat]]
you find out that you now need to choose an 'assertion framework' and a
'reporter', and maybe a 'mocking library', and it never ends!

In the end I decided we should use http://qunitjs.com/[qunit] because it's
simple, and it works well with jQuery.  

NOTE: I was dead keen to use Mocha, because of the Nyan cat test runner.  If
someone can show me a simple mocha setup that lets the user test, in the
browser and from the command-line as well, using the "tdd" ui and the "assert"
assertion library... Well, I'll be eternally grateful.


Make a directory called 'tests' inside 'lists/static', and download the qunit
javascript and css files into it, stripping out version numbers if necessary (I
got version 1.12).  We'll also put a file called 'tests.html' in there:

----
$ tree lists/static/tests/
lists/static/tests/
├── qunit.css
├── qunit.js
└── tests.html
----

The boilerplate for a qunit html file looks like this, including a smoke test:

[role="sourcecode"]
.lists/static/tests/tests.html
[source,html]
----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Javascript tests</title>
    <link rel="stylesheet" href="qunit.css">
</head>

<body>
    <div id="qunit"></div>
    <div id="qunit-fixture"></div>
    <script src="qunit.js"></script>
    <script>
test("smoke test", function() {
    equal(1, 1, "Maths works!" );
});
    </script>

</body>
</html>
----

Disecting that, the important things to pick up are the fact that we pull
in 'qunit.js' using the first `<script>` tag, and then use the second one
to write the main body of tests.

If you open up the file using your web browser (no need to run the dev
server, just find the file on disk) you should see something like this:

.Basic Qunit screen
image::images/qunit_smoke_test.png["Qunit screen showing 1 passing test"]

Looking at the test itself, we'll find many similarities with the Python
tests we've been writing so far:

[role="skipme sourcecode"]
[source,javascript]
----
test("smoke test", function () { // <1>
    equal(1, 1, "Maths works!"); // <2>
});
----

<1> The `test` function defines a test case, a bit like 
`def test_something(self)` did in Python. Its first argument is a name for the
test, and the second is a function closure for the body of the test.
//TODO: is that an incorrect use of the word closure?
<2> The `equal` function is an assertion; very much like `assertEqual`, it
compares two arguments. Unlike in Python, though, the message is displayed
both for failures and for passes, so it should be phrased as a positive rather
than a negative.

Why not try changing those arguments to see a deliberate failure?

Using jquery and the fixtures div
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's get a bit more comfortable with what our testing framework can do,
and start using a bit of jQuery

NOTE: If you've never seen jQuery before, I'm going to try and explain it as we
go, just enough so that you won't be totally lost; but this isn't a jQuery
tutorial.  You may find it helpful to spend an hour or two investigating jQuery
at some point during this chapter.

Let's add jQuery to our scripts, and a few elements to use in our tests:

[role="sourcecode"]
.lists/static/tests/tests.html
[source,html]
----
    <div id="qunit-fixture"></div>

    <form> <1>
        <input name="text" />
        <div class="has-error">Error text</div>
    </form>

    <script src="http://code.jquery.com/jquery.min.js"></script>
    <script src="qunit.js"></script>
    <script>

test("smoke test", function () {
    equal($('.has-error').is(':visible'), true); //<2><3>
    $('.has-error').hide(); //<4>
    equal($('.has-error').is(':visible'), false); //<5>
});

    </script>
----
//ch13l006

<1> The `<form>` and its contents are there to represent what will be
on the real list page.

<2> jQuery magic starts here!  `$` is the jQuery swiss army knife. It's
used to find bits of the DOM.  Its first argument is a CSS selector; here,
we're telling it to find all elements that have the class "error".  It returns
an object that represents one or more DOM elements. That, in turn, has various
useful methods that allow us to manipulate or find out about those elements. 

<3> Here we use `.is`, which can tell us whether an element matches a
particular CSS property. Here we use `:visible` to check whether the element
is displayed or hidden.

<4> We then use jQuery's `.hide()` method to hide the div.  Behind the
scenes, it dynamically sets a `style="display: none"` on the element. 

<5> And finally we check that it's worked, with a second `equal` assertion.


If you refresh the browser, you should see that all passes:

.Expected results from Qunit in browser
----
Tests completed in 27 milliseconds.
2 assertions of 2 passed, 0 failed.
1. smoke test (0, 2, 2)Rerun
----

Time to see how fixtures work.  If we just dupe up this test:


[role="sourcecode"]
.lists/static/tests/tests.html
[source,html]
----
    <script>

test("smoke test", function () {
    equal($('.has-error').is(':visible'), true);
    $('.has-error').hide();
    equal($('.has-error').is(':visible'), false);
});
test("smoke test 2", function () {
    equal($('.has-error').is(':visible'), true);
    $('.has-error').hide();
    equal($('.has-error').is(':visible'), false);
});

    </script>
----

Slightly unexpectedly, we find one of them fails:

.One of the two tests is failing
image::images/qunit_first_test_failure.png["Qunit screen showing only 1 passing test"]

What's happening here is that the first test hides the error div, so when 
the second test runs, it starts out invisible. 

NOTE: Qunit test do not run in a predictable order, so you can't rely on the
first test running before the second one.

We need some way of tidying up between tests, a bit like `setUp` and
`teardDown`, or like the Django test runner would reset the database between
each test.  Thankfully, and you can probably see this coming, but the
`qunit-fixture` div is exactly what we're looking for.  Move the form in there:

[role="sourcecode"]
.lists/static/tests/tests.html
[source,html]
----
    <div id="qunit"></div>
    <div id="qunit-fixture">
        <form>
            <input name="text" />
            <div class="has-error">Error text</div>
        </form>
    </div>

    <script src="http://code.jquery.com/jquery.min.js"></script>
----

And that gets us back to 2 neatly passing tests.

----
Tests completed in 21 milliseconds.
4 assertions of 4 passed, 0 failed.
1. smoke test (0, 2, 2)
2. smoke test 2 (0, 2, 2)
----

Building a JavaScript unit test for our desired functionality
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Switch back to just one test:

[role="sourcecode"]
.lists/static/tests/tests.html
[source,html]
----
    <script>

test("errors should be hidden on keypress", function () {
    $('input').trigger('keypress'); // <1>
    equal($('.has-error').is(':visible'), false); 
});

    </script>
----

<1> The jQuery `.trigger` method is mainly used for testing.  It says "fire off
a JavScript DOM event on the element(s)".  Here we use the 'keypress' event,
which is fired off by the browser behind the scenes whenever a user types
something into a particular input element. 

NOTE: jQuery is hiding a lot of complexity behind the scenes here.  Just check
out http://www.quirksmode.org/dom/events/index.html[Quirksmode.org] for a view
on the hideous nest of differences between the different browsers'
interpretation of events.  The reason that jQuery is so popular is that it just
makes all this stuff go away.

//TODO: also do onclick, to handle paste. show how to FT this too

And that gives us:

----
0 assertions of 1 passed, 1 failed.
1. errors should be hidden on keypress (1, 0, 1)
    1. failed
        Expected: 	false
        Result: 	true
----

Let's say we want to keep our code in a standalone JavaScript file called
'list.js'


[role="sourcecode"]
.lists/static/tests/tests.html
[source,html]
----
    <script src="qunit.js"></script>
    <script src="../list.js"></script>
    <script>
----

Here's the minimal code to get that test to pass:

[role="sourcecode"]
.lists/static/list.js
[source,html]
----
$('.has-error').hide();
----

It has an obvious problem. We'd better add another test:

[role="sourcecode"]
.lists/static/tests/tests.html
[source,html]
----
test("errors not be hidden unless there is a keypress", function () {
    equal($('.has-error').is(':visible'), true);
});
----

Now we get an expected failure:

----
1 assertions of 2 passed, 1 failed.
1. errors should be hidden on keypress (0, 1, 1)
2. errors not be hidden unless there is a keypress (1, 0, 1)
    1. failed
        Expected: 	true
        Result: 	false
        Diff: 	true false 
----

And we can make a more realistic implementation:

[role="sourcecode"]
.lists/static/list.js
[source,html]
----
$('input').on('keypress', function () {
    $('.has-error').hide();
});
----

That gets our unit tests to pass! 

Grand, so let's pull in our script, and jquery, on all our pages:

[role="sourcecode"]
.lists/templates/base.html
[source,html]
----
        </div>

        <script src="http://code.jquery.com/jquery.min.js"></script>
        <script src="/static/list.js"></script>
    </body>
</html>
----

NOTE: It's good practice to put your script-loads at the end of your
body HTML, as it means the user doesn't have to wait for all your
JavaScript to load before they can see something on the page.  It also
helps to make sure most of the DOM has loaded before any scripts run.

//TODO: note re: judgement call.  may need to test js works on all pages.

Aaaand we run our FT:

----
$ python3 manage.py test \
functional_tests.ItemValidationTest.test_error_messages_are_cleared_on_input

.
 ---------------------------------------------------------------------
Ran 1 test in 3.023s

OK
----

Hooray!  That's a commit!

TODO: change list.js to use some kind of "onload" boilerplate.

TODO: take the opportunity to use {% static %} tag in templates?

TODO: note about how I don't 'really' mean it when I'm mean about JS.

.JavaScript testing notes
*******************************************************************************
* One of the great advantages of Selenium is that it allows you to test that
your JavaScript really works, just as it tests your Python code

* There are many JavaScript test running libraries out there.  Qunit is closely
tied to jQuery, which is the main reason I chose it.  

* Qunit mainly expects you to "run" your tests using an actual web browser.
This has the advantage that it's easy to create some HTML fixtures that 
match the kind of HTML your site actually contains, for tests to run against

* I'll say it again: make sure you've read <<jsgoodparts,JavaScript: The Good
Parts>>.

*******************************************************************************

