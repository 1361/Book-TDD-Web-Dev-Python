[[appendix1]]
Appendix II: Django Class-Based Views
-------------------------------------

This appendix follows on from Chapter 9, in which we implemented Django forms
for validation, and refactored our views.  By the end of that chapter, our
views were still using functions.

The new shiny in the Django world, however, is class-based views. In this
chapter, we'll refactor our application to use them instead of view functions.
More specifically, we'll have a go at using class-based 'generic' views.

Class-based generic views
~~~~~~~~~~~~~~~~~~~~~~~~~

It's worth making a distinction at this point, between class-based views
and class-based 'generic' views.  Class-based views are just another way 
of defining view functions.  They make few assumptions about what your
views will do, and they offer one major benefit over view functions, which
is that they can be subclassed.  This comes, arguably, at the expense of
being less readable than traditional function-based views.  The main use
case for 'plain' class-based views is when you have several views that
re-use the same logic.  We want to obey the DRY principle. With function-based
views, you would use helper functions or decorators.  The theory is that using
a class structure may give you a more elegant solution.

Class-based 'generic' views are class-based views that attempt to provide
ready-made solutions to common use cases:  fetching an object from the 
database and passing it to a template, fetching a list of objects, saving
user input from a POST request using a ModelForm, and so on.  These sound very
much like our use cases, but as we'll soon see, the devil is in the detail.

I should say at this point that I've not used either kind of class-based views
much. I can definitely see the sense in them, and there are potentially many
use cases in Django apps where CBGVs would fit in perfectly. However, as soon
as your use case is slightly outside the basics -- as soon as you have more
than one model you want to use, for example, I find that using class-based
views becomes much more complicated, and you end up with code that's harder to
read than a classic view function.  And because we're working with multiple
related models (lists and items), that's the case with our views.

Still, because we're forced to use a lot of the customisation options for
class-based views, implementing them in this case can teach us a lot about
how they work, and how we can unit tests them.

My hope is that the same unit tests we use for function-based views should
work just as well for class-based views.  Let's see how we get on.



[role="sourcecode"]
.lists/views.py (ch21l001)
[source,python]
----
from django.views.generic import FormView
[...]

class HomePageView(FormView):
    template_name = 'home.html'
    form_class = ItemForm
----

And update urls.py, replacing the line that used to say `lists.views.home_page`:

[role="sourcecode"]
.lists/urls.py (ch21l002)
[source,python]
----
    url(r'^$', 'lists.views.home_page', name='home'),
    url(r'^$', HomePageView.as_view(), name='home'),
----

And the tests all check out! that was easy..

----
$ python3 manage.py test lists
Creating test database for alias 'default'...
......................
 ---------------------------------------------------------------------
Ran 22 tests in 0.134s

OK
Destroying test database for alias 'default'...

$ python3 manage.py test functional_tests
Creating test database for alias 'default'...
....
 ---------------------------------------------------------------------
Ran 4 tests in 15.160s

OK
Destroying test database for alias 'default'...
----

Next we have a crack at new_list.  Looking thru the possible CBGVs, we 
probably want a `CreateView`, and we know we're using the `ItemForm` class,
so let's see how we get on with them, and whether the tests will help us:


[role="sourcecode"]
.lists/views.py
[source,python]
----
class NewListView(CreateView):
    form_class = ItemForm
----

----
$ python3 manage.py test lists
Creating test database for alias 'default'...
...................EEE
======================================================================
ERROR: test_redirects_after_POST (lists.tests.test_views.NewListTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/harry/Dropbox/book/source/appendix_II/superlists/lists/tests/test_views.py", line 33, in test_redirects_after_POST
    data={'text': 'A new list item'}
    [...]
  File "/usr/local/lib/python3.3/dist-packages/django/forms/models.py", line 370, in save
    fail_message, commit, construct=False)
  File "/usr/local/lib/python3.3/dist-packages/django/forms/models.py", line 87, in save_instance
    instance.save()
  File "/home/harry/Dropbox/book/source/appendix_II/superlists/lists/models.py", line 26, in save
    self.full_clean()
  File "/usr/local/lib/python3.3/dist-packages/django/db/models/base.py", line 926, in full_clean
    raise ValidationError(errors)
django.core.exceptions.ValidationError: {'list': ['This field cannot be null.']}

======================================================================
ERROR: test_saving_a_POST_request (lists.tests.test_views.NewListTest)
 ---------------------------------------------------------------------
[...]
django.core.exceptions.ValidationError: {'list': ['This field cannot be null.']}

======================================================================
ERROR: test_validation_errors_sent_back_to_home_page_template (lists.tests.test_views.NewListTest)
 ---------------------------------------------------------------------
[...]
django.template.base.TemplateDoesNotExist: No template names provided

 ---------------------------------------------------------------------
Ran 22 tests in 0.114s

FAILED (errors=3)
Destroying test database for alias 'default'...
----


<decode tracebacks>

Let's start with the third -- maybe we can just add the template?

[role="sourcecode"]
.lists/views.py
[source,python]
----
class NewListView(CreateView):
    form_class = ItemForm
    template_name = 'home.html'
----

That gets us down to just two failures.

We retrieve some of our old code and put it into a special method called form_valid:


[role="sourcecode"]
.lists/views.py
[source,python]
----
class NewListView(CreateView):
    template_name = 'home.html'
    form_class = ItemForm

    def form_valid(self, form):
        list = List.objects.create()
        Item.objects.create(text=form.cleaned_data['text'], list=list)
        return redirect(list)
----

That gets us a pass!

----
$ python3 manage.py test lists
Ran 22 tests in 0.117s
OK
$ python3 manage.py test functional_tests
Ran 4 tests in 15.157s
OK
----


And we can even save two lines and use DRY, and the real point of CBVs:
inheritance!

[role="sourcecode"]
.lists/views.py
[source,python]
----
class NewListView(CreateView, HomePageView):

    def form_valid(self, form):
        list = List.objects.create()
        Item.objects.create(text=form.cleaned_data['text'], list=list)
        return redirect('/lists/%d/' % (list.id,))
----

Still passes!

views - with dunderinit version of form

[source,python]
.lists/views.py
----
from django.views.generic.edit import CreateView
from django.views.generic.detail import DetailView

class ListViewAndAddItemView(DetailView, CreateView):
    model = List
    context_object_name = 'list'
    template_name = 'list.html'
    form_class = ItemForm

    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        kwargs.update({'parent_list': self.get_object()})
        return kwargs


def new_list(request):
    list = List.objects.create()
    try:
        Item.objects.create(text=request.POST['item_text'], list=list)
    except ValidationError:
        error_text = "You can't have an empty list item"
        return render(request, 'home.html', {"error": error_text})

    return redirect('/lists/%d/' % (list.id,))
----


Stuff
~~~~~

get absolute url in model:

[source,python]
.lists/models.py
----

class Item(models.Model):
    [...]

    def get_absolute_url(self):
        return reverse('view_list', args=(self.id,))
----

