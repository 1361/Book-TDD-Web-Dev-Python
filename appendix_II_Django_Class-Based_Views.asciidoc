[[appendix1]]
Appendix II: Django Class-Based Views
-------------------------------------

This appendix follows on from Chapter 9, in which we implemented Django forms
for validation, and refactored our views.  By the end of that chapter, our
views were still using functions.

The new shiny in the Django world, however, is class-based views. Now I've
not used class-based views much. I can definitely see the sense in them, 
and there are many use cases in Django apps where they would fit in perfectly:
when you need to be able to display details of a single object on a page,
when you have a form that can update that object or create a new one, then
the combination of Django ModelForms and generic Class-based views can very
quickly give you what you want.

However, as soon as your use case is slightly outside the basics -- as soon
as you have more than one model you want to use, for example, I find that
using class-based views becomes much more complicated, and you end up with
code that's harder to read than a classic view function.  And because
we're working with multiple related models (lists and items), that's the
case with our views.

Still, because we're forced to use a lot of the customisation options for
class-based views, implementing them in this case can teach us a lot about
how they work, and how to write unit tests for them.

My theory is that the same unit tests we use for function-based views should
work just as well for class-based views.  Let's see how we get on.



views - with dunderinit version of form

[source,python]
.lists/views.py
----
from django.views.generic.edit import CreateView
from django.views.generic.detail import DetailView

class ListViewAndAddItemView(DetailView, CreateView):
    model = List
    context_object_name = 'list'
    template_name = 'list.html'
    form_class = ItemForm

    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        kwargs.update({'parent_list': self.get_object()})
        return kwargs


def new_list(request):
    list = List.objects.create()
    try:
        Item.objects.create(text=request.POST['item_text'], list=list)
    except ValidationError:
        error_text = "You can't have an empty list item"
        return render(request, 'home.html', {"error": error_text})

    return redirect('/lists/%d/' % (list.id,))
----


Stuff
~~~~~

get absolute url in model:

[source,python]
.lists/models.py
----

class Item(models.Model):
    [...]

    def get_absolute_url(self):
        return reverse('view_list', args=(self.id,))
----

