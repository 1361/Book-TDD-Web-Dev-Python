Input validation and test organisation
--------------------------------------

Over the next few chapters we'll talk about testing and implementing validation
of user inputs. We'll also take the opportunity to do a little tidying up.

NOTE: I had originally intended to spend just one chapter talking about 
forms and validation.  It's ended up being three.  I'd really like your
feedback -- is it too much?  What, if anything, would you drop?


Validation FT: preventing blank items
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As our first few users start using the site, we've noticed they sometimes make 
mistakes that mess up their lists, like accidentally submitting blank list
items, or accidentally inputting two identical items to a list.  Computers are
meant to help stop us from making silly mistakes, so let's see if we can't get
our site to help!

Let's see how that might work as an FT:


[role="sourcecode"]
.functional_tests/tests.py (ch09l001)
[source,python]
----
def test_cannot_add_empty_list_items(self):
    # Edith goes to the home page and accidentally tries to submit
    # an empty list item. She hits Enter on the empty input box

    # The home page refreshes, and there is an error message saying
    # that list items cannot be blank

    # She tries again with some text for the item, which now works

    # Perversely, she now decides to submit a second blank list item

    # She receives a similar warning on the list page

    # And she can correct it by filling some text in
    self.fail('write me!')
----

That's all very well, but before we go any further -- our functional tests
file is beginning to get a little crowded.  Let's split it out into several
files, in which each has a single test method.  

Remember that functional tests are closely linked to "user stories". If you
were using some sort of project management tool like an issue tracker, you
might make it so that each file matched one issue or ticket, and its filename
contained the ticket ID.  Or, if you prefer to think about things in terms of
"features", where one feature may have several user stories, then you might
have one file and class for the feature, and several methods for each of its
user stories.

We'll also have one base test class which they can all inherit from.  Here's 
how to get there step-by-step:

Skipping a test
^^^^^^^^^^^^^^^

First off, it's always nice, when doing refactoring, to have a fully passing
test suite.  We've just written a test with a deliberate failure. Let's
temporarily switch it off, using a decorator called "skip" from `unittest`:

[role="sourcecode"]
.functional_tests/tests.py (ch09l001-1)
[source,python]
----
from unittest import skip
[...]

    @skip
    def test_cannot_add_empty_list_items(self):
----

This tells the test runner to ignore this test.  You can see it works --
if we re-run the tests, it'll say it passes:

[subs="specialcharacters,quotes"]
----
$ *python3 manage.py test functional_tests*
[...]
Ran 3 tests in 11.577s
OK
----

WARNING: Skips are dangerous -- you need to remember to remove them 
before you commit your changes back to the repo.  This is why line-by-line 
reviews of each of your diffs are a good idea!


.Don't forget the "Refactor" in "Red, Green, Refactor"
**********************************************************************
A criticism that's sometimes levelled at TDD is that it leads to badly
architected code, as the developer just focuses on getting tests to pass
rather than stopping to think about how the whole system should be designed.
I think it's slightly unfair.

It's definitely true that TDD is no silver bullet; you still have to spend
time thinking about good design.  But what often happens is that people
forget the "Refactor" in "Red, Green, Refactor". The methodology allows
you to throw together any old code to get your tests to pass, but it 'also'
asks you to then spend some time refactoring it to improve its design.

Often, however, ideas for how to refactor code will occur to you a few days
after you've written a piece of code -- perhaps weeks or months later, 
as you're writing some new functionality, when you spot some old code with
fresh eyes.  But if you're half-way through something else, should you stop to
refactor the old code?

The answer is: it depends.  In the case at the beginning of the chapter,
we haven't even started writing our new code, we know we are in a working
state, so we can justify putting a skip our new FT (to get back to fully
passing tests) and do a bit of refactoring straight away.

Later in the chapter we'll spot other bits of code we want to alter.
In those cases, rather than taking the risk of refactoring an application
that's not in a working state, we'll make a note of the thing we want to
change, and wait until we're back to a fully passing test suite before 
refactoring.
**********************************************************************


Splitting functional tests out into many files
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

NOTE: this chapter depends on Django 1.6.  If you started with an old version
of the book that used Django 1.5, upgrade now with a 
`pip install --upgrade django`
//TODO: remove me

We start putting each test into its own class, still in the same file:

[role="sourcecode"]
.functional_tests/tests.py (ch09l002)
[source,python]
----
class FunctionalTest(LiveServerTestCase):

    @classmethod
    def setUpClass(cls):
        [...]
    @classmethod
    def tearDownClass(cls):
        [...]
    def setUp(self):
        [...]
    def tearDown(self):
        [...]
    def check_for_row_in_list_table(self, row_text):
        [...]


class NewVisitorTest(FunctionalTest):

    def test_can_start_a_list_and_retrieve_it_later(self):
        [...]



class LayoutAndStylingTest(FunctionalTest):

    def test_layout_and_styling(self):
        [...]



class ItemValidationTest(FunctionalTest):

    @skip
    def test_cannot_add_empty_list_items(self):
        [...]
----

At this point we can re-run the FTs and see they all still work.  

----
Ran 3 tests in 11.577s

OK
----

That's labouring it a little bit, and we could probably get away doing this
stuff in fewer steps, but, as I keep saying, practising the step-by-step method
on the easy cases makes it that much easier when we have a complex case.

Now we switch from a single tests file to using one for each class, and one
"base" file to contain the base class all the tests will inherit from.  We'll
make 4 copies of 'tests.py', naming them appropriately, and then delete the
parts we don't need from each:

[subs="specialcharacters,quotes"]
----
$ *git mv functional_tests/tests.py functional_tests/base.py*
$ *cp functional_tests/base.py functional_tests/test_simple_list_creation.py*
$ *cp functional_tests/base.py functional_tests/test_layout_and_styling.py*
$ *cp functional_tests/base.py functional_tests/test_list_item_validation.py*
----

'base.py' can be cut down to just the FunctionalTest class.  We leave the
helper method on the base class, because we suspect we're about to re-use
it in our new FT.

[role="sourcecode"]
.functional_tests/base.py (ch09l003)
[source,python]
----
from django.test import LiveServerTestCase
from selenium import webdriver
import sys

class FunctionalTest(LiveServerTestCase):

    @classmethod
    def setUpClass(cls):
        [...]
    def tearDownClass(cls):
        [...]
    def setUp(self):
        [...]
    def tearDown(self):
        [...]
    def check_for_row_in_list_table(self, row_text):
        [...]
----

NOTE: Keeping helper methods in a base FunctionalTest class is one useful way 
of preventing duplication in FTs.  Later in the book we'll use the "Page
pattern", which is related, but prefers composition over inheritance.

Our first FT is now in its own file, and should be just one class and one test
method:

[role="sourcecode"]
.functional_tests/test_simple_list_creation.py (ch09l004)
[source,python]
----
from .base import FunctionalTest
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

class NewVisitorTest(FunctionalTest):

    def test_can_start_a_list_and_retrieve_it_later(self):
        [...]
----

I used a relative import (`from .base`). Some people like to use those a lot
more often in Django code (eg, your views might import models using `from
.models import List`, instead of `from list.models`). Ultimately this is a
matter of personal preference.  I prefer to use relative imports only when I'm
super-super sure that the relative position of source.  That applies in this
case because I know for sure all the test will sit next to base.py which they
inherit from.

The layout and styling FT should now be one file and one class:

[role="sourcecode"]
.functional_tests/test_layout_and_styling.py (ch09l005)
[source,python]
----
from .base import FunctionalTest

class LayoutAndStylingTest(FunctionalTest):
        [...]
----


Lastly our new validation test is in a file of its own too:


[role="sourcecode"]
.functional_tests/test_list_item_validation.py (ch09l006)
[source,python]
----
from unittest import skip
from .base import FunctionalTest

class ItemValidationTest(FunctionalTest):

    @skip
    def test_cannot_add_empty_list_items(self):
        [...]
----

And we can test everything worked by re-running `manage.py test
functional_tests`, and checking once again that all three tests are run.

----
Ran 3 tests in 11.577s

OK
----

Now we can remove our skip:

[role="sourcecode"]
.functional_tests/test_list_item_validation.py (ch09l007)
[source,python]
----
class ItemValidationTest(FunctionalTest):

    def test_cannot_add_empty_list_items(self):
        [...]
----


Running a single test file
^^^^^^^^^^^^^^^^^^^^^^^^^^

As a side-bonus, we're now able to run an individual test file, like this:

[subs="specialcharacters,quotes"]
----
$ *python3 manage.py test functional_tests.test_list_item_validation*
[...]
AssertionError: write me!
----

Brilliant, no need to sit around waiting for all the FTs when we're only
interested in a single one. Although we need to remember to run all of them
now and again, to check for regressions.  Later in the book we'll see how
to give that task over to an automated Continuous Integration loop. For now
let's commit!

[subs="specialcharacters,quotes"]
----
$ *git status* 
$ *git add functional_tests* 
$ *git commit -m"Moved Fts into their own individual files"*
----


Fleshing out the FT
^^^^^^^^^^^^^^^^^^^

Now let's start implementing the test, or at least the beginning of it.


[role="sourcecode"]
.functional_tests/test_list_item_validation.py (ch09l008)
[source,python]
----
def test_cannot_add_empty_list_items(self):
    # Edith goes to the home page and accidentally tries to submit
    # an empty list item. She hits Enter on the empty input box
    self.browser.get(self.server_url)
    self.browser.find_element_by_id('id_new_item').send_keys('\n')

    # The home page refreshes, and there is an error message saying
    # that list items cannot be blank
    error = self.browser.find_element_by_css_selector('.has-error') #<1>
    self.assertEqual(error.text, "You can't have an empty list item")

    # She tries again with some text for the item, which now works
    self.browser.find_element_by_id('id_new_item').send_keys('Buy milk\n')
    self.check_for_row_in_list_table('1: Buy milk') #<2>

    # Perversely, she now decides to submit a second blank list item
    self.browser.find_element_by_id('id_new_item').send_keys('\n')

    # She receives a similar warning on the list page
    self.check_for_row_in_list_table('1: Buy milk')
    error = self.browser.find_element_by_css_selector('.has-error')
    self.assertEqual(error.text, "You can't have an empty list item")

    # And she can correct it by filling some text in
    self.browser.find_element_by_id('id_new_item').send_keys('Make tea\n')
    self.check_for_row_in_list_table('1: Buy milk')
    self.check_for_row_in_list_table('2: Make tea')
----

A couple of things to note about this test:

<1> We specify we're going to use a CSS class called `.has-error` to mark our
error text.  We'll see that Bootstrap has some useful styling for those
<2> As predicted, we are re-using the `check_for_row_in_list_table` helper
function when we want to confirm that list item submission *does* work.

The technique of keeping helper methods in a parent class is absolutely
vital to preventing duplication across your functional test code.  The day
we decide to change the implementation of how our list table works, we want
to make sure we only have to change our FT code in one place, not in dozens
of places across loads of FTs...

And we're off!

----
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"css selector","selector":".has-error"}' ; Stacktrace: 
----


Using model-layer validation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are two levels at which you can do validation in Django. One is
at the model level, and the other is higher up at the forms level.  I
like to use the lower level whenever possible, partially because I'm
a bit too fond of databases and database integrity rules, and partially
because it's safer -- you can sometimes forget which form you use to 
validate input, but you're always going to use the same database.


Refactoring unit tests into several files
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We're going to want to add another test for our model, but before we
do so, it's time to tidy up our unit tests in a similar way to the
functional tests.  A difference will be that, because the `lists`
app contains real application code as well as test, we'll separate
out the tests into their own folder:

[subs="specialcharacters,quotes"]
----
$ @mkdir lists/tests@
$ @touch lists/tests/__init__.py@
$ @git mv lists/tests.py lists/tests/test_all.py@
$ @git status@
$ @git add lists/tests@
$ @python3 manage.py test lists@
[...]
Ran 10 tests in 0.034s

OK
$ @git commit -m"Move unit tests into a folder with single file"@
----

If you get a message saying "Ran 0 tests", you probably forgot to
add a dunderinit
footnote:["dunder" is shorthand for double-underscore, so "dunderinit" means
'__init__.py']
-- it needs to be there or else the tests folder isn't a valid Python
module...

Now we turn test_all into two files, one called `test_views.py` which
only contains view tests, and one called `test_models.py`:

[subs="specialcharacters,quotes"]
----
$ *git mv lists/tests/test_all.py lists/tests/test_views.py*
$ *cp lists/tests/test_views.py lists/tests/test_models.py*
----

We strip 'test_models.py' down to being just the one test -- it means
it needs far fewer imports:

[role="sourcecode"]
.lists/tests/test_models.py (ch09l009)
[source,python]
----
from django.test import TestCase

from lists.models import Item, List


class ListAndItemModelsTest(TestCase):
        [...]
----

Whereas 'test_views.py'  just loses one class:

[role="sourcecode"]
.lists/tests/test_views.py (ch09l010)
[source,diff]
----
--- a/lists/tests/test_views.py
+++ b/lists/tests/test_views.py
@@ -103,34 +103,3 @@ class ListViewTest(TestCase):
         self.assertNotContains(response, 'other list item 1')
         self.assertNotContains(response, 'other list item 2')
 
-
-
-class ListAndItemModelsTest(TestCase):
-
-    def test_saving_and_retrieving_items(self):
[...]
----

And we re-run the tests to check everything is still there:

[subs="specialcharacters,quotes"]
----
$ *python3 manage.py test lists*
[...]
Ran 10 tests in 0.040s

OK
----

Great!  

[subs="specialcharacters,quotes"]
----
$ *git add lists/tests*
$ *git commit -m "Split out unit tests into two files"*
----

NOTE: Some people like to make their unit tests into a tests folder straight
away, as soon as they start a project, with the addition of another file,
'test_forms.py'. That's a perfectly good idea, I just thought I'd wait until it
became necessary, to avoid doing too much housekeeping all in the first
chapter!



Unit testing model validation and the self.assertRaises context manager
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Let's add a new test method to `ListAndItemModelsTest`, which tries to create
a blank list item:

[role="sourcecode"]
.lists/tests/test_models.py (ch09l012)
[source,python]
----
from django.core.exceptions import ValidationError
class ListAndItemModelsTest(TestCase):
    [...]

    def test_cannot_save_empty_list_items(self):
        list1 = List.objects.create()
        item = Item(list=list1, text='')
        with self.assertRaises(ValidationError):
            item.save()
----

TIP: if you're new to Python, you may never have seen the `with` statement.
It's used with what are called "context managers", which wrap a block of code,
usually with some kind of set-up, clean-up, or error-handling code.  There's a
good write-up in the 
http://docs.python.org/release/2.5/whatsnew/pep-343.html[Python 2.5 release
notes]

This is a new unit testing technique: when we want to check that doing
something will raise an error, we can use the `self.assertRaises` context
manager.  We could have used something like this instead:

[role="skipme"]
[source,python]
----
try:
    item.save()
    self.fail('The full_clean should have raised an exception')
except ValidationError:
    pass
----

But the `with` formulation is neater.  Now, we can try running the test, 
and see if fail:

----
    item.save()
AssertionError: ValidationError not raised
----


Overriding the save method on a model to ensure validation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

And now we discover one of Django's dirty little secrets. 'This test should
already pass'.  If you take a look at the
https://docs.djangoproject.com/en/1.6/ref/models/fields/#blank[docs for the
Django model fields], you'll see that `TextField` actually defaults to
`blank=False`, which means that it 'should' disallow empty values.

So why is the test not failing?  Well, for 
https://groups.google.com/forum/#!topic/django-developers/uIhzSwWHj4c[slightly
tedious historical reasons], Django models don't run full validation on
save.  As we'll see later, any constraints that are actually implemented in the
database will raise errors on save, but Sqlite doesn't support enforcing
emptiness constraints on text columns, and so our save method is letting this
invalid value through silently.

Django does have a method to manually run full validation however, called
`full_clean`.  You can hack it in to see it work if you like:


[role="sourcecode"]
.lists/tests/test_models.py
[source,python]
----
    with self.assertRaises(ValidationError):
        item.save()
        item.full_clean()
----

Which would get the tests to pass.  Let's revert it and make a real
implementation by overriding the model's `save` method:

[role="sourcecode"]
.lists/models.py (ch09l013)
[source,python]
----
class Item(models.Model):
    text = models.TextField()
    list = models.ForeignKey(List)

    def save(self, *args, **kwargs):
        self.full_clean()
        super().save(*args, **kwargs)
----

TIP: It's good practice to use `*args, **kwargs` when overriding Django
model methods like `save`, because they're called from all sorts of strange
places, and you want to make sure those arguments get passed to the superclass
save, so that all the Django magic still works.
//TODO: but I'm not testing that, am I?

That works:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*] 
Creating test database for alias 'default'...
...........
 ---------------------------------------------------------------------
Ran 11 tests in 0.037s

OK
Destroying test database for alias 'default'...
----

TODO: putting full_clean into the model save method may not be a good idea in 
general.  investigate putting it in the view instead.


Handling model validation errors in the view:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Next we want to surface those validation errors from the model into a useful
form for the user.  This is the job of the view and template. We start by
adjusting our tests in the `NewListTest` class.  I'm going to use two slightly
different error-handling patterns here.

In the first case, our URL and view for new lists will optionally render the
same template as the home page, but with the addition of an error message.
Here's a unit test for that:

[role="sourcecode"]
.lists/tests/test_views.py (ch09l014)
[source,python]
----
class NewListTest(TestCase):
    [...]

    def test_validation_errors_sent_back_to_home_page_template(self):
        response = self.client.post('/lists/new', data={'item_text': ''})
        self.assertEqual(Item.objects.all().count(), 0)
        self.assertTemplateUsed(response, 'home.html')
        expected_error =  "You can't have an empty list item"
        self.assertContains(response, expected_error)
----

As we're writing this test, we might get slightly offended by the '/lists/new'
URL, which we're manually entering as a string. We've got a lot of URLs
hard-coded in our tests, in our views, and in our templates, which violates the
DRY principle.  I don't mind a bit of duplication in tests, but we should
definitely be on the lookout for hard-coded URLs in our views and templates,
and make a note to refactor them out.  But we won't do them straight away,
because right now our application is in a broken state. We want to get back
to a working state first.  

As it is, the test fails out with an error -- our view tries to save an item
with blank text, but the model validation raises an exception:

----
django.core.exceptions.ValidationError: {'text': ['This field cannot be
blank.']}
----

So we try our first approach:  using a try/except to detect errors. Obeying the
testing goat, we start by just the try/except and nothing else.  The tests
should tell us what to code next...

[role="sourcecode"]
.lists/views.py (ch09l015)
[source,python]
----
from django.core.exceptions import ValidationError
[...]

def new_list(request):
    list_ = List.objects.create()
    try:
        Item.objects.create(text=request.POST['item_text'], list=list_)
    except ValidationError:
        pass
    return redirect('/lists/%d/' % (list_.id,))
----

As we're looking at the view code, we make a note that there's a hard-coded
URL in there.  Let's add that to our scratchpad:

* remove hard-coded URLs from 'views.py'

Back to the test, which wants us to use a template:

----
AssertionError: No templates used to render the response
----

We try that naively:

[role="sourcecode"]
.lists/views.py (ch09l016)
[source,python]
----
    except ValidationError:
        return render(request, 'home.html')
----

And the tests now tell us to put the error message into the template:

----
AssertionError: False is not true : Couldn't find 'You can't have an empty list
item' in response
----

We do that by passing a new template variable in:

[role="sourcecode"]
.lists/views.py (ch09l017)
[source,python]
----
    except ValidationError:
        error_text = "You can't have an empty list item"
        return render(request, 'home.html', {"error": error_text})
----

And adjusting the template HTML itself -- it's not actually in 'home.html',
it's in the parent template. But while we're looking around for it, we
notice another hard-coded URL:

[role="skipme"]
----
{% block form_action %}/lists/new{% endblock %}
----

We'll make a note to fix that, and then go up to 'base.html':

* remove hard-coded URLs from 'views.py'
* remove hard-coded URLs from form in 'home.html'

Here's what we actually want to change now:

[role="sourcecode"]
.lists/templates/base.html (ch09l018)
[source,html]
----
<form method="POST" action="{% block form_action %}{% endblock %}">
    <input name="item_text" id="id_new_item" class="form-control input-lg" placeholder="Enter a to-do item" />
    {% csrf_token %}
    {% if error %}
        <div class="form-group has-error">
            <span class="help-block">{{ error }}</span>
        </div>
    {% endif %}
</form>
----

Take a look at the http://getbootstrap.com/css/#forms[Bootstrap docs] for more
info on form controls. 

Hmm, it looks like that didn't quite work:

----
AssertionError: False is not true : Couldn't find 'You can't have an empty list
item' in response
----

A little print-based debug...

[role="sourcecode"]
.lists/tests/test_views.py
[source,python]
----
expected_error =  "You can't have an empty list item"
print(response.content.decode())
self.assertContains(response, expected_error)
----

...will show us the cause: Django has 
https://docs.djangoproject.com/en/1.6/topics/templates/#automatic-html-escaping[HTML-escaped]
the apostrophe:

----
<span class="help-block">You can&#39;t have
an empty list item</span>
----

We could hack something like this in to our test:

[role="skipme"]
[source,python]
----
    expected_error =  "You can&#39;t have an empty list item"
----

But using Django's helper function is probably a better idea:


[role="sourcecode"]
.lists/tests/test_views.py (ch09l019)
[source,python]
----
from django.utils.html import escape
[...]

    expected_error =  escape("You can't have an empty list item")
    self.assertContains(response, expected_error)
----

That passes!  Do the FTs pass?
//TODO: check do they really pass, and am i being unclear about deleting an old
//fn called test_redirects_after_POST  

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.test_list_item_validation*] 
[...]
  File "/workspace/superlists/functional_tests/test_list_item_validation.py",
line 24, in test_cannot_add_empty_list_items
[...]
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"id","selector":"id_list_table"}' ; Stacktrace: 

----

Not quite, but they did get a little further.  Checking the `line 24`, we can
see that we've got past the first part of the test, and are now onto the second
check -- that submitting a second empty item also raises an exception.  That's
currently producing a server error instead of a nice exception, so let's fix
that.

But first, a little commit:


[subs="specialcharacters,quotes"]
----
$ *git commit -am"Adjust new list view to render validation errors"*
----


Django pattern: processing POST request in the same view as renders the form
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This time we'll use a slightly different approach, one that's actually a very
common pattern in Django, which is to use the same view to process POST
requests as to render the form that they come from.  Whilst this doesn't fit
the REST-ful URL model quite as well, it has the important advantage that the
same URL can display a form, and display any errors encountered in processing
the user's input.

The current situation is that we have one view and URL for displaying a list,
and one view and URL for processing additions to that list.  We're going to
combine them into one. So, in 'list.html', our form will have a different
target:

[role="sourcecode"]
.lists/templates/list.html (ch09l020)
[source,html]
----
    {% block form_action %}/lists/{{ list.id }}/{% endblock %}
----

Incidentally, that's another item in our to-do list:

* remove hard-coded URLs from 'views.py'
* remove hard-coded URLs from form in 'home.html'
* remove hard-coded URLs from form in 'list.html'

This will immediately break our original functional test:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.test_simple_list_creation*]
AssertionError: '2: Use peacock feathers to make a fly' not found in ['1: Buy
peacock feathers']
----

Now let's change the tests for saving POST requests to existing lists. We
move them both into `ListViewTest`, and make them point at the base list URL:

[role="sourcecode"]
.lists/tests/test_views.py (ch09l021)
[source,python]
----
class ListViewTest(TestCase):

    def test_uses_list_template(self):
        [...]

    def test_passes_correct_list_to_template(self):
        [...]

    def test_displays_only_items_for_that_list(self):
        [...]

    def test_can_save_a_POST_request_to_an_existing_list(self):
        other_list = List.objects.create()
        correct_list = List.objects.create()

        self.client.post(
            '/lists/%d/' % (correct_list.id,),
            data={'item_text': 'A new item for an existing list'}
        )

        self.assertEqual(Item.objects.all().count(), 1)
        new_item = Item.objects.all()[0]
        self.assertEqual(new_item.text, 'A new item for an existing list')
        self.assertEqual(new_item.list, correct_list)


    def test_POST_redirects_to_list_view(self):
        other_list = List.objects.create()
        correct_list = List.objects.create()

        response = self.client.post(
            '/lists/%d/' % (correct_list.id,),
            data={'item_text': 'A new item for an existing list'}
        )
        self.assertRedirects(response, '/lists/%d/' % (correct_list.id,))
----

Note that the `NewItemTest` class disappears.  I've also changed the name
of the redirect test to make it explicit that it only applies to POST 
requests. That gives

----
FAIL: test_POST_redirects_to_list_view (lists.tests.test_views.ListViewTest)
AssertionError: 200 != 302 : Response didn't redirect as expected: Response
code was 200 (expected 302)
[...]
FAIL: test_can_save_a_POST_request_to_an_existing_list
(lists.tests.test_views.ListViewTest)
AssertionError: 0 != 1
----

We change the `view_list` function to handle two types of request,
and delete the `add_item` view:


[role="sourcecode"]
.lists/views.py (ch09l022)
[source,python]
----
def view_list(request, list_id):
    list_ = List.objects.get(id=list_id)
    if request.method == 'POST':
        Item.objects.create(text=request.POST['item_text'], list=list_)
        return redirect('/lists/%d/' % (list_.id,))
    return render(request, 'list.html', {'list': list_})
----


Oops, a couple of unexpected failures:

----
django.core.exceptions.ViewDoesNotExist: Could not import lists.views.add_item.
View does not exist in module lists.views.
[...]
django.core.exceptions.ViewDoesNotExist: Could not import lists.views.add_item.
View does not exist in module lists.views.
----

It's because we've deleted the view, but it's still being referred to in
'urls.py'.  We remove it from there:

[role="sourcecode"]
.lists/urls.py (ch09l023)
[source,python]
----
urlpatterns = patterns('',
    url(r'^(\d+)/$', 'lists.views.view_list', name='view_list'),
    url(r'^new$', 'lists.views.new_list', name='new_list'),
)
----

And that gets us to the `OK`. Let's try a full FT run, to make sure our
refactor is complete:


[subs="specialcharacters,quotes"]
----
$ *python3 manage.py test functional_tests*
[...]

Ran 3 tests in 15.276s

FAILED (errors=1)
----

We're back to the 1 failure in our new functional test. We should commit there.

[subs="specialcharacters,quotes"]
----
$ *git commit -am"Refactor list view to handle new item POSTs"*
----

NOTE: Am I breaking the rule about never refactoring against failing tests?  In
this case, it's allowed, because the refactor is required to get our new
functionality to work.  You should definitely never refactor against failing
'unit' tests.  But it's OK for the FT for the current story you're working to
be failing.

Next we write a new unit test for the validation of items posted 
to the 'existing' lists view.  It's very similar to the one for the 
home page, just a couple of tweaks:

[role="sourcecode"]
.lists/tests/test_views.py (ch09l024)
[source,python]
----
class ListViewTest(TestCase):
    [...]

    def test_validation_errors_end_up_on_lists_page(self):
        listey = List.objects.create()
        
        response = self.client.post(
            '/lists/%d/' % (listey.id,),
            data={'item_text': ''}
        ) 
        self.assertEqual(Item.objects.all().count(), 0)
        self.assertTemplateUsed(response, 'list.html')
        expected_error =  escape("You can't have an empty list item")
        self.assertContains(response, expected_error)
----

//TODO: make a note that we should split this out into multiple tests?

Which should fail, because our view currently doesn't catch validation
errors from the save. 

----
django.core.exceptions.ValidationError: {'text': ['This field cannot be
blank.']}
----

Here's an implementation:


[role="sourcecode"]
.lists/views.py (ch09l025)
[source,python]
----
def view_list(request, list_id):
    list_ = List.objects.get(id=list_id)
    error = None

    if request.method == 'POST':
        try:
            Item.objects.create(text=request.POST['item_text'], list=list_)
            return redirect('/lists/%d/' % (list_.id,))
        except ValidationError:
            error = "You can't have an empty list item"

    return render(request, 'list.html', {'list': list_, "error": error})
----

It's not deeply satisfying is it? There's definitely some duplication of code
here, that try/except occurs twice in 'views.py', and in general things are 
feeling clunky.

Let's wait a bit before we do a refactor though, because we know we're about to
do some slightly different validation coding for duplicate items. We'll just
add it to our scratchpad for now:

* remove hard-coded URLs from 'views.py'
* remove hard-coded URLs from form in 'home.html'
* remove hard-coded URLs from form in 'list.html'
* remove duplication of validation logic in views.


NOTE: One of the reasons that the "three strikes and refactor" rule exists is
that, if you wait until you have three use cases, each might be slightly
different, and it gives you a better view for what the common functionality is.
If you refactor too early, you may find that the third use case doesn't quite
fit with your refactored code...

And that gets us to the end of the test!

----
OK
----

Fantastic.  We're back to a working state, so we can take a look at some
of the items on our scratchpad.  But I'd say it is 'definitely' time for
a tea break first.


Refactor: Removing hard-coded URLs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Do you remember those `name=` parameters in 'urls.py'? We just copied
them across from the default example Django gave us, and I've been giving
them some reasonably descriptive names. Now we find out what they're for!

[role="skipme"]
[source,python]
----
    url(r'^(\d+)/$', 'lists.views.view_list', name='view_list'),
    url(r'^new$', 'lists.views.new_list', name='new_list'),
----

The {% url %} template tag
^^^^^^^^^^^^^^^^^^^^^^^^^^

We can replace the hard-coded URL in 'home.html' with a Django template tag
which refers to the URL's "name":

[role="sourcecode"]
.lists/templates/home.html (ch09l026-1)
[source,html]
----
{% block form_action %}{% url 'new_list' %}{% endblock %}
----

We check that doesn't break the unit tests:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
OK
----

And we check the functional tests too:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests*]
OK
----

Fabulous, that's one refactor done:

* remove hard-coded URLs from 'views.py'
* [strikethrough line-through]#remove hard-coded URLs from form in 'home.html'#
* remove hard-coded URLs from form in 'list.html'
* remove duplication of validation logic in views.

Let's do the other template while we're at it.  This one is more interesting,
because we pass it a parameter:


[role="sourcecode"]
.lists/templates/list.html (ch09l026-2)
[source,html]
----
{% block form_action %}{% url 'view_list' list.id %}{% endblock %}
----

Check out the 
https://docs.djangoproject.com/en/1.6/topics/http/urls/#reverse-resolution-of-urls[Django
docs on reverse url resolution] for more info.

We run the tests again, and check they all pass (or get to the expected
self.fail):

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
OK
$ pass:quotes[*python3 manage.py test functional_tests*]
OK
----

That's worthy of a commit:

[subs="specialcharacters,quotes"]
----
$ *git commit -am"Refactor hard-coded URLs out of templates"*
----

Using get_absolute_url for redirects
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now let's tackle 'views.py. One way of doing it is just like in the
template, passing in the name of the URL and a positional argument:

[role="sourcecode"]
.lists/views.py (ch09l026-3)
[source,python]
----
def new_list(request):
    [...]
    return redirect('view_list', list_.id)
----

That would get the unit and functional tests passing, but the `redirect`
function can do even better magic than that!  In Django, because Model objects
are often associated with a particular URL, you can define a special function
called `get_absolute_url` which says what page diplays the item.  It's useful
in this case, but it's also useful in the Django admin view (which we'll see
later in the book): it will let you jump from looking at an object in the admin
view to looking at the object on the live site. I'd always recommend defining
a `get_absolute_url` for a model whenever there is one that makes sense, it
takes no time at all.

All it takes is a super-simple unit test in 'test_models.py':

[role="sourcecode"]
.lists/tests/test_models.py (ch09l026-4)
[source,python]
----
    def test_get_absolute_url(self):
        list1 = List.objects.create()
        self.assertEqual(list1.get_absolute_url(), '/lists/%d/' % (list1.id,))
----

//TODO: simplify first model test at this point??

Which gives

----
AttributeError: 'List' object has no attribute 'get_absolute_url'
----

And the implementation use one of Django's shortcut functions, so again we
obey DRY and avoid using a hard-coded string:

[role="sourcecode"]
.lists/models.py (ch09l026-5)
[source,python]
----
from django.shortcuts import resolve_url


class List(models.Model):

    def get_absolute_url(self):
        return resolve_url('view_list', self.id)
----

// TODO: resolve_url is currently undcomented. Switch to using reverse, which has
// a known stable API.

And now we can use it in the view -- the `redirect` function just takes the
object we want to redirect to, and it uses `get_absolute_url` under the
hood automagically!


[role="sourcecode"]
.lists/views.py (ch09l026-6)
[source,python]
----
def new_list(request):
    [...]
    return redirect(list_)
----

There's more info in the
https://docs.djangoproject.com/en/1.6/topics/http/shortcuts/#redirect[Django
docs].  Quick check that the unit tests still pass:

[subs="specialcharacters,macros"]
----
OK
----

Then we do the same to `view_list`:

[role="sourcecode"]
.lists/views.py (ch09l026-7)
[source,python]
----
def view_list(request, list_id):
    [...]

        try:
            Item.objects.create(text=request.POST['item_text'], list=list_)
            return redirect(list_)
        except ValidationError:
            error = "You can't have an empty list item"
----

And a full unit test and functional test run to assure ourselves that
everything still works:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
OK
$ pass:quotes[*python3 manage.py test functional_tests*]
OK
----

Cross off our todos:

* [strikethrough line-through]#remove hard-coded URLs from 'views.py'#
* [strikethrough line-through]#remove hard-coded URLs from form in 'home.html'#
* [strikethrough line-through]#remove hard-coded URLs from form in 'list.html'#
* remove duplication of validation logic in views.

And a commit:

[subs="specialcharacters,quotes"]
----
$ *git commit -am"Use get_absolute_url on List model to DRY urls in views"*
----

That final to-do item will be the subject of the next chapter...


.Tips on organising tests and refactoring
*******************************************************************************
Use a tests folder::
    Just as you use multiple files to hold your application code, you should
    split your tests out into multiple files.
    +
    * Use a folder called 'tests', adding a '__init__.py' which imports all
    test classes
    * For functional test, group them into tests for a particular feature or
    user story
    * For unit tests, you want a separate test file for each tested source code
    file. For Django, that's typically 'test_models.py', 'test_views.py',
    'test_forms.py'
    * Have at least a placeholder test for *every* function and class

Don't forget the "Refactor" in "Red, Green, Refactor"::
    The whole point of having tests is to allow you to refactor your code!
    Use them, and make your code as clean as you can.  

Don't refactor against failing tests::
    * In general!
    * But the FT you're currently working on doesn't count.
    * You can occasionally put a skip on a test which is testing something you
    haven't written yet.  
    * More commonly, make a note of the refactor you want to do, finish what
    you're working on, and do the refactor a little later, when you're back to
    a working state
    * Don't forget to remove any skips before you commit your code! You should
    always review your diffs line by line to catch things like this.
*******************************************************************************

