Forms and input validation
--------------------------

In this chapter we'll learn how to test and implement validation of user inputs
using Django forms. We'll also take the opportunity to do a little tidying up.

NOTE: this chapter is still in draft form, you may see a few TODOs.  Your
feedback is, as ever, earnestly solicited.


Validation: preventing blank and duplicate list items
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As our first few users start using the site, we've noticed they sometimes make 
mistakes which mess up their lists, like accidentally submitting blank list
items, and accidentally inputting 2 identical items to a list.  Computers are
meant to help stop us from making silly mistakes, so let's see if we can't get
our site to help!

Let's see how that might work as an FT:


[role="sourcecode"]
.functional_tests/tests.py (ch09l001)
[source,python]
----
def test_cannot_add_empty_list_items(self):
    # Edith goes to the home page and accidentally tries to submit
    # an empty list item. She hits Enter on the empty input box

    # The home page refreshes, and there is an error message saying
    # that list items cannot be blank

    # She tries again with some text for the item, which now works

    # Perversely, she now decides to submit a second blank list item

    # She receives a similar warning on the list page

    # And she can correct it by filling some text in
    self.fail('write me!')
----

That's all very well, but before we go any further -- our functional tests
file is beginning to get a little crowded.  Let's split it out into several
files, in which each has a single test method.  

Remember that functional tests map to "user stories". If you were using some
sort of project management tool like an issue tracker, you might make it so
that each file matched one issue or ticket, and its filename contained the
ticket ID.

We'll also have one base test class which they can all inherit from.  Here's 
how to get there step-by-step:

Start by switching from using a tests file to a tests folder. In order for the
Django test runner to still work, we need to make sure the new tests module,
which is now a folder instead of a file, still has all the same tests -- we do
this by doing an import in the '__init__.py':

[subs="specialcharacters,quotes"]
----
$ *mkdir functional_tests/tests*
$ *touch functional_tests/tests/__init__.py*
$ *git mv functional_tests/tests.py functional_tests/tests/base.py*
$ @echo "from .base import *" >> functional_tests/tests/__init__.py@
----

NOTE: Two things re: `from .base import *`. Firstly, these universal 
test-imports are one of the only places in which it's a good idea to use
`import *`.  Secondly, I used a relative import (`from .base`). Some people
like to use those a lot more often in Django code (eg, your views might import
models using `from .models import List`, instead of `from list.models`.
Ultimately this is a matter of personal preference.  I prefer to use relative 
imports only when I'm super-super sure that the relative position of source
code files isn't going to change.
http://www.python.org/dev/peps/pep-0008/#imports[PEP 8] has more to say on
this.

And now we check that we can still see all 3 tests being run if we run
the FTs as before:

[subs="specialcharacters,quotes"]
----
$ *python3 manage.py test functional_tests*
[...]
AssertionError: write me!
Ran 3 tests in 11.290s
----

That works, we can do a first commit

[subs="specialcharacters,quotes"]
----
$ *git add functional_tests/tests*
$ *git commit -m "Move FTs into a tests folder"*
----

Now we prepare a base class for all the tests to inherit from, and have
each test be in its own class:

[role="sourcecode"]
.functional_tests/tests/base.py (ch09l002)
[source,python]
----
class FunctionalTest(LiveServerTestCase):

    @classmethod
    def setUpClass(cls):
        [...]
    def tearDownClass(cls):
        [...]
    def setUp(self):
        [...]
    def tearDown(self):
        [...]
    def check_for_row_in_list_table(self, row_text):
        [...]


class NewVisitorTest(FunctionalTest):

    def test_can_start_a_list_and_retrieve_it_later(self):
        [...]



class LayoutAndStylingTest(FunctionalTest):

    def test_layout_and_styling(self):
        [...]



class ItemValidationTest(FunctionalTest):

    def test_cannot_add_empty_list_items(self):
        [...]
----

Again, we can re-run the FTs and see they all still work.  I'm labouring this a
little bit, we could probably get away doing this stuff in less steps, but, as
I keep saying, practising the step-by-step method on the easy cases makes it
that much easier when we have a complex case.

Now we can split each class out into its own file.  It's easy to do this
by making 3 new copies of 'base.py', deleting all the irrelevant bits from
each and just keeping one import:

[subs="specialcharacters,quotes"]
----
*cp functional_tests/tests/base.py functional_tests/tests/test_simple_list_creation.py*
*cp functional_tests/tests/base.py functional_tests/tests/test_layout_and_styling.py*
*cp functional_tests/tests/base.py functional_tests/tests/test_list_item_validation.py*
----

'base.py' can be cut down to just the FunctionalTest class.  We leave the
helper method on the base class, because we suspect we're about to re-use
it in our new FT.

NOTE: Keeping helper methods in a base FunctionalTest class is a useful way 
of preventing duplication in FTs.  Later in the book we'll use the Page
pattern, which is related.

[role="sourcecode"]
.functional_tests/tests/base.py (ch09l003)
[source,python]
----
from django.test import LiveServerTestCase
from selenium import webdriver
import sys

class FunctionalTest(LiveServerTestCase):

    def check_for_row_in_list_table(self, row_text):
        [...]

----

Our first FT is now in its own file, with one class and one test method:

[role="sourcecode"]
.functional_tests/tests/test_simple_list_creation.py (ch09l004)
[source,python]
----
from .base import FunctionalTest
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

class NewVisitorTest(FunctionalTest):
    def test_can_start_a_list_and_retrieve_it_later(self):
        [...]
----

The layout and styling FT is now one file and one class:

[role="sourcecode"]
.functional_tests/tests/test_layout_and_styling.py (ch09l005)
[source,python]
----
from .base import FunctionalTest

class LayoutAndStylingTest(FunctionalTest):
        [...]
----

And finally our new validation test is in a file of its own too:

[role="sourcecode"]
.functional_tests/tests/test_list_item_validation.py (ch09l006)
[source,python]
----
from .base import FunctionalTest

class ItemValidationTest(FunctionalTest):
        [...]
----

Finally we need to change the tests module's dunderinit to import our 3
test classes:


[role="sourcecode"]
.functional_tests/tests/__init__.py (ch09l007)
[source,python]
----
from .test_simple_list_creation import NewVisitorTest
from .test_layout_and_styling import LayoutAndStylingTest
from .test_list_item_validation import ItemValidationTest
----

And we can test everything worked by re-running `manage.py test`, and checking
once again that all 3 tests are run.

----
AssertionError: write me!
----

As a side-bonus, we're now able to run an individual test class, like this:

[subs="specialcharacters,quotes"]
----
$ *python3 manage.py test functional_tests.ItemValidationTest*
[...]
AssertionError: write me!
----

Brilliant, no need to sit around waiting for all the FTs when we're only
interested in a single one. Although we need to remember to run all of them
now and again, to check for regressions.  Later in the book we'll see how
to give that task over to an automated Continuous Integration loop. For now
let's commit!

[subs="specialcharacters,quotes"]
----
$ *git status* 
$ *git add functional_tests* 
$ *git commit -m"Moved Fts into their own individual files"*
----


Now let's start implementing the test, or at least the beginning of it:


[role="sourcecode"]
.functional_tests/tests/test_list_item_validation.py (ch09l008)
[source,python]
----
def test_cannot_add_empty_list_items(self):
    # Edith goes to the home page and accidentally tries to submit
    # an empty list item. She hits Enter on the empty input box
    self.browser.get(self.server_url)
    self.browser.find_element_by_id('id_new_item').send_keys('\n')

    # The home page refreshes, and there is an error message saying
    # that list items cannot be blank
    error = self.browser.find_element_by_css_selector('.error') #<1>
    self.assertEqual(error.text, "You can't have an empty list item")

    # She tries again with some text for the item, which now works
    self.browser.find_element_by_id('id_new_item').send_keys('Buy milk\n')
    self.check_for_row_in_list_table('1: Buy milk') #<2>

    # Perversely, she now decides to submit a second blank list item
    self.browser.find_element_by_id('id_new_item').send_keys('\n')

    # She receives a similar warning on the list page
    self.check_for_row_in_list_table('1: Buy milk')
    error = self.browser.find_element_by_css_selector('.error')
    self.assertEqual(error.text, "You can't have an empty list item")

    # And she can correct it by filling some text in
    self.browser.find_element_by_id('id_new_item').send_keys('Make tea\n')
    self.check_for_row_in_list_table('1: Buy milk')
    self.check_for_row_in_list_table('2: Make tea')

    self.fail("Don't forget to also test duplicate items!")

----

A couple of things to note about this test:

<1> We specify we're going to use a CSS class called `.error` to mark our
error text.  We'll see that Bootstrap has some useful styling for those
<2> As predicted, we are re-using the `check_for_row_in_list_table` helper
function when we want to confirm that list item submission *does* work.

TODO: actually use those bootstrap classes! 

The technique of keeping helper methods in a parent class is absolutely
vital to preventing duplication across your functional test code.  The day
we decide to change the implementation of how our list table works, we want
to make sure we only have to change our FT code in one place, not in dozens
of places across loads of FTs...

And we're off!

----
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"css selector","selector":".error"}' ; Stacktrace: 
----


Using model-layer validation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are two levels at which you can do validation in Django. One is
at the model level, and the other is higher up at the forms level.  I
like to use the lower level whenever possible, partially because I'm
a bit too fond of databases and database integrity rules, and partially
because it's safer -- you can sometimes forget which form you use to 
validate input, but you're always going to use the same database.


Refactoring unit tests into several files
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We're going to want to add another test for our model, but before we
do so, it's time to tidy up our unit tests in a similar way to the
functional tests:

[subs="specialcharacters,quotes"]
----
$ @mkdir lists/tests@
$ @touch lists/tests/__init__.py@
$ @git mv lists/tests.py lists/tests/test_all.py@
$ @echo "from .test_all import *" > lists/tests/__init__.py@
$ @git st@
$ @git add lists/tests@
$ @python3 manage.py test lists@
[...]
Ran 9 tests in 0.034s

OK
$ @git commit -m"Move unit tests into a folder with single file"@
----

Now we turn test_all into two files, one called `test_views.py` which
only contains view tests, and one called `test_models.py`:

[subs="specialcharacters,quotes"]
----
$ *git mv lists/tests/test_all.py lists/tests/test_views.py*
$ *cp lists/tests/test_views.py lists/tests/test_models.py*
----

We then strip 'test_models.py' down to being just the one test -- it means
it needs far fewer imports:

[role="sourcecode"]
.lists/tests/test_models.py (ch09l009)
[source,python]
----
from django.test import TestCase

from lists.models import Item, List


class ListAndItemModelsTest(TestCase):

    def test_saving_and_retrieving_items(self):
        list = List()
        [...]
----

Whereas 'test_views.py'  just loses one class:

[role="sourcecode"]
.lists/tests/test_views.py (ch09l010)
[source,diff]
----
--- a/lists/tests/test_views.py
+++ b/lists/tests/test_views.py
@@ -103,34 +103,3 @@ class ListViewTest(TestCase):
         self.assertNotContains(response, 'other list item 1')
         self.assertNotContains(response, 'other list item 2')
 
-
-
-class ListAndItemModelsTest(TestCase):
-
-    def test_saving_and_retrieving_items(self):
[...]
----

And we re-run the tests to check everything is still there:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*] 
ImportError: No module named 'lists.tests.test_all'
----

Oops!  Forgot to change the dunderinit:


[role="sourcecode"]
.lists/tests/__init__.py (ch09l011)
[source,python]
----
from .test_models import *
from .test_views import *
----

[subs="specialcharacters,quotes"]
----
$ *python3 manage.py test lists*
[...]
Ran 9 tests in 0.040s

OK
----

Great!  

[subs="specialcharacters,quotes"]
----
$ *git add lists/tests*
$ *git commit -m "Split out unit tests into two files"*
----

NOTE: Some people like to make their unit tests into a tests folder straight
away, as soon as they start a project, with the addition of another file,
'test_forms.py'. That's a perfectly good idea, I just thought I'd wait until it
became necessary, to avoid doing too much housekeeping all in the first
chapter!



Unit testing model validation and the self.assertRaises context manager
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Let's add a new test method to `ListAndItemModelsTest`, which tries to create
a blank list item:

[role="sourcecode"]
.lists/tests/test_models.py (ch09l012)
[source,python]
----
from django.core.exceptions import ValidationError
class ListAndItemModelsTest(TestCase):
    [...]

    def test_cannot_save_empty_list_items(self):
        list1 = List.objects.create()
        item = Item(list=list1, text='')
        with self.assertRaises(ValidationError):
            item.save()
----

This is a new unit testing technique: when we want to check that doing
something will raise an error, we can use the `self.assertRaises` context
manager.  We could have used something like this instead:

[role="skipme"]
[source,python]
----
try:
    item.save()
    self.fail('The full_clean should have raised an exception')
except ValidationError:
    pass
----

But the `with` formulation is neater.  Now, we can try running the test, 
and see if fail:

----
    item.save()
AssertionError: ValidationError not raised
----


Overriding the save method on a model to ensure validation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

And now we discover one of Django's dirty little secrets. 'This test should
already pass'.  If you take a look at the
https://docs.djangoproject.com/en/1.5/ref/models/fields/#blank[docs for the
Django model fields], you'll see that `TextField` actually defaults to
`blank=False`, which means that it 'should' disallow empty values.

So why is the test not failing?  Well, for 
https://groups.google.com/forum/#!topic/django-developers/uIhzSwWHj4c[slightly
tedious historical reasons], Django models don't run full validation on
save.  As we'll see later, any constraints that are actually implemented in the
database will raise errors on save, but Sqlite doesn't support enforcing
emptiness constraints on text columns, and so our save method is letting this
invalid value through silently.

Django does have a method to manually run full validation however, called
`full_clean`.  You can hack it in to see it work if you like:


[role="sourcecode"]
.lists/tests/test_models.py
[source,python]
----
    with self.assertRaises(ValidationError):
        item.save()
        item.full_clean()
----

Which would get the tests to pass.  Let's revert it an make a real
implementation by overriding the model's `save` method:

[role="sourcecode"]
.lists/models.py (ch09l013)
[source,python]
----
class Item(models.Model):
    text = models.TextField()
    list = models.ForeignKey(List)

    def save(self, *args, **kwargs):
        self.full_clean()
        super().save(*args, **kwargs)
----

NOTE: It's good practice to use `*args, **kwargs` when overriding Django
model methods like `save`, because they're called from all sorts of strange
places, and you want to make sure those arguments get passed to the superclass
save, so that all the Django magic still works.

That works:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*] 
Creating test database for alias 'default'...
..........
 ---------------------------------------------------------------------
Ran 10 tests in 0.037s

OK
Destroying test database for alias 'default'...
----


Handling model validation errors in the view:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Next we want to surface those validation errors from the model into a useful
form for the user.  This is the job of the view and template. We start by
adjusting our tests in the `NewListTest` class.  I'm going to use two slightly
different error-handling patterns here.

In the first case, our URL and view for new lists will optionally render the
same template as the home page, but with the addition of an error message.
Here's a unit test for that:

[role="sourcecode"]
.lists/tests/test_views.py (ch09l014)
[source,python]
----
class NewListTest(TestCase):
    [...]

    def test_validation_errors_sent_back_to_home_page_template(self):
        response = self.client.post('/lists/new', data={'item_text': ''})
        self.assertEqual(Item.objects.all().count(), 0)
        self.assertTemplateUsed(response, 'home.html')
        expected_error =  "You can't have an empty list item"
        self.assertContains(response, expected_error)
----

As we're writing this test, we might get slightly offended by the '/lists/new'
URL, which we're manually entering as a string. We've got a lot of URLs
hard-coded in our tests, in our views, and in our templates, which violates the
DRY principle.  I don't mind a bit of duplication in tests, but we should
definitely be on the lookout for hard-coded URLs in our views and templates,
and make a note to refactor them out.  But we won't do them straight away,
because right now our application is in a broken state. We want to get back
to a working state first.  

As it is, the test fails out with an error -- our view tries to save an item
with blank text, but the model validation raises an exception:

----
django.core.exceptions.ValidationError: {'text': ['This field cannot be
blank.']}
----

So we try our first approach:  using a try/except to detect errors. Obeying the
testing goat, we start by just the try/except and nothing else.  The tests
should tell us what to code next...

[role="sourcecode"]
.lists/views.py (ch09l015)
[source,python]
----
from django.core.exceptions import ValidationError
[...]

def new_list(request):
    list = List.objects.create()
    try:
        Item.objects.create(text=request.POST['item_text'], list=list)
    except ValidationError:
        pass
    return redirect('/lists/%d/' % (list.id,))
----

As we're looking at the view code, we make a note that there's a hard-coded
URL in there.  Let's add that to our scratchpad:

* remove hard-coded URLs from 'views.py'

Back to the test, which wants us to use a template:

----
AssertionError: No templates used to render the response
----

We try that naively:

[role="sourcecode"]
.lists/views.py (ch09l016)
[source,python]
----
    except ValidationError:
        return render(request, 'home.html')
----

And the tests now tell us to put the error message into the template:

----
AssertionError: False is not true : Couldn't find 'You can't have an empty list
item' in response
----

We do that by passing a new template variable in:

[role="sourcecode"]
.lists/views.py (ch09l017)
[source,python]
----
    except ValidationError:
        error_text = "You can't have an empty list item"
        return render(request, 'home.html', {"error": error_text})
----

And adjusting the template itself:

[role="sourcecode"]
.lists/templates/home.html (ch09l018)
[source,html]
----
    <form method="POST" action="/lists/new" >
        <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
        {% csrf_token %}
        {% if error %}
            <p class="error">{{ error }}</p>
        {% endif %}
    </form>
----

Making a note of another hard-coded URL in the form:

* remove hard-coded URLs from 'views.py'
* remove hard-coded URLs from form in 'home.html'

Hmm, it looks like this code doesn't quite work:

----
AssertionError: False is not true : Couldn't find 'You can't have an empty list
item' in response
----

A little print-based debug...

[role="sourcecode"]
.lists/tests/test_views.py
[source,python]
----
expected_error =  "You can't have an empty list item"
print(response.content.decode())
self.assertContains(response, expected_error)
----

...will show us the cause: Django has HTML-escaped the apostrophe:

----
<p class="error">You can&#39;t have an empty list item</p>
----

We could hack something like this in to our test:

[role="skipme"]
[source,python]
----
    expected_error =  "You can&#39;t have an empty list item"
----

But using Django's helper function is probably a better idea:


[role="sourcecode"]
.lists/tests/test_views.py (ch09l019)
[source,python]
----
from django.utils.html import escape
[...]

    expected_error =  escape("You can't have an empty list item")
    self.assertContains(response, expected_error)
----

That passes!  Do the FTs pass?


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.ItemValidationTest*] 
[...]
  File
"/workspace/superlists/functional_tests/tests/test_list_item_validation.py",
line 24, in test_cannot_add_empty_list_items
[...]
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"id","selector":"id_list_table"}' ; Stacktrace: 

----

Not quite, but they did get a little further.  Checking the `line 24`, we can
see that we've got past the first part of the test, and are now onto the second
check -- that submitting a second empty item also raises an exception.  That's
currently producing a server error instead of a nice exception, so let's fix
that.

First, a little commit:


[subs="specialcharacters,quotes"]
----
$ *git commit -am"Adjust new list view to render validation errors"*
----


Django pattern: processing POST request in the same view as renders the form
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This time we'll use a slightly different approach, one that's actually a very
common pattern in Django, which is to use the same view to process POST
requests as to render the form that they come from.  Whilst this doesn't fit
the REST-ful URL model quite as well, it has the important advantage that the
same URL can display a form, and display any errors encountered in processing
the user's input.

So, in 'list.html', our form will have a different target:

[role="sourcecode"]
.lists/templates/list.html (ch09l020)
[source,html]
----
    <form method="POST" action="/lists/{{ list.id }}/" >
----

Incidentally, that's another item in our to-do list:

* remove hard-coded URLs from 'views.py'
* remove hard-coded URLs from form in 'home.html'
* remove hard-coded URLs from form in 'list.html'

This will immediately break our original functional test:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.NewVisitorTest*]
AssertionError: '2: Use peacock feathers to make a fly' not found in ['1: Buy
peacock feathers']
----

Now let's change the tests for saving POST requests to existing lists. We
move them both into `ListViewTest`, and make them point at the base list URL:

[role="sourcecode"]
.lists/tests/test_views.py (ch09l021)
[source,python]
----
class ListViewTest(TestCase):

    def test_list_view_passes_list_to_list_template(self):
        [...]

    def test_list_view_displays_items_for_that_list(self):
        [...]

    def test_can_save_a_POST_request_to_an_existing_list(self):
        [...]
        self.client.post(
            '/lists/%d/' % (correct_list.id,),
            data={'item_text': 'A new item for an existing list'}
        )

    def test_POST_redirects_to_list_view(self):
        [...]
        response = self.client.post(
            '/lists/%d/' % (correct_list.id,),
----

Note that the `NewItemTest` class disappears.  I've also changed the name
of the redirect test to make it explicit that it only applies to POST 
requests. That gives

----
FAIL: test_POST_redirects_to_list_view (lists.tests.test_views.ListViewTest)
AssertionError: 200 != 302 : Response didn't redirect as expected: Response
code was 200 (expected 302)
[...]
FAIL: test_can_save_a_POST_request_to_an_existing_list
(lists.tests.test_views.ListViewTest)
AssertionError: 0 != 1
----

We change the `view_list` function to handle two types of request,
and delete the `add_item` view:


[role="sourcecode"]
.lists/views.py (ch09l022)
[source,python]
----
def view_list(request, list_id):
    list = List.objects.get(id=list_id)
    if request.method == 'POST':
        Item.objects.create(text=request.POST['item_text'], list=list)
        return redirect('/lists/%d/' % (list.id,))
    return render(request, 'list.html', {'list': list})
----


Oops, a couple of unexpected failures:

----
django.core.exceptions.ViewDoesNotExist: Could not import lists.views.add_item.
View does not exist in module lists.views.
[...]
django.core.exceptions.ViewDoesNotExist: Could not import lists.views.add_item.
View does not exist in module lists.views.
----

It's because we've deleted the view, but it's still being referred to in
'urls.py'.  We remove it from there:

[role="sourcecode"]
.lists/urls.py (ch09l023)
[source,python]
----
urlpatterns = patterns('',
    url(r'^(\d+)/$', 'lists.views.view_list', name='view_list'),
    url(r'^new$', 'lists.views.new_list', name='new_list'),
)
----

And that gets us to the `OK`. Let's try a full FT run, to make sure our
refactor is complete:


[subs="specialcharacters,quotes"]
----
$ *python3 manage.py test functional_tests*
[...]

Ran 3 tests in 15.276s

FAILED (errors=1)
----

We're back to the 1 failure in our new functional test. We should commit there.

[subs="specialcharacters,quotes"]
----
$ *git commit -am"Refactor list view to handle new item POSTs"*
----


Now we can write a new unit test for the validation of items posted 
to the 'existing' lists view.  It's very similar to the one for the 
home page, just a couple of tweaks:

[role="sourcecode"]
.lists/tests/test_views.py (ch09l024)
[source,python]
----
class ListViewTest(TestCase):
    [...]

    def test_validation_errors_end_up_on_lists_page(self):
        listey = List.objects.create()
        
        response = self.client.post(
            '/lists/%d/' % (listey.id,),
            data={'item_text': ''}
        ) 
        self.assertEqual(Item.objects.all().count(), 0)
        self.assertTemplateUsed(response, 'list.html')
        expected_error =  escape("You can't have an empty list item")
        self.assertContains(response, expected_error)
----

Which should fail, because our view currently doesn't catch validation
errors from the save. 

----
django.core.exceptions.ValidationError: {'text': ['This field cannot be
blank.']}
----

Here's an implementation:


[role="sourcecode"]
.lists/views.py (ch09l025)
[source,python]
----
def view_list(request, list_id):
    list = List.objects.get(id=list_id)
    error = None

    if request.method == 'POST':
        try:
            Item.objects.create(text=request.POST['item_text'], list=list)
            return redirect('/lists/%d/' % (list.id,))
        except ValidationError:
            error = "You can't have an empty list item"

    return render(request, 'list.html', {'list': list, "error": error})
----

It's not deeply satisfying is it? There's definitely some duplication of code
here, that try/except occurs twice in 'views.py', and in general things are 
feeling clunky.

Let's wait a bit before we do a refactor though, because we know we're about to
do some slightly different validation coding for duplicate items. We'll just
add it to our scratchpad for now:

* remove hard-coded URLs from 'views.py'
* remove hard-coded URLs from form in 'home.html'
* remove hard-coded URLs from form in 'list.html'
* remove duplication of validation logic in views.


NOTE: One of the reasons that the "three strikes and refactor" rule exists is
that, if you wait until you have 3 use cases, each might be slightly different,
and it gives you a better view for what the commmon functionality is.  If you
refactor too early, you may find that the 3rd use case doesn't quite fit with
your refactored code...

Meantime we need to add the error to the list template.

[role="sourcecode"]
.lists/templates/list.html (ch09l026)
[source,html]
----
<form method="POST" action="/lists/{{ list.id }}/" >
    <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
    {% csrf_token %}
    {% if error %}
        <p class="error">{{ error }}</p>
    {% endif %}
</form>
----


And that gets us to the end of the test!

----
AssertionError: Don't forget to also test duplicate items!
----

Fantastic!  We're back to a working state, so we can take a look at some
of the items on our scratchpad.  But I'd say it's a good time for a tea
break first...


Refactor: Removing hard-coded URLs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Do you remember those `name=` parameters in 'urls.py'? We just copied
them across from the default example Django gave us, and I've been giving
them some reasonably descriptive names. Now we find out what they're for!

[role="skipme"]
[source,python]
----
    url(r'^(\d+)/$', 'lists.views.view_list', name='view_list'),
    url(r'^new$', 'lists.views.new_list', name='new_list'),
----

The {% url %} template tag
^^^^^^^^^^^^^^^^^^^^^^^^^^

We can replace the hard-coded URL in 'home.html' with a Django template tag
which refers to the URL's "name":

[role="sourcecode"]
.lists/templates/home.html (ch09l026-1)
[source,html]
----
    <form method="POST" action="{% url 'new_list' %}" >
----

We check that doesn't break the unit tests:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
OK
----

And we check the functional tests too:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests*]
AssertionError: Don't forget to also test duplicate items!

Ran 3 tests in 12.932s
----

That's OK, it's the `self.fail` at the end of the test. We're happy the 
application still works just as well.

* remove hard-coded URLs from 'views.py'
* [strikethrough line-through]#remove hard-coded URLs from form in 'home.html'#
* remove hard-coded URLs from form in 'list.html'
* remove duplication of validation logic in views.

Let's do the other template while we're at it.  This one is more interesting,
because we pass it a parameter:


[role="sourcecode"]
.lists/templates/list.html (ch09l026-2)
[source,html]
----
    <form method="POST" action="{% url 'view_list' list.id %}" >
----

More info in the 
https://docs.djangoproject.com/en/1.5/ref/templates/builtins/#url[Django docs
on template tags].

We run the tests again, and check they all pass (or get to the expected
self.fail):

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
OK
$ pass:quotes[*python3 manage.py test functional_tests*]
FAILED (failures=1)
----

That's worthy of a commit:

[subs="specialcharacters,quotes"]
----
$ *git commit -am"Refactor hard-coded URLs out of templates"*
----

Now let's tackle 'views.py. One way of doing it is just like in the
template, passing in the name of the URL and a positional argument:

[role="sourcecode"]
.lists/views.py (ch09l026-3)
[source,python]
----
def new_list(request):
    [...]
    return redirect('view_list', list.id)
----

That would get the unit and functional tests passing, but the `redirect`
function can do even better magic than that!  In Django, because Model objects
are often associated with a particular URL, you can define a special function
called `get_absolute_url` which says what page diplays the item.  It's useful
in this case, but it's also useful in the Django admin view (which we'll see
later in the book): it will let you jump from looking at an object in the admin
view to looking at the object on the live site. I'd always recommend defining
a `get_absolute_url` for a model whenever there is one that makes sense, it
takes no time at all.

All it takes is a super-simple unit test in 'test_models.py':

[role="sourcecode"]
.lists/tests/test_models.py (ch09l026-4)
[source,python]
----
    def test_get_absolute_url(self):
        list1 = List.objects.create()
        self.assertEqual(list1.get_absolute_url(), '/lists/%d/' % (list1.id,))
----

//TODO: simplify first model test at this point??

Which gives


----
AttributeError: 'List' object has no attribute 'get_absolute_url'
----

And the implementation use one of Django's shortcut functions, so again we
obey DRY and avoid using a hard-coded string:

[role="sourcecode"]
.lists/models.py (ch09l026-5)
[source,python]
----
from django.shortcuts import resolve_url


class List(models.Model):

    def get_absolute_url(self):
        return resolve_url('view_list', self.id)
----

And now we can use it in the view -- the `redirect` function just takes the
object we want to redirect to, and it uses `get_absolute_url` under the
hood automagically!


[role="sourcecode"]
.lists/views.py (ch09l026-6)
[source,python]
----
def new_list(request):
    [...]
    return redirect(list)
----

Again, there's more info in the
https://docs.djangoproject.com/en/1.5/topics/http/shortcuts/#redirect[Django
docs]

Grand.  A full unit test and functional test run to assure ourselves that
everything still works:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
OK
$ pass:quotes[*python3 manage.py test functional_tests*]
FAILED (failures=1)
----

Cross off our todos:

* [strikethrough line-through]#remove hard-coded URLs from 'views.py'#
* [strikethrough line-through]#remove hard-coded URLs from form in 'home.html'#
* [strikethrough line-through]#remove hard-coded URLs from form in 'list.html'#
* remove duplication of validation logic in views.

And a commit:

[subs="specialcharacters,quotes"]
----
$ *git commit -am"Use get_absolute_url on List model to DRY urls in views"*
----

And back to our onions...




Another FT for duplicate items
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We can delete the `self.fail` from the previous test and add a second
test method to `ItemValidationTest`:

[role="sourcecode"]
.functional_tests/tests/test_list_item_validation.py (ch09l027)
[source,python]
----
def test_cannot_add_dulicate_items(self):
    # Edith goes to the home page and starts a new list
    self.browser.get(self.server_url)
    self.browser.find_element_by_id('id_new_item').send_keys('Buy wellies\n')
    self.check_for_row_in_list_table('1: Buy wellies')

    # She accidentally tries to enter a duplicate item
    self.browser.find_element_by_id('id_new_item').send_keys('Buy wellies\n')

    # She sees a helpful error message
    self.check_for_row_in_list_table('1: Buy wellies')
    error = self.browser.find_element_by_css_selector('.error')
    self.assertEqual(error.text, "You've already got this in your list")
----

Why have two test methods rather than extending one, or having a new file
and class?  It just feels like these two tests belong together, but are
separate enough to merit being their own class...


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.ItemValidationTest*] 
[...]
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"css selector","selector":".error"}' ; Stacktrace: 

Ran 2 tests in 9.613s
----

OK, so we know the first of the two tests passes now, is there a way to run
just the failing one, I hear you ask!  Why yes indeed -- the technique known
as 'Dontification'.

Dontification
^^^^^^^^^^^^^

[role="sourcecode skipme"]
.lists/functional_tests/test_list_item_validation.py
[source,python]
----
    def DONTtest_cannot_add_empty_list_items(self):
----

We can 'temporarily' rename any of our test methods in such a way that they
don't begin with `test_`, and then the test runner ignores them.

WARNING: Dontification is dangerous -- you need to remember to change it back 
before you commit your changes back to the repo.  This is why line-by-line 
reviews of each of your diffs are a good idea!


Preventing duplicates at the model layer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We add another test to our model unit tests to check that duplicate items
in the same list raise an error

[role="sourcecode"]
.lists/tests/test_models.py (ch09l028)
[source,python]
----
def test_cannot_save_duplicate_items(self):
    list1 = List.objects.create()
    Item.objects.create(list=list1, text='bla')
    with self.assertRaises(ValidationError):
        Item.objects.create(list=list1, text='bla')
----

And, while it occurs to us, we add another test to make sure we don't 
overdo it on our integrity constraints:


[role="sourcecode"]
.lists/tests/test_models.py (ch09l029)
[source,python]
----
def test_CAN_save_same_item_to_different_lists(self):
    list1 = List.objects.create()
    list2 = List.objects.create()
    Item.objects.create(list=list1, text='bla')
    Item.objects.create(list=list2, text='bla') # should not raise
----

I always like to put a little comment for tests which are checking 
that a particular use case should 'not' raise an error, otherwise
it can be hard to see what's being tested.

----
AssertionError: ValidationError not raised
----

If we want to get it deliberately wrong, we can do this:


[role="sourcecode"]
.lists/models.py (ch09l030)
[source,python]
----
class Item(models.Model):
    text = models.TextField(unique=True)
    list = models.ForeignKey(List)
----

That lets us check that our second test really does pick up on this
problem:

----
Traceback (most recent call last):
  File "/workspace/superlists/lists/tests/test_models.py", line 60, in
test_CAN_save_same_item_to_different_lists
    Item.objects.create(list=list2, text='bla') # should not raise
    [...]
django.core.exceptions.ValidationError: {'text': ['Item with this Text already
exists.']}
----

.An aside on when to test for developer stupidity
*******************************************************************************
One of the judgement calls in testing is when you should write tests that sound
like "check we haven't done something stupid".  In general, you should be wary
of these.

In this case, we've written a test to check that you can't save duplicate items
to the same list.  Now, the simplest way to get that test to pass, the way in
which you'd write the least lines of code, would be to make it impossible to
save 'any' duplicate items.  That justifies writing another test, despite the
fact that it would be a "stupid" or "wrong" thing for us to code.

But you can't be writing tests for every possible way we could have coded
something wrong.  If you have a function that adds two numbers, you can write
a couple of tests:

[role="skipme"]
[source,python]
----
assert adder(1, 1) == 2
assert adder(2, 1) == 3
----

But you have the right to assume that the implementation isn't deliberately
screwey or perverse:

[role="skipme"]
[source,python]
----
def adder(a, b):
    # unlikely code!
    if a = 3:
        return 666
    else:
        return a + b
----

One way of putting it is that you should trust yourself not to do something
'deliberately' stupid, but not to do something 'accidentally' stupid.
*******************************************************************************

Great.  The real implementation happens in a special class attribute called
`Meta`, and a constraint which says that that an item must be unique for a
particular list, or in other words, that text and list must be unique together:

[role="sourcecode"]
.lists/models.py (ch09l031)
[source,python]
----
class Item(models.Model):
    text = models.TextField()
    list = models.ForeignKey(List)

    class Meta:
        unique_together = ('list', 'text')


    def save(self, *args, **kwargs):
        [...]
----

You might want to take a quick peek at the 
https://docs.djangoproject.com/en/1.5/ref/models/options/[Django docs on model
meta attributes] at this point.


A little digression on Queryset ordering and string representations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When we run the tests they reveal an unexpected failure:

----
======================================================================
FAIL: test_saving_and_retrieving_items
(lists.tests.test_models.ListAndItemModelsTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/workspace/superlists/lists/tests/test_models.py", line 31, in
test_saving_and_retrieving_items
    self.assertEqual(first_saved_item.text, 'The first (ever) list item')
AssertionError: 'Item the second' != 'The first (ever) list item'
- Item the second
[...]
----

That's a bit of a puzzler. A bit of print-based debugging:

[role="skipme"]
[role="sourcecode"]
.lists/tests/test_models.py
[source,python]
----
    first_saved_item = saved_items[0]
    print(first_saved_item.text)
    second_saved_item = saved_items[1]
    print(second_saved_item.text)
    self.assertEqual(first_saved_item.text, 'The first (ever) list item')
----


[role="skipme"]
----
.....Item the second
The first (ever) list item
F.....
----

It looks like our uniqueness constraint has messed with the default ordering
of queries like `Item.objects.all()`.  Although we already have a failing test,
it's best to add a new test that explicitly tests for ordering:


[role="sourcecode"]
.lists/tests/test_models.py (ch09l032)
[source,python]
----
    def test_list_ordering(self):
        list1 = List.objects.create()
        item1 = Item.objects.create(list=list1, text='i1')
        item2 = Item.objects.create(list=list1, text='item 2')
        item3 = Item.objects.create(list=list1, text='3')
        self.assertEqual(
            Item.objects.all(),
            [item1, item2, item3]
        )
----

That gives us a new failure, but it's not a very readable one:

----
AssertionError: [<Item: Item object>, <Item: Item object>, <Item: Item object>]
!= [<Item: Item object>, <Item: Item object>, <Item: Item object>]
----

We need a better string representation for our objects.  Let's add another
unit tests:

NOTE: Ordinarily you would be wary of adding more failing tests when you
already have some -- it makes reading test output that much more complicated,
and just generally makes you nervous. Will we ever get back to a working
state? In this case, they're all quite simple tests, so I'm not too worried.

[role="sourcecode"]
.lists/tests/test_models.py (ch09l033)
[source,python]
----
def test_string_representation(self):
    list1 = List.objects.create() 
    item1 = Item.objects.create(list=list1, text='some text')
    self.assertEqual(str(item1), item1.text)
----

That gives us:

----
AssertionError: 'Item object' != 'some text'
----

As well as the other two failures.  Let's start fixing them all now:


[role="sourcecode"]
.lists/models.py (ch09l034)
[source,python]
----
class Item(models.Model):
    [...]

    def __str__(self):
        return self.text
----

NOTE: in Python 2.x versions of Django, the string representation method used
to be __unicode__. Like much string handling, this is simplified in Python 3.
See the
https://docs.djangoproject.com/en/1.5/topics/python3/#str-and-unicode-methods[docs].


Now we're down to 2 failures, and the ordering test has a more readable failure
message:

----
AssertionError: [<Item: 3>, <Item: i1>, <Item: item 2>] != [<Item: i1>, <Item:
item 2>, <Item: 3>]
----

We can fix that in the class Meta:

[role="sourcecode"]
.lists/models.py (ch09l035)
[source,python]
----
    class Meta:
        ordering = ('id',)
        unique_together = ('list', 'text')
----

Does that work?

----
AssertionError: [<Item: i1>, <Item: item 2>, <Item: 3>] != [<Item: i1>, <Item:
item 2>, <Item: 3>]
----

Urp?  It has worked, you can see the items 'are' in the same order, but the
tests are confused.  I keep running into this problem actually -- Django
querysets don't compare well with lists.  We can fix it by converting the
queryset to a list in our test:


[role="sourcecode"]
.lists/tests/test_models.py (ch09l036)
[source,python]
----
    self.assertEqual(
        list(Item.objects.all()),
        [item1, item2, item3]
    )
----

----
OK
----

That gets us to a fully passing test suite.  Time for a commit:


[subs="specialcharacters,quotes"]
----
$ *git diff*
$ *git commit -am "Implement data validation at model layer"*
----

The next task is to handle the validation error in the view. Before we do that,
a quick aside, for the curious. Do you remember I mentioned earlier that some
data integrity errors 'are' picked up on save?  Try temporarily disabling our
`.full_clean` in the model save:

[role="sourcecode"]
.lists/models.py
[source,python]
----
    def save(self, *args, **kwargs):
        #self.full_clean()
        super().save(*args, **kwargs)
----

That gives

----
ERROR: test_cannot_save_duplicate_items
(lists.tests.test_models.ListAndItemModelsTest)
    return Database.Cursor.execute(self, query, params)
django.db.utils.IntegrityError: columns list_id, text are not unique

[... and a bunch of other failures due to validation not working any more]
----

Note that it's a different error to the one we want, an `IntegrityError` 
instead of a `ValidationError`.  


Handling validation at the views layer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's put our `full_clean` back, and try running our FT, just to see where we are:

[role="dofirst-ch09l035"] 
----
AssertionError: "You can't have an empty list item" != "You've already got this
in your list"
----

Right.  Our site is currently mistaking one sort of validation error for 
another


Returning different error messages for different validation errors
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Time for a new unit test for our view.  We rename the old one too, 
to clarify who's doing what:

[role="sourcecode"]
.lists/tests/test_views.py (ch09l037)
[source,python]
----
    def test_empty_item_validation_errors_end_up_on_lists_page(self):
        [...]

    def test_duplicate_item_validation_errors_end_up_on_lists_page(self):
        list1 = List.objects.create()
        item1 = Item.objects.create(list=list1, text='textey')
        response = self.client.post(
            '/lists/%d/' % (list1.id,),
            data={'item_text': 'textey'}
        )

        self.assertEqual(Item.objects.all().count(), 1)
        self.assertTemplateUsed(response, 'list.html')
        expected_error =  escape("You've already got this in your list")
        self.assertContains(response, expected_error)
----

Gives

----
AssertionError: False is not true : Couldn't find 'You&#39;ve already got this
in your list' in response
----


Here's one possible solution:

[role="sourcecode"]
.lists/views.py (ch09l038)
[source,python]
----
def view_list(request, list_id):
    [...]

    except ValidationError as e:
        if 'blank' in str(e):
            error = "You can't have an empty list item"
        elif 'already exists' in str(e):
            error = "You've already got this in your list"
----

We can try the FT and... that works!  Time for a commit.

[subs="specialcharacters,quotes"]
----
$ *git diff*
$ *git commit -am"duplicate item validation implemented at views level"*
----


Moving validation logic into a form
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

That 'does' work, but we're really doing too much work in our view. Django
encourages us to use Form classes to do the work of validating user input, and
choosing what error messages to display.

NOTE: in Django, a complex view is a code smell.  Could some of that logic
be pushed out to a form?  Or to some custom methods on the model class? Or
to a non-Django module that represents your business logic?

Forms have several powers in Django:
* they can process user input and validate it for errors
* they can be rendered used in templates to render HTML input elements,
and error messages too
* and, as we'll see later, some of them can even save data to the database
for you

Let's do a little experimenting with forms by using a unit test.  My plan
is to iterate towards a complete solution, and hopefully introduce forms gradually
enough that they'll make sense if you've never seen them before!

First we add a new file to hold our forms tests in:

[role="sourcecode"]
.lists/tests/__init__.py 
[source,python]
----
from .test_forms import *
from .test_models import *
from .test_views import *
----

Then we'll add a forms unit test that just looks at the form HTML:

[role="sourcecode"]
.lists/tests/test_forms.py 
[source,python]
----
from django.test import TestCase

from lists.forms import ItemForm


class ItemFormTest(TestCase):

    def test_form_renders_item_text_input(self):
        form = ItemForm()
        self.fail(form.as_p())
----

`form.as_p()` renders the form as HTML.  This unit test is using a self.fail
for some explanatory coding.  You could just as easily use a `manage.py shell`
session, although you'd need to keep reloading your code for each change.

For now it will just fail with an import error.

Let's make a minimal form.  It inherits from the base Form class, and has 
a single field called `item_text`:

[role="sourcecode"]
.lists/forms.py 
[source,python]
----
from django import forms

class ItemForm(forms.Form):
    item_text = forms.CharField()
----

We now see a failure message which tells us what the auto-generated form 
HTML will look like.

----
    self.fail(form.as_p())
AssertionError: <p><label for="id_item_text">Item text:</label> <input
id="id_item_text" name="item_text" type="text" /></p>
----

It's already pretty close to what we have in 'home.html' and 'list.html'.  One
thing we're missing is the placeholder attribute.  Let's make a unit test
for that:

[role="sourcecode"]
.lists/tests/test_forms.py 
[source,python]
----
def test_form_renders_item_text_input(self):
    form = ItemForm()
    self.assertIn('placeholder="Enter a to-do item"', form.as_p())
----

That gives us a fail which justifies some real coding.  How can we customise
the input for a form field?  Using a "widget":


[role="sourcecode"]
.lists/forms.py 
[source,python]
----
class ItemForm(forms.Form):
    item_text = forms.CharField(
        widget=forms.fields.TextInput(attrs={'placeholder': 'Enter a to-do item'})
    )
----

Switching to a Django ModelForm
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

What's next?  We want our form to re-use the validation code that we've already
defined on our model.  Django provides a special class which can auto-generate
a form for a model, called ModelForm.  Let's try that:

[role="sourcecode"]
.lists/forms.py 
[source,python]
----
from django import forms

from lists.models import Item

class ItemForm(forms.models.ModelForm):

    class Meta:
        model = Item
        fields = ('text',)
----

As you can see, `ModelForm` also uses the `class Meta` attribute for
configuration.  Here we specify which model the form is for, and 
which fields we want it to use.

ModelForms do all sorts of smart stuff, like assigning sensible HTML
form input types to different types of field, and applying default 
validation.  Check out the 
https://docs.djangoproject.com/en/1.5/topics/forms/modelforms/[docs] for more
info.

We now have some different-looking form HTML:

----
AssertionError: 'placeholder="Enter a to-do item"' not found in '<p><label
for="id_text">Text:</label> <textarea cols="40" id="id_text" name="text"
rows="10">\r\n</textarea></p>'
----

You can see that it's using `name="text"` instead of `name="item_text"`. We
can probably live with that. But it's using a `textarea` instead of a normal
input, and that's not the UI we want for our app. Thankfully, you can override
widgets for ModelForm fields, similarly to the way we did it with the normal
form:


[role="sourcecode"]
.lists/forms.py 
[source,python]
----
class ItemForm(forms.models.ModelForm):

    class Meta:
        model = Item
        fields = ('text',)
        widgets = {
            'text': forms.fields.TextInput(
                attrs={'placeholder': 'Enter a to-do item'}
            ),
        }
----

That gets the test passing. Now let's see if the ModelForm has picked up the
same validation rules which we defined on the model.  We'll also learn how to
pass data into the form, as if it came from the user:


[role="sourcecode"]
.lists/tests/test_forms.py (ch09l046)
[source,python]
----
    def test_form_validation_for_blank_items(self):
        form = ItemForm(data={'text': ''})
        form.save()
----

Great, that gives us:

----
ValueError: The Item could not be created because the data didn't validate.
----

Good, the form won't allow you to save if you give it an empty item text.

Now let's see if we can get it to use the specific error message that we 
want:

[role="sourcecode"]
.lists/tests/test_forms.py (ch09l047)
[source,python]
----
def test_form_validation_for_blank_items(self):
    form = ItemForm(data={'text': ''})
    self.assertFalse(form.is_valid())
    self.assertEqual(
        form.errors['text'],
        ["You can't have an empty list item"]
    )
----

Calling `form.is_valid()` returns True or False, but it also has the
side-effect of validating the input data, and populating the errors
attribute.  It's a dictionary mapping the names of fields to lists of
errors for those fields (it's possible for a field to have more than 
one error)

That gives us:

----
AssertionError: ['This field is required.'] != ["You can't have an empty list
item"]
----

Django already has a default error message which we could present to the
user -- you might use it if you were in a hurry to build your web app,
but we care enough to make our message special.  Customising it does
involve hacking the form's init though:


[role="sourcecode"]
.lists/forms.py (ch09l048)
[source,python]
----
from django import forms

from lists.models import Item

class ItemForm(forms.models.ModelForm):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        empty_error = "You can't have an empty list item"
        self.fields['text'].error_messages['required'] = empty_error


    class Meta:
        [...]
----

You know what we be even better than messing about with all these
error strings?  Having a constant:  

[role="sourcecode"]
.lists/forms.py (ch09l049)
[source,python]
----
EMPTY_LIST_ERROR = "You can't have an empty list item"

class ItemForm(forms.models.ModelForm):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields['text'].error_messages['required'] = EMPTY_LIST_ERROR

    [...]
----

Re-run the tests to see they pass.... OK.  Now we change the test:

[role="sourcecode"]
.lists/tests/test_forms.py (ch09l050) 
[source,python]
----
from lists.forms import EMPTY_LIST_ERROR, ItemForm
[...]

    def test_form_validation_for_blank_items(self):
        form = ItemForm(data={'text': ''})
        self.assertFalse(form.is_valid())
        self.assertEqual(form.errors['text'], [EMPTY_LIST_ERROR])
----

And the tests still pass. Great.  We are totes commitballs.

[subs="specialcharacters,quotes"]
----
$ *git status* # should show new file at lists/forms.py and its test_forms.py
$ *git add lists*
$ *git commit -m "new form for list items"*
----

Using the form in our home page
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

There's a sort of corollary to the "deploy as early as possible" lean methodoloy,
which is "merge code as early as possible".  What I mean by that is that, in building
this bit of forms code, it would be easy to go on for ages, adding more and
more functionality to the form -- I should know, because that's exactly what I
did during the drafting of this chapter, and I ended up doing all sorts of work
making an all-singing, all-dancing form class before I realised it wouldn't really
work for our most basic use case.

So, instead, try and use your new bit of code as soon as possible.  This makes
sure you never have unused bits of code lying around, and that you start
checking your code against "the real world" as soon as possible.

We have a form class which can render some HTML and do validation of at
least one kind of error -- let's start using it!  We should be able to use
it in our 'home.html' template, and in our new list view.  

Let's start in our unit tests for the home view. Let's replace the old-style
`test_home_page_returns_correct_html` with a set of tests that use the Django Test
Client.  We leave the old test in at first, to check that our new test is equivalent:

[role="sourcecode"]
.lists/tests/test_views.py (ch09l051)
[source,python]
----
from lists.forms import ItemForm
[...]


    def test_home_page_returns_correct_html(self):
        request = HttpRequest()
        [...]


    def test_home_page_renders_home_template_with_form(self):
        response = self.client.get('/')
        self.assertTemplateUsed(response, 'home.html')
        self.assertIsInstance(response.context['form'], ItemForm)
----

That gives us:

----
KeyError: 'form'
----

So we use the form in our home page view:

[role="sourcecode"]
.lists/views.py (ch09l052)
[source,python]
----
[...]
from lists.forms import ItemForm
from lists.models import Item, List

def home_page(request):
    return render(request, 'home.html', {'form': ItemForm()})
----

OK, now let's try using it in the template:


[role="sourcecode"]
.lists/templates/home.html (ch09l053)
[source,html]
----
    <form method="POST" action="{% url 'new_list' %}" >
        {{ form.text }}
        {% csrf_token %}
        {% if error %}
            <p class="error">{{ error }}</p>
        {% endif %}
    </form>
----

`{{form.text}}` renders just the HTML input for `text` field of the form.

Now our old test is out of date:


----
    self.assertEqual(response.content.decode(), expected_html)
AssertionError: '<!DOCTYPE html>\n<html>\n    <head>\n        <meta
[...]
----

Let's just clarify that error message a little:

[role="sourcecode"]
.lists/tests/test_views.py (ch09l054)
[source,python]
----
class HomePageTest(TestCase):
    maxDiff = None #<2>
    [...]
    def test_home_page_returns_correct_html(self):
        request = HttpRequest()
        response = home_page(request)
        expected_html = render_to_string('home.html')
        self.assertMultiLineEqual(response.content.decode(), expected_html) #<1>
----

<1> `assertMultiLineEqual` is useful for comparing long strings, it gives you a
diff-style output, but it truncates long diffs by default...

<2> so that's why we also need to set `maxDiff = None` on the test class.

Sure enough, it's because our `render_to_string` call doesn't know about the
form :

----
[...]
      <form method="POST" action="/lists/new" >
-         <input id="id_text" name="text" placeholder="Enter a to-do item"
type="text" />
+         
[...]
----

But we can fix that:

[role="sourcecode"]
.lists/tests/test_views.py
[source,python]
----
def test_home_page_returns_correct_html(self):
    request = HttpRequest()
    response = home_page(request)
    expected_html = render_to_string('home.html', {'form': ItemForm()})
    self.assertMultiLineEqual(response.content.decode(), expected_html)
----


And that gets us back to passing.  We've now reassured ourselves enough
that the behaviour has stayed the same, so it's now OK to delete
the old test. The `assertTemplateUsed` and `response.context` checks from
the new test are sufficient for testing a basic view with a GET request.


One thing we have done, though, is changed our form -- it no longer uses
the same `id` and `name` attributes.  You'll see if we run our functional
tests that they fail the first time they try and find the input box.


----
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"id","selector":"id_new_item"}' ; Stacktrace: 
----

TODO: commit first

Let's fix the functional tests.  A quick grep shows us there are several
places where we're using `id_new_item`

[subs="specialcharacters,quotes"]
----
$ @grep id_new_item functional_tests/tests/test*@
----

That's a good call for a refactor.  Let's make a new helper method
in 'base.py':

[role="sourcecode"]
.functional_tests/tests/base.py (ch09l057)
[source,python]
----
class FunctionalTest(LiveServerTestCase):
    [...]
    def get_item_input_box(self):
        return self.browser.find_element_by_id('id_text')
----

And then we use it throughout - I had to make 3 changes in 
'test_simple_list_creation.py', 2 in 'test_layout_and_styling.py' and 6
in 'test_list_item_validation.py', eg:


[role="skipme"]
[source,python]
----
    # She is invited to enter a to-do item straight away
    inputbox = self.get_item_input_box()
----

Or

[role="skipme"]
[source,python]
----
    # an empty list item. She hits Enter on the empty input box
    self.browser.get(self.server_url)
    self.get_item_input_box().send_keys('\n')
----

I won't show you every single one, I'm sure you can manage this for 
yourself!  You can re-do the `grep` to check you've caught them all..

That gets us past the first step, but now we have to bring the rest
of the application code in line with the change.  We need to find any occurrences
of the old id (`id_new_item`) and name (`item_text`) and replace them too, with
`id_text` and `text`, respectively.

[role="dofirst-ch09l058"] 
[subs="specialcharacters,quotes"]
----
$ *grep -r id_new_item lists/*

lists/static/base.css:#id_new_item {
lists/templates/list.html:        <input name="item_text" id="id_new_item"
placeholder="Enter a to-do item" />
----

That's two changes, and similarly for the `name`:

[role="dofirst-ch09l059-1"] 
[subs="specialcharacters,macros"]
----
$ pass:quotes[*grep -Ir item_text lists*]
lists/views.py:        Item.objects.create(text=request.POST['item_text'],
list=list)
lists/views.py:            Item.objects.create(text=request.POST['item_text'],
list=list)
lists/tests/test_forms.py:    def test_form_renders_item_text_input(self):
lists/tests/test_views.py:            data={'item_text': 'A new list item'}
lists/tests/test_views.py:            data={'item_text': 'A new list item'}
lists/tests/test_views.py:        response = self.client.post('/lists/new',
data={'item_text': ''})
[...]
----

Once we're done, we re-run the unit tests to check everything still works:

[role="dofirst-ch09l059-2"] 
[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*] 
Creating test database for alias 'default'...
...................
 ---------------------------------------------------------------------
Ran 19 tests in 0.126s

OK
Destroying test database for alias 'default'...
----

And the functional tests too:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests*] 
[...]
======================================================================
ERROR: test_cannot_add_empty_list_items
 ---------------------------------------------------------------------
(functional_tests.tests.test_list_item_validation.ItemValidationTest)
  File "/workspace/superlists/functional_tests/tests/base.py", line 30, in
get_item_input_box
    return self.browser.find_element_by_id('id_text')
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"id","selector":"id_text"}' ; Stacktrace: 
[...]
----


So close!  Let's look at where this is happening -- we check the line number
from the validation FT, and see it's happening after we've submitted a blank
list item.  We see the error text on the next page, but the form has
disappeared!

Now, looking in 'views.py', we see that we're not passing the form to the
'home.html' template inside the `new_list` view:


[role="skipme"]
[source,python]
----
except ValidationError:
    error_text = "You can't have an empty list item"
    return render(request, 'home.html', {"error": error_text})
----

This is a job our form should be doing!  Before we make any more changes
though, let's do a commit

[subs="specialcharacters,quotes"]
----
$ *git status*
$ *git commit -am"rename all item input ids and names"*
----


Now we adjust the unit tests for the `new_list` view. Instead of manually
checking for a hard-coded error string, we check for the `EMPTY_LIST_ERROR`
from 'forms.py', and we can also check that a form of the right class
was passed to the template:

[role="sourcecode"]
.lists/tests/test_views.py (ch09l066)
[source,python]
----
from lists.forms import ItemForm, EMPTY_LIST_ERROR
[...]

class NewListTest(TestCase):
[...]

    def test_validation_errors_sent_back_to_home_page_template(self):
        response = self.client.post('/lists/new', data={'text': ''})
        self.assertEqual(Item.objects.all().count(), 0)
        self.assertTemplateUsed(response, 'home.html')
        self.assertContains(response, escape(EMPTY_LIST_ERROR))
        self.assertIsInstance(response.context['form'], ItemForm)
----


Sure enough, the form isn't being passed to the template:

----
KeyError: 'form'
----

And here's how we use the form in the view:  


[role="sourcecode"]
.lists/views.py
[source,python]
----
def new_list(request):
    form = ItemForm(data=request.POST) #<1>
    if form.is_valid(): #<2>
        list = List.objects.create()
        Item.objects.create(text=request.POST['text'], list=list)
        return redirect(list)
    else:
        return render(request, 'home.html', {"form": form}) #<3>
----

<1> We pass the `request.POST` data into the form's constructor, 
<2> We use `form.is_valid()` to determine whether this is a good or a
bad submission
<3> In the bad case, we pass the form down to the template, instead of
our hard-coded error string.

Incidentally, did you notice that we've also fixed a small bug?  In the
previous code, we were saving a superfluous List object, even for invalid
inputs.  They would have been left lying around our database.  We should add an
extra assert in our unit tests once this refactor is done.

* [strikethrough line-through]#remove hard-coded URLs from 'views.py'#
* [strikethrough line-through]#remove hard-coded URLs from form in 'home.html'#
* [strikethrough line-through]#remove hard-coded URLs from form in 'list.html'#
* remove duplication of validation logic in views.
* add test that we don't save superfluous lists

At this point the tests will fail, because we're not yet using the form
to display errors in the template:

[role="sourcecode"]
.lists/templates/home.html (ch09l068)
[source,html]
----
    <form method="POST" action="{% url 'new_list' %}" >
        {{ form.text }}
        {% csrf_token %}
        {% if form.errors %} #<1>
            <div class="error">{{ form.text.errors }}</div> #<2>
        {% endif %}
    </form>
----

<1> `form.errors` contains a list of all the errors for the form
<2> `form.text.errors` is a list of just the errors for the `text` field.

//TODO div vs p, either mention it or change the earlier one.

That gets the unit tests passing.  How about the FTs?


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests*]
Creating test database for alias 'default'...
....
 ---------------------------------------------------------------------
Ran 4 tests in 16.154s

OK
Destroying test database for alias 'default'...
----

Woohoo!  Can you feel that feeling of relief wash over you?  We've just made
a fairly major change to our small app -- that input field, its name and ID,
is absolutely critical to making everything work.  We've touched 7 or 8
different files, doing a refactor that's quite involved... This is the kind of
thing that, without tests, would seriously worry me.  In fact, I might well
have decided that it wasn't worth messing with code that works...  But, because
we have a full tests suite, we can delve around in it, tidying things up, safe
in the knowledge that the tests are there to spot any mistakes we make.  It
just makes it that much likelier that you're going to keep refactoring, keep
tidying up, keep gardening, keep everything neat and tidy and clean and smooth
and concise and functional.

Definitely time for a commit.

[subs="specialcharacters,quotes"]
----
$ *git diff* 
$ *git commit -am"use form in home page, rename item_text and id_new_item attrs"*
----


Before we forget, let's add our check that invalid new list forms don't create
a pointless list object:

[role="sourcecode"]
.lists/tests/test_views.py (ch09l069)
[source,python]
----
    def test_validation_errors_sent_back_to_home_page_template(self):
        response = self.client.post('/lists/new', data={'text': ''})
        self.assertEqual(List.objects.all().count(), 0)
        self.assertEqual(Item.objects.all().count(), 0)
        self.assertTemplateUsed(response, 'home.html')
        expected_error =  escape("You can't have an empty list item")
        self.assertContains(response, expected_error)
----

That should pass. Time for another self-contained little commit, before we
move onto the next task.

[subs="specialcharacters,quotes"]
----
$ *git commit -am"extra test for not saving List on invalid input"*
----

* [strikethrough line-through]#remove hard-coded URLs from 'views.py'#
* [strikethrough line-through]#remove hard-coded URLs from form in 'home.html'#
* [strikethrough line-through]#remove hard-coded URLs from form in 'list.html'#
* remove duplication of validation logic in views.
* [strikethrough line-through]#add test that we don't save superfluous lists#


A more complex form to handle uniqueness validation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The form to create a new list only needs to know one thing, the new item text.
A form which validates that list items are unique needs to know both.  Let's
see if we can use a subclass: 


[role="sourcecode"]
[source,python]
.lists/tests/test_forms.py (ch09l070)
----
from lists.forms import (
    DUPLICATE_ITEM_ERROR, EMPTY_LIST_ERROR,
    ExistingListItemForm, ItemForm
)
from lists.models import Item, List
[...]

class ExistingListItemFormTest(TestCase):

    def test_form_renders_item_text_input(self):
        form = ExistingListItemForm()
        self.assertIn('placeholder="Enter a to-do item"', form.as_p())


    def test_form_validation_for_blank_items(self):
        listey = List.objects.create()
        form = ExistingListItemForm(data={'list': listey.id, 'text': ''})
        self.assertFalse(form.is_valid())
        self.assertEqual(form.errors['text'], [EMPTY_LIST_ERROR])


    def test_form_validation_for_duplicate_items(self):
        listey = List.objects.create()
        Item.objects.create(list=listey, text='no twins!')
        form = ExistingListItemForm(data={'list': listey.id, 'text': 'no twins!'})
        self.assertFalse(form.is_valid())
        self.assertEqual(form.errors['text'], [DUPLICATE_ITEM_ERROR])
----

Let's start with a minimal class:

[role="sourcecode"]
.lists/forms.py (ch09l071)
[source,python]
----
DUPLICATE_ITEM_ERROR = "You've already got this in your list"
[...]
class ExistingListItemForm(forms.Form):
    pass
----

Gives

----
AssertionError: 'placeholder="Enter a to-do item"' not found in ''
AssertionError: True is not false
AssertionError: True is not false
----


Now let's see if making it inherit from our existing form helps:

[role="sourcecode"]
.lists/forms.py (ch09l072)
[source,python]
----
class ExistingListItemForm(ItemForm):
    pass
----

That takes us down to just one failure:

----
FAIL: test_form_validation_for_duplicate_items
(lists.tests.test_forms.ExistingListItemFormTest)
    self.assertFalse(form.is_valid())
AssertionError: True is not false
----

Now we need to override the fields list from our parent form class.  We 
can do this by inheriting the class `Meta` (you know, I didn't know this
would work before I set off writing this chapter.  It's pretty cool):

[role="sourcecode"]
.lists/forms.py
[source,python]
----
class ExistingListItemForm(ItemForm):

    class Meta(ItemForm.Meta):
        fields = ('list', 'text')
----

We now get a little further:

----
KeyError: 'text'
----

Hm, a little debugging required.  Let's try this in our test:

[role="sourcecode"]
.lists/tests/test_forms.py (ch09l074)
[source,python]
----
    self.assertFalse(form.is_valid())
    self.fail(dict(form.errors))
    self.assertEqual(form.errors['text'], [DUPLICATE_ITEM_ERROR])
----

----
AssertionError: {'__all__': ['Item with this List and Text already exists.']}
----

Right,  Django puts uniqueness validation errors into a special `__all__` key,
because it's not clear which field it should apply to -- list or item.  We
want it to be in the `text` field though.


*******************************************************************************
Does this feel a bit like development-driven-tests?  That's OK, now 
and again.  When you're exploring a new API, you're absolutely allowed
to mess about with it for a while before you get back to rigorous TDD.  We're
using the unit test framework as a way of experimenting, but you could just
as well use an interactive console, or print statements, or whatever you
prefer.
*******************************************************************************


One more little customisation should do it:  Django uses a method called
`validate_unique` for this check, which we can customise:

[role="sourcecode"]
.lists/forms.py
[source,python]
----
class ExistingListItemForm(ItemForm):
    [...]


    def validate_unique(self):
        super().validate_unique()
        if self.non_field_errors(): #<1>
            self._update_errors({'text': [DUPLICATE_ITEM_ERROR]}) #<2>
----

We use a couple of special Django methods here:

<1> `self.non_field_errors()`, which is just the same as
+self.errors['__all__']+, but more readable, and
<2> `self._update_errors`, a Django helper method which takes care of the fact
that dictionary keys may not exist, and fields may already have errors in their
list which we want to append to (see the Django source if you're curious).

Our little debug `self.fail` tells us things are working:

----
AssertionError: {'text': ["You've already got this in your list"], '__all__':
['Item with this List and Text already exists.']}
----

Just to stay neat and tidy, let's say we want to remove that `__all__`
non-field error.  Adjust the unit test, removing the `self.fail` while we're at
it:

[role="sourcecode"]
.lists/tests/test_forms.py (ch09l076)
[source,python]
----
    self.assertFalse(form.is_valid())
    self.assertEqual(form.errors['text'], [DUPLICATE_ITEM_ERROR])
    self.assertFalse(form.non_field_errors())
----

Almost there:

----
AssertionError: ['Item with this List and Text already exists.'] is not false
----

Final step:

[role="sourcecode"]
.lists/forms.py
[source,python]
----
    def validate_unique(self):
        super().validate_unique()
        if self.non_field_errors():
            self._update_errors({'text': [DUPLICATE_ITEM_ERROR]})
            del self.errors['__all__']
----

And we're there!  A quick commit

[subs="specialcharacters,quotes"]
----
$ *git diff*
$ *git commit -a*
----


Using the existing lists item form in the list view
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now let's see if we can put this form to work in our view.  We start by
checking we're using it in the unit test:

[role="sourcecode"]
.lists/tests_test_views.py
[source,python]
----
self.assertIsInstance(response.context['form'], ExistingListItemForm)
----

// TODO: also move the template test and the context tests up,
// or to a different test


[role="sourcecode"]
.lists/views.py
[source,python]
----
from lists.forms import ExistingListItemForm, ItemForm
[...]

def view_list(request, list_id):
    list = List.objects.get(id=list_id)

    if request.method == 'POST':
        form = ExistingListItemForm(data={
            'text': request.POST['text'],
            'list': list.id
        })
        if form.is_valid():
            form.save()
            return redirect(list)
    else:
        form = ExistingListItemForm()

    return render(request, 'list.html', {'list': list, "form": form})
----

//TODO: use diff 078 to fix 1 bug in final diff

How about that form.save() eh?  If you'd never met Django ModelForms, 
there's some of the real power of a ModelForm right there!

We still have failures for the two validation tests:  

----
FAIL: test_duplicate_item_validation_errors_end_up_on_lists_page
(lists.tests.test_views.ListViewTest)
AssertionError: False is not true : Couldn't find 'You&#39;ve already got this
in your list' in response
[...]
FAIL: test_empty_item_validation_errors_end_up_on_lists_page
(lists.tests.test_views.ListViewTest)
AssertionError: False is not true : Couldn't find 'You can&#39;t have an empty
list item' in response
----

We adjust the template:

[role="sourcecode"]
.lists/templates/list.html
[source,html]
----
<form method="POST" action="{% url 'view_list' list.id %}" >
    {{ form.text }}
    {% csrf_token %}
    {% if form.errors %}
        <div class="error">{{ form.text.errors }}</div>
    {% endif %}
</form>
----


And we're there!  Unit tests pass!

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
[...]
Ran 22 tests in 0.082s

OK
----

And so does our FT for validation:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.ItemValidationTest*]
Creating test database for alias 'default'...
..
 ---------------------------------------------------------------------
Ran 2 tests in 12.048s

OK
Destroying test database for alias 'default'...
----

As a final check, we re-run 'all' the FTs:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests*]
Creating test database for alias 'default'...
....
 ---------------------------------------------------------------------
Ran 4 tests in 19.048s

OK
Destroying test database for alias 'default'...
----

Hooray! Time for a final commit, and a wrap-up.


.Tips for testing views and forms
*******************************************************************************
* Split tests out into their own folder called 'tests', adding a '__init__.py'
which imports all test classes
* Split unit tests up into at least 3 files, 'test_models.py', 'test_views.py',
'test_forms.py'
* Have at least a placeholder test for each model class and each form class
* When testing views, I would recommend:
    * Using the Django Test Client
    * Check the template used
    * Check each item in the template context
        * eg check any forms are of the correct class
        * and check any objets or querystes have the correct items.
    * Test any template logic:  any for or if should get a smoke test
    * Sanity-check that your form is rendered, and its errors are displayed

Why these points?  Skip ahead to Appendix II (under construction), and I'll 
show how they are sufficient to ensure that our views are still correct if
we refactor them to start using Class-Based Views.

*******************************************************************************


TODO: prettier bootstrap formatting

TODO: deploy!  use south..

TODO: a general philosophical discussion on design in TDD, "don't forget the
refactor step"

