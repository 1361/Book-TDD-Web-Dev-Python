Prettification: layout and styling, and what to test about it
-------------------------------------------------------------

We're starting to think about releasing the first version of our site, but
we're a bit embarrassed by how ugly it looks at the moment.  In this 
chapter, we'll cover some of the basics of styling, including integrating an
HTML/CSS framework called Bootstrap.  We'll learn how static files work
in Django, and what we need to do about testing them.



What to functionally test about layout and style
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Our site is undeniably a bit ugly at the moment.  

.Our homepage, looking a little ugly..
image::images/ugly_homepage_screenshot.png[Our homepage, looking a little ugly]


NOTE: If you spin up your dev server with `manage.py runserver`, you 
may run into a database error "table lists_item has no column named list_id".
It's because, in the last chapter, we added a column to an existing table: the
foreign key field on the item model pointing at the list model. Syncdb doesn't
know how to modify existing tables. For now, just delete your database
file ('database.sqlite') and re-run `syncdb`, and everything should work
again.  We'll come back to this issue in chapter 12.


We can't be adding to Python's reputation for being
http://grokcode.com/746/dear-python-why-are-you-so-ugly/[ugly],
so let's do a tiny bit of polishing.  Here's a few things we might want:

* A nice large input field for adding new and existing lists
* A large, attention-grabbing, centered box to put it in

How do we apply TDD to these things?  Most people will tell you you
shouldn't test aesthetics, and they're right.  It's a bit like testing a
constant, in that tests usually wouldn't add any value.  

But we can test the implementation of our aesthetics -- just enough to
reassure ourselves that things are working.  For example, we're going to use
Cascading Style Sheets (CSS) for our styling, and they are loaded as static
files.  Static files can be a bit tricky to configure (especially, as we'll see
later, when you move off your own PC and onto a hosting site), so we'll want
some kind of simple "smoke test" that the CSS has loaded.  We don't have to
test fonts and colours and every single pixel, but we can do a quick check that
the main input box is aligned the way we want it to on each page, and that will
give us confidence that the rest of the styling for that page is probably
loaded too.

We start with a new test method inside our functional test:

[role="sourcecode"]
.functional_tests/tests.py (ch07l001)
[source,python]
----
class NewVisitorTest(LiveServerTestCase):
    [...]


    def test_layout_and_styling(self):
        # Edith goes to the home page
        self.browser.get(self.live_server_url)
        self.browser.set_window_size(1024, 768)

        # She notices the input box is nicely centered
        inputbox = self.browser.find_element_by_tag_name('input')
        self.assertAlmostEqual(
            inputbox.location['x'] + inputbox.size['width'] / 2,
            512,
            delta=3
        )
----

//TODO: find a better way of smoke-testing the CSS. This is too brittle.

A few new things here.  We start by setting the window size to a fixed
size. We then find the input element, look at its size and location, and
do a little maths to check whether it seems to be positioned in the middle
of the page.  `assertAlmostEqual` helps us to deal with rounding errors by
letting us specify that we want our arithmetic to work to within 3 pixels.

Now, if we run the functional tests, we get:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests*]
Creating test database for alias 'default'...
.F
======================================================================
FAIL: test_layout_and_styling (functional_tests.tests.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/workspace/superlists/functional_tests/tests.py", line 103, in
test_layout_and_styling
    delta=3
AssertionError: 125.0 != 512 within 3 delta

 ---------------------------------------------------------------------
Ran 2 tests in 9.188s

FAILED (failures=1)
Destroying test database for alias 'default'...
----

That's the expected failure.  Still, this kind of FT is easy to get wrong, so
let's use a quick-and-dirty "cheat" solution, to check that the FT also passes
when the input box is centered.  We'll delete this code again almost as soon
as we've used it to check the FT:

[role="sourcecode"]
.lists/templates/home.html (ch07l002)
[source,html]
----
<form method="POST" action="/lists/new">
    <p style="text-align: center;">
        <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
    </p>
    {% csrf_token %}
</form>
----

That passes, which means the FT works.  Let's extend it to make sure that the
input box is also aligned-center on the page for a new list:

[role="sourcecode"]
.functional_tests/tests.py (ch07l003)
[source,python]
----
    # She starts a new list and sees the input is nicely
    # centered there too
    inputbox.send_keys('testing\n')
    inputbox = self.browser.find_element_by_tag_name('input')
    self.assertAlmostEqual(
        inputbox.location['x'] + inputbox.size['width'] / 2,
        512,
        delta=3
    )
----

That gives us another test failure:

----
  File "/workspace/superlists/functional_tests/tests.py", line 113, in
test_layout_and_styling
    delta=3
AssertionError: 125.0 != 512 within 3 delta
----

Let's commit just the FT:

[subs="specialcharacters,quotes"]
----
$ *git add functional_tests/tests.py*
$ *git commit -m "first steps of FT for layout + styling"*
----

Now it feels like we're justified in finding a "proper" solution to our need
for some better styling for our site.  We can back out our hacky 
`<p style="text-align: center">`.

[subs="specialcharacters,quotes"]
----
$ *git reset --hard*
----

WARNING: `git reset --hard` is the "take off and nuke the site from orbit" Git
command, so be careful with it -- it blows away all your un-committed changes.
Unlike almost everything else you can do with Git, there's no way of going back
after this one.


Prettification: Using a CSS framework
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Design is hard ([strikethrough line-through]#let's go shopping#), and doubly so
now that we have to deal with mobile, tablets and so forth.  That's why many
programmers, particularly lazy ones like me, are turning to CSS frameworks to
solve some of those problems for them.  There are lots of frameworks out there,
but one of the earliest and most popular is Twitter's Bootstrap.  Let's use
that.

You can find bootstrap at http://twitter.github.io/bootstrap/ 

We'll download it and put it in a new folder called *static* inside the `lists`
app:
footnote:[on Windows, you may not have `wget` and `unzip`, but I'm sure you can
figure out how to download bootstrap, unzip it, and put the contents of the
'dist' folder into the 'lists/static/bootstrap' folder.]

[subs="specialcharacters,quotes"]
----
$ *wget -O bootstrap.zip https://github.com/twbs/bootstrap/archive/v3.0.0.zip*
$ *unzip bootstrap.zip*
$ *mkdir lists/static*
$ *mv bootstrap-3.0.0/dist/ lists/static/bootstrap*
$ @rm -rf bootstrap*@
----

Bootstrap comes with a plain, uncustomised installation in the 'dist' folder.
We're going to use that for now, but you should really never do this for a
real site -- vanilla bootstrap is instantly recognisable, and a big signal
to anyone in the know that you couldn't be bothered to style your site. Learn
how to use LESS and change the font, if nothing else!  More info in bootstrap's
README

NOTE: Who votes I should put an ultra-brief guide to customising bootstrap
in here?  Install node+npm, grunt, tweak, eg, the basic font inside the LESS,
compile, and we're away?  Email me via obeythetestinggoat@gmail.com, or on
the https://groups.google.com/forum/#!forum/obey-the-testing-goat-book[Mailing
list]

Our lists folder will end up looking like this:

[role="skipme"]
----
lists
├── __init__.py
├── models.py
├── static
│   └── bootstrap
│       ├── css
│       │   ├── bootstrap.css
│       │   ├── bootstrap.min.css
│       │   ├── bootstrap-theme.css
│       │   └── bootstrap-theme.min.css
│       ├── fonts
│       │   ├── glyphicons-halflings-regular.eot
│       │   ├── glyphicons-halflings-regular.svg
│       │   ├── glyphicons-halflings-regular.ttf
│       │   └── glyphicons-halflings-regular.woff
│       └── js
│           ├── bootstrap.js
│           └── bootstrap.min.js
├── templates
│   ├── home.html
│   └── list.html
├── tests.py
├── urls.py
└── views.py
----
//ch07l004

If we have a look at the "Getting Started" section of the 
http://twitter.github.io/bootstrap/getting-started.html#html-template[Bootstrap 
Documentation], you'll see it wants our HTML template to include something
like this:


[role="skipme"]
[source,html]
----
    <!DOCTYPE html>
    <html>
      <head>
        <title>Bootstrap 101 Template</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <!-- Bootstrap -->
        <link href="css/bootstrap.min.css" rel="stylesheet" media="screen">
      </head>
      <body>
        <h1>Hello, world!</h1>
        <script src="http://code.jquery.com/jquery.js"></script>
        <script src="js/bootstrap.min.js"></script>
      </body>
    </html>
----

We already have two HTML templates.  We don't want to be adding a whole load
of boilerplate code to each, so now feels like the right time to apply
the "Don't repeat yourself" rule, and bring all the common parts together.
Thankfully, the Django template language makes that easy using something
called template inheritance.

Django template inheritance
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's have a little review of what the differences are between 'home.html' and
'list.html':

[subs="specialcharacters,macros"]
----
$ pass:quotes[*diff lists/templates/home.html lists/templates/list.html*]
7,8c7,8
<         <h1>Start a new To-Do list</h1>
<         <form method="POST" action="/lists/new">
---
>         <h1>Your To-Do list</h1>
>         <form method="POST" action="/lists/{{ list.id }}/new_item">
11a12,18
> 
>         <table id="id_list_table">
>             {% for item in list.item_set.all %}
>                 <tr><td>{{ forloop.counter }}: {{ item.text }}</td></tr>
>             {% endfor %}
>         </table>
> 
----

They have different header texts, and their forms use different URLs. On top
of that, 'list.html' has the additional `<table>` element.

Now that we're clear on what's in common and what's not, we can make the two 
templates inherit from a common "superclass" template.  We'll start by 
making a copy of 'home.html':

[subs="specialcharacters,quotes"]
----
$ *cp lists/templates/home.html lists/templates/base.html*
----

We make this into a base template which just contains the common boilerplate,
and mark out the "blocks", places where child templates can customise it.

[role="sourcecode"]
.lists/templates/base.html
[source,html]
----
<html>
    <head>
        <title>To-Do lists</title>
    </head>
    <body>
        <h1>{% block header_text %}{% endblock %}</h1>
        <form method="POST" action="{% block form_action %}{% endblock %}">
            <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
            {% csrf_token %}
        </form>
        {% block table %}
        {% endblock %}
    </body>
</html>
----

The base template defines a series of areas called "blocks", which will be 
places that other templates can hook in and add their own content.  Let's
see how that works in practice, by changing 'home.html' so that it "inherits
from" 'base.html':

[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
{% extends 'base.html' %}

{% block header_text %}Start a new To-Do list{% endblock %}

{% block form_action %}/lists/new{% endblock %}
----

You can see that lots of the boilerplate html disappears, and we just
concentrate on the bits we want to customise. We do the same for 'list.html':

[role="sourcecode"]
.lists/templates/list.html
[source,html]
----
{% extends 'base.html' %}

{% block header_text %}Your To-Do list{% endblock %}

{% block form_action %}/lists/{{ list.id }}/new_item{% endblock %}

{% block table %}
    <table id="id_list_table">
        {% for item in list.item_set.all %}
            <tr><td>{{ forloop.counter }}: {{ item.text }}</td></tr>
        {% endfor %}
    </table>
{% endblock %}
----


That's a refactor of the way our templates work.  We re-run the FTs to make
sure we haven't broken anything...

----
AssertionError: 125.0 != 512 within 3 delta
----

Sure enough, they're still getting to exactly where they were before.  That's 
worthy of a commmit;

[subs="specialcharacters,quotes"]
----
$ *git diff -b*
# the -b means ignore whitespace, useful since we've changed some html indenting
$ *git status*
$ *git add lists/templates* # leave static, for now
$ *git commit -m"refactor templates to use a base template"*
----



Integrating Bootstrap
~~~~~~~~~~~~~~~~~~~~~

Now it's much easier to integrate the boilerplate code that bootstrap wants -
we won't add the JavaScript yet, just the CSS:

[role="sourcecode"]
.lists/templates/base.html
[source,html]
----
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>To-Do lists</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="css/bootstrap.min.css" rel="stylesheet" media="screen">
    </head>
----
// ch07l006 

Finally, let's actually use some of the bootstrap magic! You'll have to read
the bootstrap documentation yourself, but we can use a combination of the
grid system and the `text-center` class to get what we want:

[role="sourcecode"]
.lists/templates/base.html (ch07l007)
[source,html]
----
<body>
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-md-offset-3">
                <div class="text-center">
                    <h1>{% block header_text %}{% endblock %}</h1>
                    <form method="POST" action="{% block form_action %}{% endblock %}">
                        <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
                        {% csrf_token %}
                    </form>

                    </div>
                    {% block table %}
                    {% endblock %}
                </div>
            </div>
        </div>
    </body>
----
// ch07l007

TIP: Take the time to browse through the http://getbootstrap.com/[Bootstrap
documentation], if you've never seen it before.  It's a shopping trolley 
brimming full of useful tools to use in your site.

Does that work?

----
AssertionError: 125.0 != 512 within 3 delta
----

Hm. no.


Static files in Django
~~~~~~~~~~~~~~~~~~~~~~

Django, and indeed any web server, needs to know two things to deal with static
files:

1. How to tell when a URL request is for a static file, as opposed to for some
HTML that's going to be served via a view function
2. Where to find the static file the user wants.

In other words, static files are a mapping from URLs to files on disk. 

For item 1, Django lets us define a URL "prefix" to say that any URLs which
start with that prefix should be treated as requests for static files.  By
default, the prefix is `/static/`. It's defined in 'settings.py':


[role="sourcecode currentcontents"]
.superlists/settings.py
[source,python]
----
[...]

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/1.6/howto/static-files/

STATIC_URL = '/static/'
----

The rest of the settings we will add to this section are all to do with item 2:
finding the actual static files on disk. While we're using the Django
development server (`manage.py runserver`), we can rely it to magically find
static files for us -- it'll just look in any subfolder of one of our apps
called 'static'.

Later, when we switch to running on a "proper" web server, we'll use a command
called `collectstatic` to copy all our static files to a single location, where
the web server will serve files from.

You now see why we put all the bootstrap static files into
'lists/static'.  So why are they not working at the moment?  It's because we're
not using the `/static/` URL prefix.  Have another look at the link to the CSS
in 'base.html':

[role="sourcecode skipme"]
.lists/templates/base.html
[source,html]
----
<link href="css/bootstrap.min.css" rel="stylesheet" media="screen">
----

To get this to work, we need to change it to

[role="sourcecode"]
.lists/templates/base.html
[source,html]
----
<link href="/static/bootstrap/css/bootstrap.min.css" rel="stylesheet" media="screen">
----

// use {% static %} here?

When Django sees the request, it knows that it's for a static file because
it begins with `/static/`.  It then tries to find a file called
`bootstrap/css/bootstrap.min.css`, looking in each of our app folders for
subfolders called static, and then it should find it at
'lists/static/bootstrap/css/bootstrap.min.css'

Hopefully it will now find the new CSS, which should get our test to pass:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests*]
Creating test database for alias 'default'...
..
 ---------------------------------------------------------------------
Ran 2 tests in 9.764s
----

Hooray! And, as the tests zipped past, you may have noticed our site was
starting to look a little better laid-out:

.Our homepage, looking a little better...
image::images/slightly_better_screenshot.png[The list page with centered header]

Let's see if we can do even better.  Bootstrap has a class called 'jumbotron'
for things that are meant to be particularly prominent on the page.  Let's use
that:

[role="sourcecode"]
.lists/templates/base.html
----
    <div class="col-md-6 col-md-offset-3 jumbotron">
----

When hacking about with design and layout, it's best to have a window open that
we can hit refresh on, frequently.  Use `python3 manage.py runserver` to spin
up the dev server, and then browse to 'http://localhost:8000' to see your work
as we go.

The hero unit is a good start, but now the input box has tiny text compared to
everything else.  Thankfully, Bootstrap's form control classes offer an option
to set an input to be "large":


[role="sourcecode"]
.lists/templates/base.html (ch07l010)
[source,html]
----
<input name="item_text" id="id_new_item" class="form-control input-lg" placeholder="Enter a to-do item" />
----

Finally I'd like to just offset the input from the title text slightly. There's
no ready-made fix for that in bootstrap, so we'll make one ourselves.  That
will require specifying our own CSS file:


[role="sourcecode"]
.lists/templates/base.html
[source,html]
----
<head>
    <title>To-Do lists</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="/static/bootstrap/css/bootstrap.min.css" rel="stylesheet" media="screen">
    <link href="/static/base.css" rel="stylesheet" media="screen">
</head>
----

And we create a new file at 'lists/static/base.css', with our new CSS rule.
We'll use the `id` of the input element, `id_new_item` to find it and give it
some styling:


[role="sourcecode"]
.lists/static/base.css
[source,html]
----
#id_new_item {
    margin-top: 2ex;
}
----

All that took me a few goes, but I'm reasonably happy with this:

image::images/screenshot_good_enough.png[Our list page with all big chunks]

If you want to go further with customising Bootstrap, you need to get into
compiling LESS CSS. I 'definitely' recommend taking the time to do that some
day. LESS and other pseudo-CSS-alikes like SCSS are a great improvement on
plain old CSS, and a useful tool even if you don't use Bootstrap. I won't cover
it in this book though.


A last run of the functional tests, to see if everything still works OK?

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests*]
Creating test database for alias 'default'...
..
 ---------------------------------------------------------------------
Ran 2 tests in 10.084s

OK
Destroying test database for alias 'default'...
----


That's it! Definitely time for a commit:


[subs="specialcharacters,quotes"]
----
$ *git status* # shows changes to base.html, and new folder at lists/static
$ *git add lists*
$ *git status* # will now show all the bootstrap additions
$ *git commit -m"Use Bootstrap to improve layout"*
----


What we skipped over: collectstatic and other static directories
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If we have another look at 'settings.py', we can talk about some of the options
we didn't mention earlier. We'll need `STATIC_ROOT` in the next chapter, so
let's actually experiment with that now.  Let's change its value to a folder
just outside our repo -- I'm going to make it a folder just next to the main
source folder:

----
projects
│    ├── superlists
│    │    ├── lists
│    │    │     ├── models.py
│    │    │
│    │    ├── manage.py
│    │    ├── superlists
│    │    
│    ├── static
│    │    ├── base.css 
│    │    ├── etc...
----

The logic is the static files folder shouldn't be a part of your repository -
we don't want to put it under source control, because it's a duplicate of all
the files that are inside 'lists/static'.

Here's a neat way of specifying that folder, making it relative to the location
of the 'settings.py' file

[role="sourcecode"]
.superlists/settings.py (ch07l018)
[source,python]
----
# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/1.6/howto/static-files/

STATIC_URL = '/static/'
STATIC_ROOT = os.path.abspath(os.path.join(BASE_DIR, '../static'))
----

Now let's try running `collectstatic`:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py collectstatic*]

You have requested to collect static files at the destination
location as specified in your settings.

This will overwrite existing files!
Are you sure you want to do this?

Type 'yes' to continue, or 'no' to cancel: 
pass:quotes[*yes*]
[...]

Copying '/workspace/superlists/lists/static/bootstrap/fonts/glyphicons-halfling
s-regular.eot'

80 static files copied.
----

And if we look in '../static', we'll find all our CSS files:

[subs="specialcharacters,quotes"]
----
$ *tree ../static/*
../static/
├── admin
│   ├── css
│   │   ├── base.css

[...]

│       └── urlify.js
├── base.css
└── bootstrap
    ├── css
    │   ├── bootstrap.css
    │   ├── bootstrap.min.css
    │   ├── bootstrap-theme.css
    │   └── bootstrap-theme.min.css
    ├── fonts
    │   ├── glyphicons-halflings-regular.eot
    │   ├── glyphicons-halflings-regular.svg
    │   ├── glyphicons-halflings-regular.ttf
    │   └── glyphicons-halflings-regular.woff
    └── js
        ├── bootstrap.js
        └── bootstrap.min.js

10 directories, 80 files
----

`collectstatic` has also picked up all the css for the admin site.  We're
not ready to use that yet, so let's disable it for now:

[role="sourcecode"]
.superlists/settings.py 
[source,python]
----
INSTALLED_APPS = (
    #'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'lists',
)
----

And we try again:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*rm -rf ../static/*]
$ pass:quotes[*python3 manage.py collectstatic --noinput*]
Copying '/workspace/superlists/lists/static/base.css'
Copying '/workspace/superlists/lists/static/bootstrap/js/bootstrap.min.js'
Copying '/workspace/superlists/lists/static/bootstrap/js/bootstrap.js'
[...]

11 static files copied.
----

Much better.

NOTE: are you wondering why we didn't use the functional test to test this?
Unfortunately, one of the limitations of `LiveServerTestCase` is that it 
ignores the `STATIC_ROOT` setting, and serves static files from their app
folder locations anyway.  Similarly, the Django dev server (`manage.py runserver`)
will serve static files from app folders when `DEBUG = True`, and not at 
all when `DEBUG = False`.  Testing the static files setup on the production
web server will be part of the next chapter.

Anyway, now we know how to collect all the static files into a single folder,
where it's easy for a web server to find them. We'll find out all about that in
the next chapter!

For now let's save our changes to 'settings.py':

[subs="specialcharacters,quotes"]
----
$ *git diff* # should show changes in settings.py*
$ *git commit -am"set STATIC_ROOT in settings and disable admin"*
----

.On testing design and layout
*******************************************************************************

The short answer is: you shouldn't write tests for design and layout.  It's too
much like testing a constant, and any tests you write are likely to be brittle.

With that said, the 'implementation' of design and layout involves something 
quite tricky: CSS, and static files.   As a result, it is valuable to have some
kind of minimal "smoke test" which checks that your static files and CSS are
working.  As we'll see in the next chapter, it can help pick up problems when
you deploy your code to production.

Similarly, if a particular piece of styling required a lot of client-side 
JavaScript code to get it to work (dynamic resizing is one I've spent a bit
of time on), you'll definitely want some tests for that.

So be aware that this is a dangerous area.  Try and write the minimal tests 
that will give you confidence that your design and layout is working, without
testing *what* it actually is.  Try and leave yourself in a position where you
can freely make changes to the design and layout, without having to go back and
adjust tests all the time.

*******************************************************************************
