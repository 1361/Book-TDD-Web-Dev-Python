More advanced Forms and database migrations
-------------------------------------------

Now let's look at some slightly more advanced validation:


Another FT for duplicate items
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We can delete the `self.fail` from the previous test and add a second
test method to `ItemValidationTest`:

[role="sourcecode"]
.functional_tests/tests/test_list_item_validation.py (ch09l027)
[source,python]
----
def test_cannot_add_dulicate_items(self):
    # Edith goes to the home page and starts a new list
    self.browser.get(self.server_url)
    self.browser.find_element_by_id('id_new_item').send_keys('Buy wellies\n')
    self.check_for_row_in_list_table('1: Buy wellies')

    # She accidentally tries to enter a duplicate item
    self.browser.find_element_by_id('id_new_item').send_keys('Buy wellies\n')

    # She sees a helpful error message
    self.check_for_row_in_list_table('1: Buy wellies')
    error = self.browser.find_element_by_css_selector('.error')
    self.assertEqual(error.text, "You've already got this in your list")
----

Why have two test methods rather than extending one, or having a new file
and class?  It's a judgement call.  These two feel closely related, they're
both about input validation on the same input field, so it feels right to
keep them in the same file.  On the other hand, they're logically separate
enough that it's practical to keep them in different methods.


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.ItemValidationTest*] 
[...]
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"css selector","selector":".error"}' ; Stacktrace: 

Ran 2 tests in 9.613s
----

OK, so we know the first of the two tests passes now, is there a way to run
just the failing one, I hear you ask!  Why yes indeed -- the technique known
as 'Dontification'.


Dontification
^^^^^^^^^^^^^

[role="sourcecode skipme"]
.lists/functional_tests/test_list_item_validation.py
[source,python]
----
    def DONTtest_cannot_add_empty_list_items(self):
----

We can 'temporarily' rename any of our test methods in such a way that they
don't begin with `test_`, and then the test runner ignores them.

WARNING: Dontification is dangerous -- you need to remember to change it back 
before you commit your changes back to the repo.  This is why line-by-line 
reviews of each of your diffs are a good idea!


Preventing duplicates at the model layer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We add another test to our model unit tests to check that duplicate items
in the same list raise an error

[role="sourcecode"]
.lists/tests/test_models.py (ch09l028)
[source,python]
----
def test_cannot_save_duplicate_items(self):
    list1 = List.objects.create()
    Item.objects.create(list=list1, text='bla')
    with self.assertRaises(ValidationError):
        Item.objects.create(list=list1, text='bla')
----

And, while it occurs to us, we add another test to make sure we don't 
overdo it on our integrity constraints:


[role="sourcecode"]
.lists/tests/test_models.py (ch09l029)
[source,python]
----
def test_CAN_save_same_item_to_different_lists(self):
    list1 = List.objects.create()
    list2 = List.objects.create()
    Item.objects.create(list=list1, text='bla')
    Item.objects.create(list=list2, text='bla') # should not raise
----

I always like to put a little comment for tests which are checking 
that a particular use case should 'not' raise an error, otherwise
it can be hard to see what's being tested.

----
AssertionError: ValidationError not raised
----

If we want to get it deliberately wrong, we can do this:


[role="sourcecode"]
.lists/models.py (ch09l030)
[source,python]
----
class Item(models.Model):
    text = models.TextField(unique=True)
    list = models.ForeignKey(List)
----

That lets us check that our second test really does pick up on this
problem:

----
Traceback (most recent call last):
  File "/workspace/superlists/lists/tests/test_models.py", line 60, in
test_CAN_save_same_item_to_different_lists
    Item.objects.create(list=list2, text='bla') # should not raise
    [...]
django.core.exceptions.ValidationError: {'text': ['Item with this Text already
exists.']}
----

.An aside on when to test for developer stupidity
*******************************************************************************
One of the judgement calls in testing is when you should write tests that sound
like "check we haven't done something stupid".  In general, you should be wary
of these.

In this case, we've written a test to check that you can't save duplicate items
to the same list.  Now, the simplest way to get that test to pass, the way in
which you'd write the least lines of code, would be to make it impossible to
save 'any' duplicate items.  That justifies writing another test, despite the
fact that it would be a "stupid" or "wrong" thing for us to code.

But you can't be writing tests for every possible way we could have coded
something wrong.  If you have a function that adds two numbers, you can write
a couple of tests:

[role="skipme"]
[source,python]
----
assert adder(1, 1) == 2
assert adder(2, 1) == 3
----

But you have the right to assume that the implementation isn't deliberately
screwey or perverse:

[role="skipme"]
[source,python]
----
def adder(a, b):
    # unlikely code!
    if a = 3:
        return 666
    else:
        return a + b
----

One way of putting it is that you should trust yourself not to do something
'deliberately' stupid, but not to do something 'accidentally' stupid.
*******************************************************************************

Great.  The real implementation happens in a special class attribute called
`Meta`, and a constraint which says that that an item must be unique for a
particular list, or in other words, that text and list must be unique together:

[role="sourcecode"]
.lists/models.py (ch09l031)
[source,python]
----
class Item(models.Model):
    text = models.TextField()
    list = models.ForeignKey(List)

    class Meta:
        unique_together = ('list', 'text')


    def save(self, *args, **kwargs):
        [...]
----

You might want to take a quick peek at the 
https://docs.djangoproject.com/en/1.5/ref/models/options/[Django docs on model
meta attributes] at this point.


A little digression on Queryset ordering and string representations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TODO: investigate new Django test helper, "assertQuerySetEqual"?

When we run the tests they reveal an unexpected failure:

----
======================================================================
FAIL: test_saving_and_retrieving_items
(lists.tests.test_models.ListAndItemModelsTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/workspace/superlists/lists/tests/test_models.py", line 31, in
test_saving_and_retrieving_items
    self.assertEqual(first_saved_item.text, 'The first (ever) list item')
AssertionError: 'Item the second' != 'The first (ever) list item'
- Item the second
[...]
----

That's a bit of a puzzler. A bit of print-based debugging:

[role="skipme"]
[role="sourcecode"]
.lists/tests/test_models.py
[source,python]
----
    first_saved_item = saved_items[0]
    print(first_saved_item.text)
    second_saved_item = saved_items[1]
    print(second_saved_item.text)
    self.assertEqual(first_saved_item.text, 'The first (ever) list item')
----


[role="skipme"]
----
.....Item the second
The first (ever) list item
F.....
----

It looks like our uniqueness constraint has messed with the default ordering
of queries like `Item.objects.all()`.  Although we already have a failing test,
it's best to add a new test that explicitly tests for ordering:


[role="sourcecode"]
.lists/tests/test_models.py (ch09l032)
[source,python]
----
    def test_list_ordering(self):
        list1 = List.objects.create()
        item1 = Item.objects.create(list=list1, text='i1')
        item2 = Item.objects.create(list=list1, text='item 2')
        item3 = Item.objects.create(list=list1, text='3')
        self.assertEqual(
            Item.objects.all(),
            [item1, item2, item3]
        )
----

That gives us a new failure, but it's not a very readable one:

----
AssertionError: [<Item: Item object>, <Item: Item object>, <Item: Item object>]
!= [<Item: Item object>, <Item: Item object>, <Item: Item object>]
----

We need a better string representation for our objects.  Let's add another
unit tests:

NOTE: Ordinarily you would be wary of adding more failing tests when you
already have some -- it makes reading test output that much more complicated,
and just generally makes you nervous. Will we ever get back to a working
state? In this case, they're all quite simple tests, so I'm not too worried.

[role="sourcecode"]
.lists/tests/test_models.py (ch09l033)
[source,python]
----
def test_string_representation(self):
    list1 = List.objects.create() 
    item1 = Item.objects.create(list=list1, text='some text')
    self.assertEqual(str(item1), item1.text)
----

That gives us:

----
AssertionError: 'Item object' != 'some text'
----

As well as the other two failures.  Let's start fixing them all now:


[role="sourcecode"]
.lists/models.py (ch09l034)
[source,python]
----
class Item(models.Model):
    [...]

    def __str__(self):
        return self.text
----

NOTE: in Python 2.x versions of Django, the string representation method used
to be __unicode__. Like much string handling, this is simplified in Python 3.
See the
https://docs.djangoproject.com/en/1.5/topics/python3/#str-and-unicode-methods[docs].


Now we're down to 2 failures, and the ordering test has a more readable failure
message:

----
AssertionError: [<Item: 3>, <Item: i1>, <Item: item 2>] != [<Item: i1>, <Item:
item 2>, <Item: 3>]
----

We can fix that in the class Meta:

[role="sourcecode"]
.lists/models.py (ch09l035)
[source,python]
----
    class Meta:
        ordering = ('id',)
        unique_together = ('list', 'text')
----

Does that work?

----
AssertionError: [<Item: i1>, <Item: item 2>, <Item: 3>] != [<Item: i1>, <Item:
item 2>, <Item: 3>]
----

Urp?  It has worked, you can see the items 'are' in the same order, but the
tests are confused.  I keep running into this problem actually -- Django
querysets don't compare well with lists.  We can fix it by converting the
queryset to a list in our test:


[role="sourcecode"]
.lists/tests/test_models.py (ch09l036)
[source,python]
----
    self.assertEqual(
        list(Item.objects.all()),
        [item1, item2, item3]
    )
----

----
OK
----

That gets us to a fully passing test suite.  Time for a commit:


[subs="specialcharacters,quotes"]
----
$ *git diff*
$ *git commit -am "Implement data validation at model layer"*
----

The next task is to handle the validation error in the view. Before we do that,
a quick aside, for the curious. Do you remember I mentioned earlier that some
data integrity errors 'are' picked up on save?  Try temporarily disabling our
`.full_clean` in the model save:

[role="sourcecode"]
.lists/models.py
[source,python]
----
    def save(self, *args, **kwargs):
        #self.full_clean()
        super().save(*args, **kwargs)
----

That gives

----
ERROR: test_cannot_save_duplicate_items
(lists.tests.test_models.ListAndItemModelsTest)
    return Database.Cursor.execute(self, query, params)
django.db.utils.IntegrityError: columns list_id, text are not unique

[... and a bunch of other failures due to validation not working any more]
----

Note that it's a different error to the one we want, an `IntegrityError` 
instead of a `ValidationError`.  


Handling validation at the views layer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's put our `full_clean` back, and try running our FT, just to see where we are:

[role="dofirst-ch09l035"] 
----
AssertionError: "You can't have an empty list item" != "You've already got this
in your list"
----

Right.  Our site is currently mistaking one sort of validation error for 
another


Returning different error messages for different validation errors
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Time for a new unit test for our view.  We rename the old one too, 
to clarify who's doing what:

[role="sourcecode"]
.lists/tests/test_views.py (ch09l037)
[source,python]
----
    def test_empty_item_validation_errors_end_up_on_lists_page(self):
        [...]

    def test_duplicate_item_validation_errors_end_up_on_lists_page(self):
        list1 = List.objects.create()
        item1 = Item.objects.create(list=list1, text='textey')
        response = self.client.post(
            '/lists/%d/' % (list1.id,),
            data={'item_text': 'textey'}
        )

        self.assertEqual(Item.objects.all().count(), 1)
        self.assertTemplateUsed(response, 'list.html')
        expected_error =  escape("You've already got this in your list")
        self.assertContains(response, expected_error)
----

Gives

----
AssertionError: False is not true : Couldn't find 'You&#39;ve already got this
in your list' in response
----


Here's one possible solution:

[role="sourcecode"]
.lists/views.py (ch09l038)
[source,python]
----
def view_list(request, list_id):
    [...]

    except ValidationError as e:
        if 'blank' in str(e):
            error = "You can't have an empty list item"
        elif 'already exists' in str(e):
            error = "You've already got this in your list"
----

We can try the FT and... that works!  Time for a commit.

[subs="specialcharacters,quotes"]
----
$ *git diff*
$ *git commit -am"duplicate item validation implemented at views level"*
----


A more complex form to handle uniqueness validation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The form to create a new list only needs to know one thing, the new item text.
A form which validates that list items are unique needs to know both.  Let's
see if we can use a subclass: 


[role="sourcecode"]
[source,python]
.lists/tests/test_forms.py (ch09l070)
----
from lists.forms import (
    DUPLICATE_ITEM_ERROR, EMPTY_LIST_ERROR,
    ExistingListItemForm, ItemForm
)
from lists.models import Item, List
[...]

class ExistingListItemFormTest(TestCase):

    def test_form_renders_item_text_input(self):
        form = ExistingListItemForm()
        self.assertIn('placeholder="Enter a to-do item"', form.as_p())


    def test_form_validation_for_blank_items(self):
        listey = List.objects.create()
        form = ExistingListItemForm(data={'list': listey.id, 'text': ''})
        self.assertFalse(form.is_valid())
        self.assertEqual(form.errors['text'], [EMPTY_LIST_ERROR])


    def test_form_validation_for_duplicate_items(self):
        listey = List.objects.create()
        Item.objects.create(list=listey, text='no twins!')
        form = ExistingListItemForm(data={'list': listey.id, 'text': 'no twins!'})
        self.assertFalse(form.is_valid())
        self.assertEqual(form.errors['text'], [DUPLICATE_ITEM_ERROR])
----

Let's start with a minimal class:

[role="sourcecode"]
.lists/forms.py (ch09l071)
[source,python]
----
DUPLICATE_ITEM_ERROR = "You've already got this in your list"
[...]
class ExistingListItemForm(forms.Form):
    pass
----

Gives

----
AssertionError: 'placeholder="Enter a to-do item"' not found in ''
AssertionError: True is not false
AssertionError: True is not false
----


Now let's see if making it inherit from our existing form helps:

[role="sourcecode"]
.lists/forms.py (ch09l072)
[source,python]
----
class ExistingListItemForm(ItemForm):
    pass
----

That takes us down to just one failure:

----
FAIL: test_form_validation_for_duplicate_items
(lists.tests.test_forms.ExistingListItemFormTest)
    self.assertFalse(form.is_valid())
AssertionError: True is not false
----

Now we need to override the fields list from our parent form class.  We 
can do this by inheriting the class `Meta` (you know, I didn't know this
would work before I set off writing this chapter.  It's pretty cool):

[role="sourcecode"]
.lists/forms.py
[source,python]
----
class ExistingListItemForm(ItemForm):

    class Meta(ItemForm.Meta):
        fields = ('list', 'text')
----

We now get a little further:

----
KeyError: 'text'
----

Hm, a little debugging required.  Let's try this in our test:

[role="sourcecode"]
.lists/tests/test_forms.py (ch09l074)
[source,python]
----
    self.assertFalse(form.is_valid())
    self.fail(dict(form.errors))
    self.assertEqual(form.errors['text'], [DUPLICATE_ITEM_ERROR])
----

----
AssertionError: {'__all__': ['Item with this List and Text already exists.']}
----

Right,  Django puts uniqueness validation errors into a special `__all__` key,
because it's not clear which field it should apply to -- list or item.  We
want it to be in the `text` field though.


*******************************************************************************
Does this feel a bit like development-driven-tests?  That's OK, now 
and again.  When you're exploring a new API, you're absolutely allowed
to mess about with it for a while before you get back to rigorous TDD.  We're
using the unit test framework as a way of experimenting, but you could just
as well use an interactive console, or print statements, or whatever you
prefer.
*******************************************************************************


One more little customisation should do it:  Django uses a method called
`validate_unique` for this check, which we can customise:

[role="sourcecode"]
.lists/forms.py
[source,python]
----
class ExistingListItemForm(ItemForm):
    [...]


    def validate_unique(self):
        super().validate_unique()
        if self.non_field_errors(): #<1>
            self._update_errors({'text': [DUPLICATE_ITEM_ERROR]}) #<2>
----

We use a couple of special Django methods here:

<1> `self.non_field_errors()`, which is just the same as
+self.errors['__all__']+, but more readable, and
<2> `self._update_errors`, a Django helper method which takes care of the fact
that dictionary keys may not exist, and fields may already have errors in their
list which we want to append to (see the Django source if you're curious).

Our little debug `self.fail` tells us things are working:

----
AssertionError: {'text': ["You've already got this in your list"], '__all__':
['Item with this List and Text already exists.']}
----

Just to stay neat and tidy, let's say we want to remove that `__all__`
non-field error.  Adjust the unit test, removing the `self.fail` while we're at
it:

[role="sourcecode"]
.lists/tests/test_forms.py (ch09l076)
[source,python]
----
    self.assertFalse(form.is_valid())
    self.assertEqual(form.errors['text'], [DUPLICATE_ITEM_ERROR])
    self.assertFalse(form.non_field_errors())
----

Almost there:

----
AssertionError: ['Item with this List and Text already exists.'] is not false
----

Final step:

[role="sourcecode"]
.lists/forms.py
[source,python]
----
    def validate_unique(self):
        super().validate_unique()
        if self.non_field_errors():
            self._update_errors({'text': [DUPLICATE_ITEM_ERROR]})
            del self.errors['__all__']
----

And we're there!  A quick commit

[subs="specialcharacters,quotes"]
----
$ *git diff*
$ *git commit -a*
----


Using the existing lists item form in the list view
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now let's see if we can put this form to work in our view.  We start by
checking we're using it in the unit test:

[role="sourcecode"]
.lists/tests_test_views.py
[source,python]
----
self.assertIsInstance(response.context['form'], ExistingListItemForm)
----


// TODO: also move the template test and the context tests up,
// or to a different test

That gives us:

----
KeyError: 'form'
----

So we can adjust the view:

[role="sourcecode"]
.lists/views.py
[source,python]
----
from lists.forms import ExistingListItemForm, ItemForm
[...]

def view_list(request, list_id):
    list = List.objects.get(id=list_id)

    if request.method == 'POST':
        form = ExistingListItemForm(data={
            'text': request.POST['text'],
            'list': list.id
        })
        if form.is_valid():
            form.save()
            return redirect(list)
    else:
        form = ExistingListItemForm()

    return render(request, 'list.html', {'list': list, "form": form})
----

//TODO: use diff 078 to fix 1 bug in final diff

How about that `form.save()` eh?  If you'd never met Django ModelForms, 
there's some of the real power of a ModelForm right there!
//TODO use form.save in earlier case.  maybe add to scratchpad?

We still have failures for the two validation tests:  

----
FAIL: test_duplicate_item_validation_errors_end_up_on_lists_page
(lists.tests.test_views.ListViewTest)
AssertionError: False is not true : Couldn't find 'You&#39;ve already got this
in your list' in response
[...]
FAIL: test_empty_item_validation_errors_end_up_on_lists_page
(lists.tests.test_views.ListViewTest)
AssertionError: False is not true : Couldn't find 'You can&#39;t have an empty
list item' in response
----

We adjust the template:

[role="sourcecode"]
.lists/templates/list.html
[source,html]
----
<form method="POST" action="{% url 'view_list' list.id %}" >
    {{ form.text }}
    {% csrf_token %}
    {% if form.errors %}
        <div class="error">{{ form.text.errors }}</div>
    {% endif %}
</form>
----


And we're there!  Unit tests pass!

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
[...]
Ran 22 tests in 0.082s

OK
----

And so does our FT for validation:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.ItemValidationTest*]
Creating test database for alias 'default'...
..
 ---------------------------------------------------------------------
Ran 2 tests in 12.048s

OK
Destroying test database for alias 'default'...
----

As a final check, we re-run 'all' the FTs:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests*]
Creating test database for alias 'default'...
....
 ---------------------------------------------------------------------
Ran 4 tests in 19.048s

OK
Destroying test database for alias 'default'...
----

Hooray! Time for a final commit, and a wrap-up.


.Tips for testing views and forms
*******************************************************************************
* Split tests out into their own folder called 'tests', adding a '__init__.py'
which imports all test classes
* Split unit tests up into at least 3 files, 'test_models.py', 'test_views.py',
'test_forms.py'
* Have at least a placeholder test for each model class and each form class
* When testing views, I would recommend:
    * Using the Django Test Client
    * Check the template used
    * Check each item in the template context
        * eg check any forms are of the correct class
        * and check any objects are the right ones, or Querysets have the
        correct items.
    * Test any template logic:  any `for` or `if` should get a minimal test
    * Sanity-check that your form is rendered, and its errors are displayed

Why these points?  Skip ahead to Appendix II (under construction), and I'll 
show how they are sufficient to ensure that our views are still correct if
we refactor them to start using Class-Based Views.

TIP: Move logic out of your views as soon as you can

A generally accepted best practice in Django is to have "thin" views.  If you
find yourself writing a lot of tests for your views, it's time to start
thinking about whether that logic could be moved elsewhere: possibly to a form,
like we've done here.  Another likely spot would be a custom method on the
model class.  And -- once the complexity of the app demands it -- out of
Django-specific files and into your own classes and functions, that capture
your core business logic.
*******************************************************************************


TODO: prettier bootstrap formatting

TODO: a general philosophical discussion on design in TDD, "don't forget the
refactor step"


Epilogue: Deployment and database migrations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We've made a change to our database -- we've added some constraints to some
of the columns in the list table.  In order to apply these to our live site,
we'll need to alter the tables in the existing database. This is a
'database migration'.

The current established tool for database migrations with Django is called 
http://south.readthedocs.org/en/latest/index.html[South].  

NOTE: At the time of writing, Andrew Godwin, South's talented creator, had just
finished a
http://www.kickstarter.com/projects/andrewgodwin/schema-migrations-for-django[project]
to integrate South into the Django core, in the shape of a new feature called
https://docs.djangoproject.com/en/dev/topics/migrations/[Migrations]. I plan to
upgrade to using this new version of south at some point before publishing this
book, but I got blocked by a https://code.djangoproject.com/ticket/21236][bug].


We start by installing South:

[subs="specialcharacters,quotes"]
----
$ *../virtualenv/bin/pip install south*
[...]
Successfully installed Django
Cleaning up...
$ *../virtualenv/bin/django-admin.py --version*
1.7.dev20131006142710
----

We add it to `INSTALLED_APPS`:

[role="sourcecode"]
.superlists/settings.py
[source,python]
----
INSTALLED_APPS = (
    [...]
    # 'django.contrib.admindocs',
    'lists',
    'functional_tests',
   'south',
)
----


And to 'requirements.txt':

[role="sourcecode"]
.requirements.txt
[source,text]
----
Django==1.5.1
gunicorn==17.5
south==1.8.2
----

We can commit that to version control:

[subs="specialcharacters,quotes"]
----
$ *git commit -am "Add South"
----

Creating an initial migration to match the current live state
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For migrations to work, they need to know what we're migrating from and to.
The place this really matters is on the live server, so we want to be able
to migrate from the database state as it currently is on live, to the state
that's in the latest version of the code.

Here's where version control comes in useful. We can use `git log` to look back
for a commit that we made during chapter 8, or maybe right at the beginning of
chapter 9.

----
$ *git log --oneline*
18480bd Create base FT class and a class for each test. --ch09l002--
87e99b5 Move functional tests into a folder
7fa00f1 New ft for item validaiton. --ch09l001--
8ca488b Add a fabfile for automated deploys    # <---  this looks like it!
d28e6ea Notes and template config files for provisioning
6b0d814 Add gunicorn to virtualenv requirements
6a6c91e Add requirements.txt for virtualenv
$ *git checkout 8ca488b*
----

TODO: use a git tag to mark the last deployed version back in chapter 8

Once our source tree is back to a state that matches live, we create
our initial migration.  First you'll need to re-add south to 
`INSTALLED_APPS` in 'settings.py'. Yes, I know.  But we're essentially
re-writing history here, and sometimes that's hard.

Once you've done that, here's how we do an initial migration:

[subs="specialcharacters,quotes"]
----
$ ../virtualenv/bin/python3 manage.py schemamigration lists --initial
Creating __init__.py in '/home/harry/Dropbox/book/source/chapter_09/superlists/lists/migrations'...
 + Added model lists.List
 + Added model lists.Item
Created 0001_initial.py. You can now apply this migration with: ./manage.py migrate lists
----

The migration is stored in a directory called 'migrations' inside the
lists app:

[subs="specialcharacters,quotes"]
----
$ *tree lists/migrations/*
lists/migrations/
├── 0001_initial.py
├── __init__.py
└── __pycache__
----

We go back to the latest code version:

[subs="specialcharacters,quotes"]
----
$ *git checkout -f master*  # -f ignores change to settings.py
----

And we add the migration to version control:

[subs="specialcharacters,quotes"]
----
$ *git add lists/migrations/*
$ *git status*  # should show 2 new files
$ *git commit -m"initial migration to match live"*
----

Next we create the "real" migration that we want to apply.  This time
we use `--auto`:

[subs="specialcharacters,quotes"]
----
$ *../virtualenv/bin/python manage.py schemamigration --auto lists*
 + Added unique constraint for ['list', 'text'] on lists.Item
Created 0002_auto__add_unique_item_list_text.py. You can now apply this
migration with: ./manage.py migrate lists
----

Sure enough, it spots the new constraint.  Let's add that to VCS too:

[subs="specialcharacters,quotes"]
----
$ *git add lists/migrations/0002_auto__add_unique_item_list_text.py*
$ *git commit -m"Add new migration for list item uniqueness constraint"*
----

Migrations: like a VCS for your database
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The way migrations work is that they store a series of pictures of what your
database looks like as your code evolves.  In order to apply a migration, the
migrations tool also needs to have a view of what the database 'currently'
looks like.  

But, because we only started using migrations half-way through our development
(and this is quite a common occurrence), the migrations tool doesn't know
where it currently is.  In order to tell it, we do what's called a "fake" 
migration, to tell it that the current database state is at the 0001 migration
that we stored earlier, and that the one we want to go to is 0002.

Let's test this out locally.  First, we go and make a database that has the old
state, ie one that looks like live:

[subs="specialcharacters,quotes"]
----
$ *git checkout 8ca488b*
$ *rm ../database/database.sqlite*
$ *python3 manage.py syncdb --noinput*
$ *git checkout master*
----

Now, back on master, if you try doing a migration, you'll see that
Django is confused:

[subs="specialcharacters,quotes"]
----
$ *../virtualenv/bin/python3 manage.py migrate*
Running migrations for lists:
 - Migrating forwards to 0002_auto__add_unique_item_list_text.
 > lists:0001_initial
FATAL ERROR - The following SQL query failed: CREATE TABLE "lists_list" ("id" integer NOT NULL PRIMARY KEY)
[...]
 ! NOTE: The error which caused the migration to fail is further up.
Error in migration: lists:0001_initial
DatabaseError: table "lists_list" already exists
----

It's because Django is confused about the current state of the database. It 
thinks it needs to create this lists table, but it's already there. Here's how
we tell it that the database currently reflects the place where we are at
migration 0001, ie the place where live is:

----
$ *../virtualenv/bin/python3 manage.py migrate lists --fake 0001*
Running migrations for lists:
 - Migrating forwards to 0001_initial.
 > lists:0001_initial
   (faked)
----

And now we can test applying the real migration we want to do to
live:

----
$ *../virtualenv/bin/python3 manage.py migrate lists
Running migrations for lists:
 - Migrating forwards to 0002_auto__add_unique_item_list_text.
 > lists:0002_auto__add_unique_item_list_text
 - Loading initial data for lists.
Installed 0 object(s) from 0 fixture(s)
----

Brilliant! Are you confused?  I am, slightly, and I'm the one writing this.
Here's a recap:

* we need to apply a database migration to the live database when we deploy, 
to add the uniqueness constraint
* we're going to use South migrations for this.  We've created two migrations,
one (0001) which takes us from nothing to the old state, and one which takes
us from there to the state we want (0002)
* to test this, we've created a database in the same state as live by
checking out our old codebase and doing a syncdb
* in order to apply a migration, South needs to know what the current state
of the database is
* we tell it by applying a "fake" version of migration 0001
* then we're in a position to apply the real migration, 0002

So how are we actually going to do this on our live servers?  By replicating
those last two steps.  We're using a fabfile for our deployments, so let's 
adjust it now:

TODO: fix bug in fabfile checkout code (correct use of git reset)

[role="sourcecode"]
.dploy_tools/fabfile.py
[source,python]
----
def _update_database(source_folder):
    run('cd %s && ../virtualenv/bin/python3 manage.py syncdb' % (source_folder,))
    # one-off fake database migration. remove me before next deploy
    run('cd %s && ../virtualenv/bin/python3 manage.py migrate lists --fake 0001' % (
        source_folder,
    ))
    run('cd %s && ../virtualenv/bin/python3 manage.py migrate' % (source_folder,))
----

Still nervous?  Me too, but that's why we have a staging environment. Here 
goes nothing!

----
$ cd deploy_tools
$ fab deploy --host=superlists.ottg.eu
[superlists.ottg.eu] Executing task 'deploy'
[superlists.ottg.eu] run: mkdir -p /home/harry/sites/superlists.ottg.eu

[...]

[superlists.ottg.eu] run: cd /home/harry/sites/superlists.ottg.eu/source && ../virtualenv/bin/python3 manage.py syncdb
[superlists.ottg.eu] out: Syncing...
[superlists.ottg.eu] out: Creating tables ...
[superlists.ottg.eu] out: Creating table south_migrationhistory
[superlists.ottg.eu] out: Installing custom SQL ...
[superlists.ottg.eu] out: Installing indexes ...
[superlists.ottg.eu] out: Installed 0 object(s) from 0 fixture(s)
[superlists.ottg.eu] out: 
[superlists.ottg.eu] out: Synced:
[superlists.ottg.eu] out:  > django.contrib.auth
[superlists.ottg.eu] out:  > django.contrib.contenttypes
[superlists.ottg.eu] out:  > django.contrib.sessions
[superlists.ottg.eu] out:  > django.contrib.sites
[superlists.ottg.eu] out:  > django.contrib.messages
[superlists.ottg.eu] out:  > django.contrib.staticfiles
[superlists.ottg.eu] out:  > functional_tests
[superlists.ottg.eu] out:  > south
[superlists.ottg.eu] out: 
[superlists.ottg.eu] out: Not synced (use migrations):
[superlists.ottg.eu] out:  - lists
[superlists.ottg.eu] out: (use ./manage.py migrate to migrate these)
[superlists.ottg.eu] out: 

[superlists.ottg.eu] run: cd /home/harry/sites/superlists.ottg.eu/source && ../virtualenv/bin/python3 manage.py migrate lists --fake 0001
[superlists.ottg.eu] out:  - Soft matched migration 0001 to 0001_initial.
[superlists.ottg.eu] out: Running migrations for lists:
[superlists.ottg.eu] out:  - Migrating forwards to 0001_initial.
[superlists.ottg.eu] out:  > lists:0001_initial
[superlists.ottg.eu] out:    (faked)
[superlists.ottg.eu] out: 
----

Hooray!


