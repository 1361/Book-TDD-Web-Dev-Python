Finishing "my lists", Outside-In TDD
------------------------------------

In this chapter I'd like to talk about a technique called "outside-in" TDD.
It's pretty much what we've been doing all along, but now I'll make it
explicit, and talk about some of the common issues involved.

WARNING: the second half of this chapter is still a very rough draft.



The FT for "My Lists"
~~~~~~~~~~~~~~~~~~~~~

We know our `create_pre_authenticated_session` code works now, so we can just
write our FT to look for a "My Lists" page:


[role="sourcecode"]
.functional_tests/test_my_lists.py
[source,python]
----
    def test_logged_in_users_lists_are_saved_as_my_lists(self):
        # Edith is a logged-in user
        self.create_pre_authenticated_session()

        # She goes to the home page and starts a list
        self.browser.get(self.server_url)
        self.get_item_input_box().send_keys('Reticulate splines\n')
        self.get_item_input_box().send_keys('Immanentize eschaton\n')
        first_list_url = self.browser.current_url

        # She notices a "My lists" link, for the first time.
        self.browser.find_element_by_link_text('My lists').click()

        # She sees that her list is in there, named according to its
        # first list item
        self.browser.find_element_by_link_text('Reticulate splines').click()
        self.assertEqual(self.browser.current_url, first_list_url)

        # She decides to start another list, just to see
        self.browser.get(self.server_url)
        self.get_item_input_box().send_keys('Click cows\n')
        second_list_url = self.browser.current_url

        # Under "my lists", her new list appears
        self.browser.find_element_by_link_text('My lists').click()
        self.browser.find_element_by_link_text('Click cows').click()
        self.assertEqual(self.browser.current_url, second_list_url)

        # She logs out.  The "My lists" option disappears
        self.browser.find_element_by_id('id_logout').click()
        self.assertEqual(
            self.browser.find_elements_by_link_text('My lists'),
            []
        )
----

If you run it, the first error should look like this:

----
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"link text","selector":"My lists"}' ; Stacktrace: 
----


Outside-in TDD
~~~~~~~~~~~~~~

Our "double-loop" TDD process, in which we write the functional test first and
then the unit tests, is already a manifestation of outside-in TDD - we design
the system from the outside, and build up our code in layers. I'll point out
how we start with the most outward-facing (presentation layer), through to the
view functions (or "controllers"), and lastly the innermost layers, which in
this case will be model code.


The outside layer: presentation & templates
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The test is currently failing saying that it can't find a link saying "My
Lists". We can address that at the presentation layer, in 'home.html', in
our navigation bar. Here's the minimal code change:

[role="sourcecode"]
.lists/templates/home.html (ch17002-1)
[source,html]
----
{% if user.email %}
    <ul class="nav navbar-nav">
        <li><a href="#">My lists</a></li>
    </ul>
    <a class="btn navbar-btn navbar-right" id="id_logout" href="{% url 'logout' %}">Log out</a>
[...]
----

Of course, that link doesn't actually go anywhere, but it does get us along to
the next failure:

----
    self.browser.find_element_by_link_text('Reticulate splines').click()
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"link text","selector":"Reticulate splines"}' ; Stacktrace: 
----

Which is telling us we're going to have to build a page that lists all of a
user's lists by title.  Let's start with the basics -- a URL and a placeholder
template for it.

Again, we can go outside-in, starting at the presentation layer with just the 
URL and nothing else:


[role="sourcecode"]
.lists/templates/home.html (ch17002-2)
[source,html]
----
        <li><a href="{% url 'my_lists' user.email %}">My lists</a></li>
----


Moving down one layer to view functions (the controller)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

That will cause a template error, so we can move in one step, from the
presentation layer down to the controller layer, Django's view functions.

As always, we start with a test:

[role="sourcecode"]
.lists/test_views.py (ch17l003)
[source,python]
----
class MyListsTest(TestCase):

    def test_my_lists_url_renders_my_lists_template(self):
        response = self.client.get('/lists/users/a@b.com/')
        self.assertTemplateUsed(response, 'my_lists.html')
----

That gives:

----
AssertionError: False is not true : Template 'my_lists.html' was not a template
used to render the response. Actual template(s) used: <Unknown Template>
----

And we fix it, still at the views level, in 'urls.py', 'views.py', and by
creating 'my_lists.html':


[role="sourcecode"]
.lists/urls.py
[source,python]
----
urlpatterns = patterns('',
    url(r'^(\d+)/$', 'lists.views.view_list', name='view_list'),
    url(r'^new$', 'lists.views.new_list', name='new_list'),
    url(r'^users/(.+)/$', 'lists.views.my_lists', name='my_lists'),
)
----
//004


Here's a minimal view:

[role="sourcecode"]
.lists/views.py (ch17l005)
[source,python]
----
def my_lists(request, email):
    return render(request, 'my_lists.html')
----

And, a minimal template:

[role="sourcecode"]
.lists/templates/my_lists.html
[source,html]
----
{% extends 'base.html' %}

{% block header_text %}My Lists{% endblock %}
----

That gets our unit tests passing, but our FT is still at the same point,
saying that the "My Lists" page doesn't yet show any lists.  It wants
them to be clickable links named after the first item:

----
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate element: {"method":"link text","selector":"Reticulate splines"}' ; Stacktrace: 
----

Another pass, outside-in
~~~~~~~~~~~~~~~~~~~~~~~~

At each stage, we still let the FT drive what development we do.

Starting again at the outside layer, in the template, we can start to
write the template code we'd like to use to get the my lists page to
work the  way we want it to. It forces us to think about the API we
want our code to have, from the point of view of the things that use it, 
rather than trying to work bottom-up.

A quick re-structure of the template inheritance hierarchy
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Currently there's no place in our base template for us to put any new
content.  Also, the my lists page doesn't need the new item form, so
we'll put that into a block too, making it optional:

[role="sourcecode"]
.lists/templates/base.html (ch17l007)
[source,html]
----
    <div class="text-center">
        <h1>{% block header_text %}{% endblock %}</h1>

        {% block list_form %}
        <form method="POST" action="{% block form_action %}{% endblock %}">
            {{ form.text }}
            {% csrf_token %}
            {% if form.errors %}
                <div class="form-group has-error">
                    <div class="help-block">{{ form.text.errors }}</div>
                </div>
            {% endif %}
        </form>
        {% endblock %}

        {% block extra_content %}
        {% endblock %}

    </div>
----

We haven't seen this feature of the Django template language yet: 'list.html'
and 'home.html' now need to explicitly pull down the `list_form` block content
using `{{ block.super }}` 

[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
{% extends 'base.html' %}

{% block list_form %}{{ block.super }}{% endblock %}

{% block header_text %}Start a new To-Do list{% endblock %}

{% block form_action %}{% url 'new_list' %}{% endblock %}
----


[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
{% extends 'base.html' %}

{% block list_form %}{{ block.super }}{% endblock %}

{% block header_text %}Your To-Do list{% endblock %}

{% block form_action %}{% url 'view_list' list.id %}{% endblock %}

{% block table %}
    <table id="id_list_table">
    [...]
----

Designing our API using the template
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Meanwhile, 'my_lists.html' can just work in the new `extra_content` block:

[role="sourcecode"]
.lists/templates/my_lists.html
[source,html]
----
{% extends 'base.html' %}

{% block header_text %}My Lists{% endblock %}

{% block extra_content %}
    <h2>{{ owner.email }}'s lists</h2>
    <ul>
        {% for list in owner.list_set.all %}
            <li><a href="{{ list.get_absolute_url }}">{{ list.name }}</a></li>
        {% endfor %}
    </ul>
{% endblock %}
----

We've made several design decisions in this template which are going
to filter their way down through the code:

* We want a variable called `owner` to represent the user in our template.

* We want to be able to iterate through the lists created by the user using
  `owner.list_set.all` (I happen to know we get this for free from the Django
  ORM)

* We want to use `list.name` to print out the "name" of the list, which is
  currently specified as the text of its first element.

We can re-run our FTs, to check we didn't break anything, and to see whether
we've got any further:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests*]
[...]
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"link text","selector":"Reticulate splines"}' ; Stacktrace: 

 ---------------------------------------------------------------------
Ran 7 tests in 77.613s

FAILED (errors=1)
----


Moving down to the next layer: what the view passes to the template
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[role="sourcecode"]
.lists/tests/test_views.py (ch17l011)
[source,python]
----
from django.contrib.auth import get_user_model
User = get_user_model()
[...]

    def test_passes_owner_to_template(self):
        user = User.objects.create(email='a@b.com')
        response = self.client.get('/lists/users/a@b.com/')
        self.assertEqual(response.context['owner'], user)
----

Gives

----
KeyError: 'owner'
----

so

[role="sourcecode"]
.lists/views.py
[source,python]
----
from django.contrib.auth import get_user_model
User = get_user_model()
[...]

def my_lists(request, email):
    owner = User.objects.get(email=email)
    return render(request, 'my_lists.html', {'owner': owner})
----

We'll then get an error which will require adding a user
to our other unit test



[role="sourcecode"]
.lists/tests/test_views.py (ch17l013)
[source,python]
----
    def test_my_lists_url_renders_my_lists_template(self):
        User.objects.create(email='a@b.com')
        [...]
----

And we get to an OK

----
OK
----

Moving down again: to the model layer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Next we move down to the model layer, to get the owner.list_set.all API
working:
 

[role="sourcecode"]
.lists/tests/test_models.py (ch17l014)
[source,python]
----
from django.contrib.auth import get_user_model
User = get_user_model()
[...]

    def test_list_can_have_owners(self):
        user = User.objects.create(email='a@b.com')
        list_ = List.objects.create(owner=user)
        self.assertIn(list_, user.list_set.all())
----

The naive implementation would be this:

[role="skip"]
[source,python]
----
class List(models.Model):
    owner = models.ForeignKey(settings.AUTH_USER_MODEL)
----

But we want to make sure the list owner is optional.  Explicit
is better than implicit, and tests are documentation, so let's have a test for
that too:


[role="sourcecode"]
.lists/tests/test_models.py (ch17l016)
[source,python]
----
    def test_list_owner_is_optional(self):
        List.objects.create()  # should not raise
----

The correct implementation is this:

[role="sourcecode"]
.lists/models.py
[source,python]
----
from django.conf import settings
[...]

class List(models.Model):
    owner = models.ForeignKey(settings.AUTH_USER_MODEL, blank=True, null=True)

    def get_absolute_url(self):
        return resolve_url('view_list', self.id)
----

Now running the tests gives a database error

    return Database.Cursor.execute(self, query, params)
django.db.utils.OperationalError: table lists_list has no column named owner_id


Because we need to do a schema migration

    $ python3 manage.py schemamigration lists --auto

And commit that too

//018



List owner should be assigned on list creation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[role="sourcecode"]
.lists/tests.py (ch17l019)
[source,python]
----
from django.http import HttpRequest
[...]
from lists.views import new_list
[...]

class NewListTest(TestCase):
    [...]

    def test_list_owner_is_saved(self):
        request = HttpRequest()
        request.user = User.objects.create(email='a@b.com')
        request.POST['text'] = 'new list item'
        new_list(request)
        list_ = List.objects.all()[0]
        self.assertEqual(list_.owner, request.user)
----

We use the raw view function because our custom authentication 
makes it hard to use the Django Test Client.


    self.assertEqual(list_.owner, request.user)
AssertionError: None != <User: User object>

Here's a naive implementation:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def new_list(request):
    form = ItemForm(data=request.POST)
    if form.is_valid():
        list_ = List.objects.create()
        list_.owner = request.user
        list_.save()
        form.save(for_list=list_)
        [...]
----

But that gives errors in other tests:

----
ValueError: Cannot assign "<SimpleLazyObject:
<django.contrib.auth.models.AnonymousUser object at 0x7f3fcc855690>>":
"List.owner" must be a "User" instance
----

So we check that our user is a "real" user first:

[role="sourcecode"]
.lists/views.py (ch17l021)
[source,python]
----
from django.contrib.auth.models import AnonymousUser
[...]

    if form.is_valid():
        list_ = List.objects.create()
        if not isinstance(request.user, AnonymousUser):
            list_.owner = request.user
            list_.save()
        form.save(for_list=list_)
        return redirect(list_)
    else:
----


Final step: feeding through the .name API from the template
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


[role="sourcecode"]
.lists/tests/test_models.py (ch17l022)
[source,python]
----
    def test_list_name_is_first_item_text(self):
        list_ = List.objects.create()
        Item.objects.create(list=list_, text='first item')
        Item.objects.create(list=list_, text='second item')
        self.assertEqual(list_.name, 'first item')
----


[role="sourcecode"]
.lists/models.py (ch17l023)
[source,python]
----
    @property
    def name(self):
        return self.item_set.all()[0].text
----


And that, believe it or not, actually gets us a passing test, 
and a working "My Lists" page!

.My Lists
image::images/my_lists_screenshot.png[Screenshot of new My Lists page]


----
$ python3 manage.py test functional_tests
Creating test database for alias 'default'...
.......
 ---------------------------------------------------------------------
Ran 7 tests in 93.819s

OK
----

I'll tell you what though, those FTs are taking an annoyingly long time to 
run though.  I wonder if there's something we can do about that?


TODO: outside-in TDD wrap-up

