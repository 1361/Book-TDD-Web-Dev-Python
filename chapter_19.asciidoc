[[isolation-chapter]]
Test Isolation, and "listening to your tests"
---------------------------------------------

In the last chapter, we made the decision to leave a unit test failing in
the views layer while we proceeded to write more tests and more code at
the models layer to get it to pass.

We got away with it because our app was simple, but I should stress that,
in a more complex application, this would be a dangerous decision. Proceeding
to work on lower levels while you're not sure that the higher levels are
'really' finished or not is a risky strategy.

NOTE: I'm grateful to Gary Bernhardt, who took a look at an early draft of the
previous chapter, and encouraged me to get into a longer discussion of test
isolation.

Ensuring isolation between layers does involve more effort (and more of the
dreaded mocks!), but it can also help to drive out improved design, as we'll
see in this chapter. 


Revisiting our decision point: the views layer depends on unwritten models code
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's revisit the point we were at half-way through the last chapter, when we
couldn't get the `new_list` view to work because lists didn't have the `.owner`
attribute yet.  

We'll actually go back in time and check out the old codebase, so that we can
see how things would have worked if we'd used more isolated tests.


[subs="specialcharacters,quotes"]
----
$ *git checkout -b more-isolation*  # a branch for this experiment
$ *git checkout revisit_this_point_with_isolated_tests*
----

Here's what our failing tests looks like:


[role="sourcecode currentcontents"]
.lists/tests/test_views.py
[source,python]
----
class NewListTest(TestCase):
    [...]

    def test_list_owner_is_saved_if_user_is_authenticated(self):
        request = HttpRequest()
        request.user = User.objects.create(email='a@b.com')
        request.POST['text'] = 'new list item'
        new_list(request)
        list_ = List.objects.first()
        self.assertEqual(list_.owner, request.user)
----

And here's what our attempted solution looked like:

[role="sourcecode currentcontents"]
.lists/views.py
[source,python]
----
def new_list(request):
    form = ItemForm(data=request.POST)
    if form.is_valid():
        list_ = List()
        list_.owner = request.user
        list_.save()
        form.save(for_list=list_)
        return redirect(list_)
    else:
        return render(request, 'home.html', {"form": form})
----

And at this point, the view test is failing because we don't have the model
layer yet:

----
    self.assertEqual(list_.owner, request.user)
AttributeError: 'List' object has no attribute 'owner'
----

NOTE: You won't see this error unless you actually check out the old code
    and revert 'lists/models.py'.  You should definitely do this, part of
    the objective of this chapter is to see whether we really can write 
    tests for a models layer that doesn't exist yet.


A first attempt at using mocks for isolation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Lists don't have owners yet, but we can let the views layer tests pretend they
do by using a bit of mocking:

[role="sourcecode"]
.lists/tests/test_views.py (ch19l003)
[source,python]
----
from unittest.mock import Mock, patch

from django.http import HttpRequest
from django.test import TestCase
[...]

    @patch('lists.views.List')  #<1>
    def test_list_owner_is_saved_if_user_is_authenticated(self, mockList):
        mock_list = List.objects.create()  #<2>
        mock_list.save = Mock()
        mockList.return_value = mock_list
        request = HttpRequest()
        request.user = User.objects.create()  #<3>
        request.POST['text'] = 'new list item'

        new_list(request)

        self.assertEqual(mock_list.owner, request.user)  #<4>
----

<1> We mock out the `List` function to be able to get access to any lists
    that might be created by the view.

<2> Then we create a real List object for the view to use.  It has
    to be a real List object, otherwise the Item that the view is
    trying to save will fail with a foreign key error (this is an indication
    that the test is only partially isolated).

<3> We set a real user on the request object.  

<4> And now we can make assertions about whether the list has had
    the `.owner` attribute set on it.  

If we try to run this test now, it should pass.

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
[...]
Ran 37 tests in 0.145s
OK
----

If you don't see a pass, make sure that your views code in 'views.py' is
exactly as I've shown it, using `List()`, not `List.objects.create`.  


NOTE: Using mocks does tie you to specific ways of using an API.  This is one
of the many trade-offs involved in the use of mock objects.


Using mock side_effects to check the sequence of events
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The trouble with this test is that it can still let us get away with writing
the wrong code by mistake.  Imagine if we accidentally call save before we
we assign the owner:

[role="sourcecode"]
.lists/views.py
[source,python]
----
    if form.is_valid():
        list_ = List()
        list_.save()
        list_.owner = request.user
        form.save(for_list=list_)
        return redirect(list_)
----

The test, as it's written now, still passes:

----
OK
----

So we actually need to check, not just that the owner is assigned, but that
it's assigned 'before' we call save on our list object.

Here's how we can test the sequence of events using mocks -- you can mock out
a function, and use it as a spy to check on the state of the world at the
moment it's called:


[role="sourcecode"]
.lists/tests/test_views.py (ch19l005)
[source,python]
----
    @patch('lists.views.List')
    def test_list_owner_is_saved_if_user_is_authenticated(self, mockList):
        mock_list = List.objects.create()
        mock_list.save = Mock()
        mockList.return_value = mock_list
        request = HttpRequest()
        request.user = Mock()
        request.user.is_authenticated.return_value = True
        request.POST['text'] = 'new list item'

        def check_owner_assigned():  #<1>
            self.assertEqual(mock_list.owner, request.user)  #<1>
        mock_list.save.side_effect = check_owner_assigned  #<2>

        new_list(request)

        mock_list.save.assert_called_once_with()  #<3>
----


<1> We define a function that makes the assertion about the thing we 
    want to happen first: checking the list's owner has been set

<2> We assign that check function as a `side_effect` to the thing we
    want to check happened second.  When the view calls our mocked
    save function, it will go through this assertion.  We make sure to
    set this up before we actually call the function we're testing.

<3> Finally, we make sure that the function with the `side_effect` was
    actually triggered, ie we did `.save()`.  Otherwise our assertion
    may actually never have been run.

TIP: Two common mistakes when using mock side-effects are:  assigning the
side effect too late, i.e. 'after' you call the function under test, and
forgetting to check that the side-effect function was actually called. And
by common, I mean, "I made them both several times while writing this chapter".

At this point, if you've still got the "broken" code from above, where we
assign the owner but call save in the wrong order, you should now see a 
fail:

----
ERROR: test_list_owner_is_saved_if_user_is_authenticated
(lists.tests.test_views.NewListTest)
[...]
  File "/workspace/superlists/lists/views.py", line 17, in new_list
    list_.save()
[...]
  File "/workspace/superlists/lists/tests/test_views.py", line 84, in
check_owner_assigned
    self.assertEqual(mock_list.owner, request.user)
AttributeError: 'List' object has no attribute 'owner'
----

Notice how the failure happens when we try and save, and then go inside 
our `side_effect` function.

We can get it passing again like this:

[role="sourcecode"]
.lists/views.py
[source,python]
----
    if form.is_valid():
        list_ = List()
        list_.owner = request.user
        list_.save()
        form.save(for_list=list_)
        return redirect(list_)
----
//006


...

----
OK
----

But, boy, that's getting to be an ugly test!


Listen to your tests: ugly tests signal a need to refactor
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Whenever you find yourself having to write a test like this, and you're finding
it hard work, it's likely that your tests are trying to tell you something.
Nine lines of setup (three lines for the mock user, four more lines for
the request object, and three for our side-effect function) is way too many.

What this test is trying to tell us is that our view is doing too much work,
dealing with creating a form, creating a new list object 'and' deciding whether
or not to save an owner for the list.

We've already seen that we can make our views simpler and easier to understand
by pushing some of the work down to a form class. Why does the view need to 
create the list object?  Perhaps our `ItemForm.save` could do that?  And why
does the view need to make decisions about whether or not to save the
`request.user`?  Again, the form could do that.

While we're giving this form more responsibilities, it feels like it should
probably get a new name too.  We could call `NewListForm` instead, since
that's a better representation of what it does... something like this?

[role="sourcecode skipme"]
.lists/views.py
[source,python]
----
# don't enter this code yet, we're only imagining it.

def new_list(request):
    form = NewListForm(data=request.POST)
    if form.is_valid():
        list_ = form.save(owner=request.user)  # creates both List and Item
        return redirect(list_)
    else:
        return render(request, 'home.html', {"form": form})
----

That would be neater!  Let's see how we'd get to that state by using
fully isolated tests


Rewriting our tests for the view to be fully isolated
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Our first attempt at a test suite is for this view was highly 'integrated'.  It
needed the database layer and the forms layer to be fully functional in order
for it to pass.   We've started trying to make it more isolated, let's now go
all the way.


Keep the old integrated test suite around as a sanity-check
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Let's rename our old `NewListTest` class to `NewListViewIntegratedTest`,
and throw away our attempt at a mocky test for saving the owner, puttting
back the integrated version, with a skip on it for now:


[role="sourcecode"]
.lists/tests/test_views.py (ch19l008)
[source,python]
----
import unittest
[...]

class NewListViewIntegratedTest(TestCase):

    def test_saving_a_POST_request(self):
        [...]

    @unittest.skip
    def test_list_owner_is_saved_if_user_is_authenticated(self):
        request = HttpRequest()
        request.user = User.objects.create(email='a@b.com')
        request.POST['text'] = 'new list item'
        new_list(request)
        list_ = List.objects.first()
        self.assertEqual(list_.owner, request.user)
----

TIP: Have you heard the term "integration test" and are wondering what the
    difference is with an "integrated test"?  Go and take a peek at the
    definitions box in <<hot-lava-chapter>>.


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
[...]
Ran 37 tests in 0.139s
OK
----


A new test suite with full isolation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Let's start with a blank slate, and see if we can use isolated tests to drive
a replacement of our `new_list` view.  We'll call it `new_list2`, build it 
alongside the old view, and when we're ready, we can swap it in and see if
the old integrated tests all still pass.


[role="sourcecode"]
.lists/views.py (ch19l009)
[source,python]
----
def new_list(request):
    [...]

def new_list2(request):
    pass
----


Thinking in terms of collaborators
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In order to rewrite our tests to be fully isolated, we need to throw out or old
way of thinking about the tests in terms of the "real" effects of the view on
things like the database, and instead think of it in terms of the objects it
collaborates with, and how it interacts with them.  

In the new world, the view's main collaborator will be a form object, so we
mock that out in order to be able to fully control it, and in order to be able
to define, by wishful thinking, the way we want our form to work.


[role="sourcecode"]
.lists/tests/test_views.py (ch19l010)
[source,python]
----
from lists.views import new_list, new_list2
[...]

@patch('lists.views.NewListForm')  #<2>
class NewListViewUnitTest(unittest.TestCase):  #<1>

    def setUp(self):
        self.request = HttpRequest()
        self.request.POST['text'] = 'new list item'  #<3>

    def test_passes_POST_data_to_NewListForm(self, mockNewListForm):
        new_list2(self.request)
        mockNewListForm.assert_called_once_with(data=self.request.POST)  #<4>
----

<1> The Django `TestCase` class makes it too easy to write integrated tests.
    As a way of making sure we're writing "pure", isolated unit tests, we'll
    only use `unittest.TestCase`

<2> We mock out the NewListForm class (which doesn't even exist yet). It's
    going to be used in all the tests, so we mock it out at the class level.

<3> We set up a basic POST request in `setUp`, building up the request by
    hand rather than using the (overly integrated) Django Test Client.

<4> And we check the first thing about our new view: it initialises its
    collaborator, the `NewListForm`, with the correct constructor -- the
    data from the request.

That will start with a failure, saying we don't have a `NewListForm` in
our view yet.  


----
AttributeError: <module 'lists.views' from
'/workspace/superlists/lists/views.py'> does not have the attribute
'NewListForm'
----

Let's create a placeholder for it:


[role="sourcecode"]
.lists/views.py (ch19l011)
[source,python]
----
from lists.forms import ExistingListItemForm, ItemForm, NewListForm
[...]
----

and:

[role="sourcecode"]
.lists/forms.py (ch19l012)
[source,python]
----
class ItemForm(forms.models.ModelForm):
    [...]

class NewListForm(object):
    pass

class ExistingListItemForm(ItemForm):
    [...]
----

Next we get a real failure:


----
AssertionError: Expected 'NewListForm' to be called once. Called 0 times.
----

And we implement like this:


[role="sourcecode"]
.lists/views.py (ch19l012-2)
[source,python]
----
def new_list2(request):
    NewListForm(data=request.POST)
----


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
[...]
Ran 38 tests in 0.143s
OK
-----


Let's continue.  If the form is valid, we want to call save on it:

[role="sourcecode"]
.lists/tests/test_views.py (ch19l013)
[source,python]
----
@patch('lists.views.NewListForm')
class NewListViewUnitTest(unittest.TestCase):

    def setUp(self):
        self.request = HttpRequest()
        self.request.POST['text'] = 'new list item' 
        self.request.user = Mock() 


    def test_passes_POST_data_to_NewListForm(self, mockNewListForm):
        new_list2(self.request)
        mockNewListForm.assert_called_once_with(data=self.request.POST)


    def test_saves_form_with_owner_if_form_valid(self, mockNewListForm):
        mock_form = mockNewListForm.return_value
        mock_form.is_valid.return_value = True
        new_list2(self.request)
        mock_form.save.assert_called_once_with(owner=self.request.user)
----

That takes us to this:

[role="sourcecode"]
.lists/views.py (ch19l014)
[source,python]
----
def new_list2(request):
    form = NewListForm(data=request.POST)
    form.save(owner=request.user)
----


In the case where the form is valid, we want the view to return a redirect, 
to send us to see the object that the form has just created.  So we mock out
another of the view's collaborators, the `redirect` function:

[role="sourcecode"]
.lists/tests/test_views.py (ch19l015)
[source,python]
----
    @patch('lists.views.redirect')  #<1>
    def test_redirects_to_form_returned_object_if_form_valid(
        self, mock_redirect, mockNewListForm  #<2>
    ):
        mock_form = mockNewListForm.return_value
        mock_form.is_valid.return_value = True  #<3>

        response = new_list2(self.request)

        self.assertEqual(response, mock_redirect.return_value)  #<4>
        mock_redirect.assert_called_once_with(mock_form.save.return_value)  #<5>
----

<1> We mock out the `redirect` function, this time at the method level

<2> `patch` decorators are applied innermost first, so the new mock is injected
    to our method as before the `mockNewListForm`.

<3> We specify we're testing the case where the form is valid

<4> We check that the response from the view is the result of the `redirect`
    function.

<5> And we check that the redirect function was called with the object that
    the form returns on save.

That takes us to here:

[role="sourcecode"]
.lists/views.py (ch19l016)
[source,python]
----
def new_list2(request):
    form = NewListForm(data=request.POST)
    list_ = form.save(owner=request.user)
    return redirect(list_)
----


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
[...]
Ran 40 tests in 0.163s
OK
----

And now the failure case -- if the form is invalid, we want to render
the home page template, 

[role="sourcecode"]
.lists/tests/test_views.py (ch19l017)
[source,python]
----
    @patch('lists.views.render')
    def test_renders_home_template_with_form_if_form_invalid(
        self, mock_render, mockNewListForm
    ):
        mock_form = mockNewListForm.return_value
        mock_form.is_valid.return_value = False

        response = new_list2(self.request)

        self.assertEqual(response, mock_render.return_value)
        mock_render.assert_called_once_with(
            self.request, 'home.html', {'form': mock_form}
        )
----


That gives us:

----
AssertionError: <django.http.response.HttpResponseRedirect object at
0x7f8d3f338a50> != <MagicMock name='render()' id='140244627467408'>
----

TIP: When using assert methods on mocks, like `assert_called_once_with`,
    it's doubly important to make sure you run the test and see it fail.
    It's all too easy to make a typo in your assert function name and
    end up calling a mock method that does nothing (mine was to write
    `asssert_called_once_with` with three essses, try it!)


We make a deliberate mistake, just to make sure our tests are comprehensive:


[role="sourcecode"]
.lists/views.py (ch19l018)
[source,python]
----
def new_list2(request):
    form = NewListForm(data=request.POST)
    list_ = form.save(owner=request.user)
    if form.is_valid():
        return redirect(list_)
    return render(request, 'home.html', {'form': form})
----

That passes but it shouldn't!  One more test then:

[role="sourcecode"]
.lists/tests/test_views.py (ch19l019)
[source,python]
----
    def test_does_not_save_if_form_invalid(self, mockNewListForm):
        mock_form = mockNewListForm.return_value
        mock_form.is_valid.return_value = False
        new_list2(self.request)
        self.assertFalse(mock_form.save.called)
----

Which fails:

----
    self.assertFalse(mock_form.save.called)
AssertionError: True is not false
----

And we get to to our neat, small finished view:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def new_list2(request):
    form = NewListForm(data=request.POST)
    if form.is_valid():
        list_ = form.save(owner=request.user)
        return redirect(list_)
    return render(request, 'home.html', {'form': form})
----

...

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
[...]
Ran 42 tests in 0.163s
OK
----

Moving down to the forms layer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

So we've built up our view function based on a "wishful thinking" version
of a form called `NewItemForm`, which doesn't even exist yet. Let's write
some unit tests for it now.  

Once again, they'll be fully isolated from the layers below, which in this
case is the models layer.  So, we mock out the `Item` and `List` classes 
of the ORM:


[role="sourcecode"]
.lists/tests/test_forms.py (ch19l021)
[source,python]
----
import unittest
from unittest.mock import patch, Mock
from django.test import TestCase

from lists.forms import (
    DUPLICATE_ITEM_ERROR, EMPTY_LIST_ERROR,
    ExistingListItemForm, ItemForm, NewListForm
)


class ItemFormTest(TestCase):
    [...]

@patch('lists.forms.List')  #<1>
@patch('lists.forms.Item')  #<1>
class NewListFormTest(unittest.TestCase):

    def test_save_creates_new_list_and_item_from_cleaned_data(
        self, mockItem, mockList  #<1>
    ):
        mock_item = mockItem.return_value
        mock_list = mockList.return_value
        user = Mock()
        form = NewListForm()
        form.cleaned_data = {'text': 'new item text'}  #<2>

        def check_item_text_and_list():
            self.assertEqual(mock_item.text, 'new item text')
            self.assertEqual(mock_item.list, mock_list)
            self.assertTrue(mock_list.save.called)
        mock_item.save.side_effect = check_item_text_and_list  #<3>

        form.save(owner=user)

        self.assertTrue(mock_item.save.called)  #<4>
----

<1> We mock out the two collaborators for our form from the models layer below 

<2> Django forms store validated data in a dictionary called `.cleaned_data`. 
    Normally, it's populated when you call `form.is_valid()`, but we'll assign
    it directly. Writing more isolated test does require you to know more about
    the internals of the tools you use.

<3> We use the `side_effect` method to make sure that, when we save the new
    item object, we're doing so with a saved List and with the correct item
    text.

<4> As always, we double-check that our side-effect function was actually called.


Comparing isolated and integrated versions of the same test
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Compare this test to the old form save test in `ItemFormTest`:

[role="sourcecode currentcontents"]
.lists/tests/test_forms.py
[source,python]
----
class ItemFormTest(TestCase):
    [...]

    def test_form_save_handles_saving_to_a_list(self):
        list_ = List.objects.create()
        form = ItemForm(data={'text': 'do me'})
        new_item = form.save(for_list=list_)
        self.assertEqual(new_item, Item.objects.first())
        self.assertEqual(new_item.text, 'do me')
        self.assertEqual(new_item.list, list_)
----

It seems much more straightforward!

On the one hand, the isolated test is harder to read.  It takes a good deal
of wrapping your head around, and it's very sensitive to slight changes in the
way we use the model API (it will break if we use `Item.objects.create` instead
of `Item()`, for example).

On the other hand, the mocky test is a lot more clear about what the
dependencies of our code are.  It's harder work, but it encourages us
to keep clean separations between the layers of our code.

NOTE: One of the trade-offs between isolated an integrated tests is that
isolated tests, when they use mocks, can be harder to read and write. On the
other hand, they should help you to identify your dependencies more clearly,
and encourage you to keep your architecture clean.


If we step through the requirements of this tests, we should eventually get to
code like this:

[role="sourcecode"]
.lists/forms.py (ch19l022)
[source,python]
----
from lists.models import Item, List
[...]

class NewListForm(object):

    def save(self, owner):
        list_ = List()
        list_.save()
        item = Item()
        item.list = list_
        item.text = self.cleaned_data['text']
        item.save()
----

But our form isn't a form yet!  Let's make it inherit from `ItemForm`,
which will get us the css classes and validation for free:


[role="sourcecode"]
.lists/tests/test_forms.py (ch19l023)
[source,python]
----
    def test_is_an_ItemForm(self, mockItem, mockList):
        self.assertIsInstance(NewListForm(), ItemForm)
----

So:

[role="sourcecode"]
.lists/forms.py (ch19l024)
[source,python]
----
    class NewListForm(ItemForm):
        [...]
----


Conditionally saving owners
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Here's where we implement our new functionality: the form should conditionally
save the owner:

[role="sourcecode"]
.lists/tests/test_forms.py (ch19l025)
[source,python]
----
    def test_save_saves_owner_if_authenticated(self, mockItem, mockList):
        mock_list = mockList.return_value
        mock_list.owner = None
        user = Mock(is_authenticated=lambda: True)
        form = NewListForm()
        form.cleaned_data = {'text': 'new item text'}

        form.save(owner=user)

        self.assertEqual(mock_list.owner, user)


    def test_does_not_save_owner_if_not_authenticated(self, mockItem, mockList):
        mock_list = mockList.return_value
        mock_list.owner = None
        user = Mock(is_authenticated=lambda: False)
        form = NewListForm()
        form.cleaned_data = {'text': 'new item text'}

        form.save(owner=user)

        self.assertEqual(mock_list.owner, None)
----

One of those two will fail:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
[...]
AssertionError: None != <Mock id='140348870426896'>
[...]
Ran 46 tests in 0.172s
FAILED (failures=1)
----


And that should take us to this:

[role="sourcecode"]
.lists/forms.py
[source,python]
----
    def save(self, owner):
        list_ = List()
        if owner.is_authenticated():
            list_.owner = owner
        list_.save()
        item = Item()
        item.list = list_
        item.text = self.cleaned_data['text']
        item.save()
----


And passing tests.

----
OK
----


Finally, moving down to the models layer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Notice that we've been able to drive all this design, and the models layer
still doesn't actually implement lists having owners!  We can finally put that
together now, using the same tests we wrote in the last chapter:

[role="sourcecode"]
.lists/tests/test_models.py (ch19l027)
[source,python]
----
from django.contrib.auth import get_user_model
User = get_user_model()
[...]

class ListModelTest(TestCase):
    [...]

    def test_lists_can_have_owners(self):
        List(owner=User())  # should not raise


    def test_list_owner_is_optional(self):
        List().full_clean()  # should not raise
----

Now that we're at the models layer, we're at a boundary of the system, so 
it's OK not to use mocks any more -- we can use the real ORM, and even 
use the database if we need to.

Although in this case, I have managed to re-write the tests so that they don't
actually save objects -- just having them as in-memory objects is enough to for
this test.

TIP: Don't save models objects to the database if you don't need to. It will
    make your tests faster.


We implement, just like we did in the last chapter:

[role="sourcecode"]
.lists/models.py (ch19l028)
[source,python]
----
from django.conf import settings
[...]


class List(models.Model):
    owner = models.ForeignKey(settings.AUTH_USER_MODEL, blank=True, null=True)
    [...]
----

And a schemamigration...  takes us to failing integrated tests!  what's 
happening?

[role="dofirst-ch19l029"]
----
ValueError: Cannot assign "<SimpleLazyObject:
<django.contrib.auth.models.AnonymousUser object at 0x7fbad1cb6c10>>":
"List.owner" must be a "User" instance.
----

Ah, the old view isn't discerning enough about what it does with list
owners yet:

[role="sourcecode currentcontents"]
.lists/views.py
[source,python]
----
    if form.is_valid():
        list_ = List()
        list_.owner = request.user
        list_.save()
----


This is the point at which we realise that our old code wasn't fit for purpose.
Let's fix it to get all our tests passing:

[role="sourcecode"]
.lists/views.py (ch19l031)
[source,python]
----
def new_list(request):
    form = ItemForm(data=request.POST)
    if form.is_valid():
        list_ = List()
        if request.user.is_authenticated():
            list_.owner = request.user
        list_.save()
        form.save(for_list=list_)
        return redirect(list_)
    else:
        return render(request, 'home.html', {"form": form})


def new_list2(request):
    [...]
----

NOTE:  One of the benefits of integrated tests is that they help you to catch
    unpredictable interactions like this.  We'd forgotten about to write a test
    for the case where the user is not authenticated, but because the integrated
    tests use the stack all the way down, errors from the model layer came up
    to let us know we'd forgotten something,


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
[...]
Ran 48 tests in 0.175s
OK
----


The moment of truth (and the risks of mocking)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

So let's try switching out our old view, and activating our new view. We
can make the swap in 'urls.py':

[role="sourcecode"]
.lists/urls.py
[source,python]
----
[...]
    url(r'^new$', 'lists.views.new_list2', name='new_list'),
----

We should also remove the `unittest.skip` from our integrated test class,
and make it point at our new view (`new_list2`), to see if our new code for
list owners really works:


[role="sourcecode"]
.lists/tests/test_views.py (ch19l033)
[source,python]
----
class NewListViewIntegratedTest(TestCase):

    def test_saving_a_POST_request(self):
        [...]

    def test_list_owner_is_saved_if_user_is_authenticated(self):
        request = HttpRequest()
        request.user = User.objects.create(email='a@b.com')
        request.POST['text'] = 'new list item'
        new_list2(request)
        list_ = List.objects.first()
        self.assertEqual(list_.owner, request.user)
----

So what happens when we run our tests? Oh no!


----
ERROR: test_list_owner_is_saved_if_user_is_authenticated
[...]
ERROR: test_saving_a_POST_request
[...]
ERROR: test_redirects_after_POST
(lists.tests.test_views.NewListViewIntegratedTest)
  File "/workspace/superlists/lists/views.py", line 30, in new_list2
    return redirect(list_)
[...]
TypeError: argument of type 'NoneType' is not iterable

FAILED (errors=3)
----


Here's an important lesson to learn about test isolation: it might help you
to drive out good design for individual layers, but it won't automatically 
verify the integration 'between' your layers.

What's happened here is that the view was expecting the form to return 
a list item:

[role="sourcecode currentcontents"]
.lists/views.py
[source,python]
----
        list_ = form.save(owner=request.user)
        return redirect(list_)
----

But we forgot to make it return anything:

[role="sourcecode currentcontents"]
.lists/forms.py
[source,python]
----
    def save(self, owner):
        [...]
        item.save()
----



Thinking of interactions between layers as "contracts"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Ultimately, even if we had been writing nothing but isolated unit tests, our
functional tests would have picked up this particular slip-up.  But ideally
we'd want our feedback cycle to be quicker -- functional tests may take a
couple of minutes to run, or even a few hours once your app starts to grow.  Is
there any way to avoid this sort of problem before it happens?

Methodologically, the way to do it is to think about the interaction between
your layers in terms of contracts.  Whenever we mock out the behaviour of one
layer, we have to make a mental note that there is now an implicit contract
between the layers, and that a mock on one layer should probably translate into
a test at the layer below.

Here's the part of the contract that we missed:

[role="sourcecode currentcontents"]
.lists/tests/test_views.py
[source,python]
----
    @patch('lists.views.redirect')
    def test_redirects_to_form_returned_object_if_form_valid(
        self, mock_redirect, mockNewListForm
    ):
        mock_form = mockNewListForm.return_value
        mock_form.is_valid.return_value = True

        response = new_list2(self.request)

        self.assertEqual(response, mock_redirect.return_value)
        mock_redirect.assert_called_once_with(mock_form.save.return_value)  #<1>
----

<1> The mocked `form.save` function is returning an object, which we expect
    our view to be able to use.


Identifying implicit contracts
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It's worth reviewing each of the tests in `NewListViewUnitTest` and seeing
what each mock is saying about the implicit contract:

[role="sourcecode currentcontents"]
.lists/tests/test_views.py
[source,python]
----
    def test_passes_POST_data_to_NewListForm(self, mockNewListForm):
        [...]
        mockNewListForm.assert_called_once_with(data=self.request.POST)  #<1>


    def test_saves_form_with_owner_if_form_valid(self, mockNewListForm):
        mock_form = mockNewListForm.return_value
        mock_form.is_valid.return_value = True  #<2>
        new_list2(self.request)
        mock_form.save.assert_called_once_with(owner=self.request.user)  #<3>


    def test_does_not_save_if_form_invalid(self, mockNewListForm):
        [...]
        mock_form.is_valid.return_value = False  #<2>
        [...]


    @patch('lists.views.redirect')
    def test_redirects_to_form_returned_object_if_form_valid(
        self, mock_redirect, mockNewListForm
    ):
        [...]
        mock_redirect.assert_called_once_with(mock_form.save.return_value)  #<4>

    def test_renders_home_template_with_form_if_form_invalid(
        [...]
----

<1> We need to be able to initialise our form by passing it a POST request
    as data

<2> It should have an `is_valid()` function which returns True or False
    appropriately, based on the input data.

<3> The form should have a `.save` method which will accept a `request.user`,
    which may or may not be a logged-in user, and deal with it appropriately

<4> The form's `.save` method should return a new list object, for our view
    to redirect the user to.

If we have a look through our form tests, we'll see that, actually, only item %3%
is tested explicitly.  On items %1% and %2% we were lucky -- they're default 
features of a Django `ModelForm`, and they are actually covered by our
tests for the parent `ItemForm` class.  

But contract clause number %4% managed to slip through the net.

NOTE: When doing outside-in TDD with isolated tests, you need to keep track of
    each test's implicit assumptions about the contract which the next layer
    should implement, and remember to test each of those in turn later.  This
    is another good place to use our scratchpad.



Fixing the oversight
^^^^^^^^^^^^^^^^^^^^

Let's fix that now:


[role="sourcecode"]
.lists/tests/test_forms.py (ch19l038)
[source,python]
----
    def test_save_returns_new_list_object(self, mockItem, mockList):
        mock_list = mockList.return_value
        user = Mock(is_authenticated=lambda: True)
        form = NewListForm()
        form.cleaned_data = {'text': 'new item text'}

        response = form.save(owner=user)

        self.assertEqual(response, mock_list)
----



gives:


----
AssertionError: None != <MagicMock name='List()' id='139707803945360'>
----


And so:


[role="sourcecode"]
.lists/forms.py
[source,python]
----
class NewListForm(ItemForm):

    def save(self, owner):
        list_ = List()
        if owner.is_authenticated():
            list_.owner = owner
        list_.save()
        item = Item()
        item.list = list_
        item.text = self.cleaned_data['text']
        item.save()
        return list_
----


And that gets us to a fully passing test suite:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
[...]
Ran 49 tests in 0.169s

OK
----


One more test
~~~~~~~~~~~~~

We only have one more feature to implement, the `.name` attribute on list
objects.  Again, we can grab the test and code from the last chapter:

[role="sourcecode"]
.lists/tests/test_models.py (ch19l040)
[source,python]
----
    def test_list_name_is_first_item_text(self):
        list_ = List.objects.create()
        Item.objects.create(list=list_, text='first item')
        Item.objects.create(list=list_, text='second item')
        self.assertEqual(list_.name, 'first item')

----

(Since we're back at the boundary layer, it's OK to use the ORM again. You
could conceivable write this test using mocks, but there wouldn't be much
point).

[role="sourcecode"]
.lists/models.py (ch19l041)
[source,python]
----
    @property
    def name(self):
        return self.item_set.first().text
----


And that gets us to a passing FT!


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.test_my_lists*]

Ran 1 test in 21.428s

OK
----


Tidy-up: what to keep from our integrated test suite
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now everything is working, we can remove some redundant tests, and decide
whether we want to keep any of our old integrated tests.


Removing redundant code at the forms layer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We can get rid of the test for the old save method on the `ItemForm`:

[role="sourcecode"]
.lists/tests/test_forms.py
[source,diff]
----
--- a/lists/tests/test_forms.py
+++ b/lists/tests/test_forms.py
@@ -23,14 +23,6 @@ class ItemFormTest(TestCase):
         self.assertEqual(form.errors['text'], [EMPTY_LIST_ERROR])
 
 
-    def test_form_save_handles_saving_to_a_list(self):
-        list_ = List.objects.create()
-        form = ItemForm(data={'text': 'do me'})
-        new_item = form.save(for_list=list_)
-        self.assertEqual(new_item, Item.objects.first())
-        self.assertEqual(new_item.text, 'do me')
-        self.assertEqual(new_item.list, list_)
-
----


And if we add  one new test for the `ExistingListItemForm` we can remove a
little duplication from its tests:


[role="sourcecode"]
.lists/tests/test_forms.py
[source,diff]
----
--- a/lists/tests/test_forms.py
+++ b/lists/tests/test_forms.py
@@ -99,18 +90,8 @@ class NewListFormTest(unittest.TestCase):
 
 class ExistingListItemFormTest(TestCase):
 
-    def test_form_renders_item_text_input(self):
-        list_ = List.objects.create()
-        form = ExistingListItemForm(for_list=list_)
-        self.assertIn('placeholder="Enter a to-do item"', form.as_p())
-
-
-    def test_form_validation_for_blank_items(self):
-        list_ = List.objects.create()
-        form = ExistingListItemForm(for_list=list_, data={'text': ''})
-        self.assertFalse(form.is_valid())
-        self.assertEqual(form.errors['text'], [EMPTY_LIST_ERROR])
-
+    def test_is_an_ItemForm(self):
+        self.assertIsInstance(ExistingListItemForm(for_list=List()), ItemForm)
 
     def test_form_validation_for_duplicate_items(self):

----

And in our actual code, we can get rid of two redundant save methods in
'forms.py':

[role="sourcecode"]
.lists/forms.py
[source,diff]
----
--- a/lists/forms.py
+++ b/lists/forms.py
@@ -24,11 +24,6 @@ class ItemForm(forms.models.ModelForm):
         self.fields['text'].error_messages['required'] = EMPTY_LIST_ERROR
 
 
-    def save(self, for_list):
-        self.instance.list = for_list
-        return super().save()
-
-
 
 class NewListForm(ItemForm):
 
@@ -59,8 +54,3 @@ class ExistingListItemForm(ItemForm):
             e.error_dict = {'text': [DUPLICATE_ITEM_ERROR]}
             self._update_errors(e)
 
-
-
-    def save(self):
-        return forms.models.ModelForm.save(self)
-

----

Removing the old implementation of the view
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We can now completely remove the old `new_list` view, and rename `new_list2` to
`new_list`:

[role="sourcecode skipme"]
.lists/tests/test_views.py
[source,diff]
----
-from lists.views import new_list, new_list2
+from lists.views import new_list
 
 
 class HomePageTest(TestCase):
@@ -75,7 +75,7 @@ class NewListViewIntegratedTest(TestCase):
         request = HttpRequest()
         request.user = User.objects.create(email='a@b.com')
         request.POST['text'] = 'new list item'
-        new_list2(request)
+        new_list(request)
         list_ = List.objects.first()
         self.assertEqual(list_.owner, request.user)

@@ -91,21 +91,21 @@ class NewListViewUnitTest(unittest.TestCase): #<1>
 
     def test_passes_POST_data_to_NewListForm(self, mockNewListForm):
-        new_list2(self.request)
+        new_list(self.request)

[.. several more]

----

[role="sourcecode dofirst-ch19l045"]
.lists/urls.py
[source,diff]
----
--- a/lists/urls.py
+++ b/lists/urls.py
@@ -2,6 +2,6 @@ from django.conf.urls import patterns, url
 
 urlpatterns = patterns('',
     url(r'^(\d+)/$', 'lists.views.view_list', name='view_list'),
-    url(r'^new$', 'lists.views.new_list2', name='new_list'),
+    url(r'^new$', 'lists.views.new_list', name='new_list'),
     url(r'^users/(.+)/$', 'lists.views.my_lists', name='my_lists'),
 )
----


[role="sourcecode"]
.lists/views.py (ch19l047)
[source,python]
----
def new_list(request):
    form = NewListForm(data=request.POST)
    if form.is_valid():
        list_ = form.save(owner=request.user)
        [...]
----


And a quick check that all the tests still pass:

----
OK
----


Removing redundant code at the forms layer
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Finally, we have to decide what (if anything) to keep from our integrated test
suite.

One option is to throw them all away, and decide that the FTs will pick up any
integration problems.  That's perfectly valid.

On the other hand, we saw how integrated tests can warn you when you've made
small mistakes in integrated your layers.  We could keep just a couple of tests
around as "sanity-checks", to give us a quicker feedback cycle. 

How about these three:

[role="sourcecode"]
.lists/tests/test_views.py
[source,python]
----
class NewListViewIntegratedTest(TestCase):

    def test_saving_a_POST_request(self):
        self.client.post(
            '/lists/new',
            data={'text': 'A new list item'}
        )
        self.assertEqual(Item.objects.count(), 1)
        new_item = Item.objects.first()
        self.assertEqual(new_item.text, 'A new list item')


    def test_for_invalid_input_doesnt_save_but_shows_errors(self):
        response = self.client.post('/lists/new', data={'text': ''})
        self.assertEqual(List.objects.count(), 0)
        self.assertContains(response, escape(EMPTY_LIST_ERROR))


    def test_saves_list_owner_if_user_logged_in(self):
        request = HttpRequest()
        request.user = User.objects.create(email='logged@in.com')
        request.POST['text'] = 'new item'
        new_list(request)
        list_ = List.objects.first()
        self.assertEqual(list_.owner, request.user)
----

If you're going to keep any intermediate-level tests at all,  I like these
three because they feel like they're doing the most "integration" jobs:  they
test the full stack, from the request down to the actual database, and they
cover the three most important use cases of our view.


.On the pros and cons of different types of test
*******************************************************************************

Functional tests::
    * Provide the best guarantee that your application really works correctly.
    * But: it's a slower feedback cycle,
    * And they don't necessarily help you write clean code.

Integrated tests (reliant on, eg, the ORM or the Django Test Client)::
    * Are quick to write,
    * Easy to understand,
    * Will warn you of any integration issues,
    * But may not always drive good design.

Isolated ("mocky") tests::
    * These involve the most hard work.
    * They are harder to read and understand,
    * But: these are the only ones that can guide you towards better design

*******************************************************************************


Conclusions: When to write isolated vs integrated tests
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Django's testing tools make it very easy to quickly put together integrated
tests.  The test runner helpfully creates a fast, in-memory version of your
database and resets it for you in between each tests.  The `TestCase` class
and the Test Client make it easy to test your views, from checking whether
database objects are modified, confirming that your URL mappings work, and
inspecting the rendering of the templates.  This lets you get started with
testing very easily and get good coverage across your whole stack.

On the other hand, these kinds of integrated tests won't necessarily deliver
the full benefit that rigorous unit testing and outside-in TDD are meant to
confer in terms of design.

If we look at the example in this chapter, compare the code we had before and
after:


[role="sourcecode skipme"]
.Before
[source,python]
----
def new_list(request):
    form = ItemForm(data=request.POST)
    if form.is_valid():
        list_ = List()
        if not isinstance(request.user, AnonymousUser):
            list_.owner = request.user
        list_.save()
        form.save(for_list=list_)
        return redirect(list_)
    else:
        return render(request, 'home.html', {"form": form})
----

[role="sourcecode skipme"]
.After
[source,python]
----
def new_list(request):
    form = NewListForm(data=request.POST)
    if form.is_valid():
        list_ = form.save(owner=request.user)
        return redirect(list_)
    return render(request, 'home.html', {'form': form})
----


If we hadn't bothered to go down the isolation route, would we have bothered
to refactor the view function?  I'd like to think I would have, but it's hard
to be sure.  But writing isolated tests does make you very aware of where the
complexities in your code lie.


Let complexity be your guide
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

I'd say the point at which isolated tests start to become worth it is to do 
with complexity.  The example in this book is extremely simple, so it's not
often been worth it so far.  Even in the example in this chapter, I can
convince myself I didn't really 'need' to write those isolated tests.

But once an application gains a little more complexity -- if it starts growing
any more layers between views and models, if you find yourself writing  helper
methods, or your own classes, then you will probably gain from writing more 
isolated tests.


Should you do both?
^^^^^^^^^^^^^^^^^^^

We already have our suite of functional tests, which will serve the purpose
of telling us if we ever make any mistakes in integrating the different parts
of our code together.  Writing isolated tests can help us to drive out better
design for our code, and to verify correctness in more fine detail.  Would a 
middle layer of integration tests serve any additional purpose?

I think the answer is potentially yes, if they can provide a faster feedback
cycle, and help you identify more clearly what integration problems you suffer
from -- their tracebacks may provide you with better debug information than you
would get from a functional test, for example.

There may even be a case for building them as a separate test suite -- you could
have one suite of fast, isolated unit tests that don't even use `manage.py`, because
they don't need any of the database cleanup and teardown that the Django test 
runner gives you, and then the intermediate layer that uses Django, and finally
the functional tests layer that, say, talks to a staging server.  It may be worth
it if each layer delivers incremental benefits.

It's a judgement call.  I hope that, by going through this chapter, I've given
you a feel for what the trade-offs are.


Onwards!
^^^^^^^^

We're happy with our new version, so let's bring them across to master:


[subs="specialcharacters,quotes"]
----
$ *git add .*
$ *git commit -m"add list owners via forms. more isolated tests"*
$ *git checkout master*
$ *git checkout -b master-noforms-noisolation-bak* # optional backup
$ *git checkout master*
$ *git reset --hard more-isolation*  # reset master to our branch.
----


In the meantime -- those FTs are taking an annoyingly long time to run.  I
wonder if there's something we can do about that?

