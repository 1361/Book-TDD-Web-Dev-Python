[[appendix-bdd]]
[appendix]
Behaviour-Driven Development (BDD)
----------------------------------


* pick tool -- lettuce is popular, but doesn't support python3, so we'll choose
its main rival, 'Behave'.

* we'll also use the 'django-behave' plugin to get a test runner that's compatible with django

Basic housekeeping
~~~~~~~~~~~~~~~~~~

make a module for our tests:


[subs="specialcharacters,quotes"]
----
$ *mkdir bdd_tests*
$ *touch bdd_tests/__init__.py*
$ *touch bdd_tests/models.py*
----

Add a steps and a features directory, and placeholder for our first feature:

[subs="specialcharacters,quotes"]
----
$ *mkdir -p bdd_tests/features/steps*
$ *touch bdd_tests/features/my_lists.feature*
$ *touch bdd_tests/features/steps/my_lists.py*
$ *tree bdd_tests*
bdd_tests
├── features
│   └── my_lists.feature
│   └── steps
│       └── my_lists.py
├── __init__.py
└── models.py
----

Run "behave" as a sanity-check

[subs="specialcharacters,quotes"]
----
behave bdd_tests     
0 features passed, 0 failed, 0 skipped
0 scenarios passed, 0 failed, 0 skipped
0 steps passed, 0 failed, 0 skipped, 0 undefined
Took 0m0.000s
----


Writing an FT as a "Feature" using Gherkin syntax
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

And start writing our first "Feature".


[role="sourcecode"]
.bdd_tests/features/my_lists.feature
[source,gherkin]
----
Feature: My Lists
    Scenario:
        As a logged-in user
        I want to be able to see all my lists in one page
        So that I can find them all afer I've written them

        Given I am a logged-in user

        When I create a list with first item "Reticulate Splines"
            And I add an item "Immanentize Eschaton"
            And I create a list with first item "Buy milk"

        Then I will see a link to "My lists"
        When I click the link to "My lists"

        Then I will see a link to "Reticulate Splines"
        And I will see a link to "Buy milk"

        When I click the link to "Reticulate Splines"
        Then I will be on the "Reticulate Splines" list page
----

In this human-readable syntax, each line (which begins with "Given", "And", "When" or "Then") is
a step, and it will be implemented in code using a step function.


Generating placeholder steps
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When we run "behave", it helpfully tells us about all the steps we need to
implement:

[subs="specialcharacters,quotes"]
----
$ *behave bdd_tests*
Feature: My Lists # bdd_tests/features/my_lists.feature:1

  Scenario:                                                   # bdd_tests/features/my_lists.feature:2
    Given I am a logged-in user                               # None
    When I create a list with first item "Reticulate Splines" # None
    And I add an item "Immanentize Eschaton"                  # None
    And I create a list with first item "Buy milk"            # None
    Then I will see a link to "My lists"                      # None
    When I click the link to "My lists"                       # None
    Then I will see a link to "Reticulate Splines"            # None
    And I will see a link to "Buy milk"                       # None
    When I click the link to "Reticulate Splines"             # None
    Then I will be on the "Reticulate Splines" list page      # None


Failing scenarios:
  bdd_tests/features/my_lists.feature:2  

0 features passed, 1 failed, 0 skipped
0 scenarios passed, 1 failed, 0 skipped
0 steps passed, 0 failed, 0 skipped, 10 undefined
Took 0m0.000s

You can implement step definitions for undefined steps with these snippets:

@given('I am a logged-in user')
def step_impl(context):
    assert False

@when('I create a list with first item "Reticulate Splines"')
def step_impl(context):
    assert False

@when('I add an item "Immanentize Eschaton"')
def step_impl(context):
    assert False

[...]
----

So we can copy and paste that output into a file, and then 
make a  bunch of changes...


First step definition
~~~~~~~~~~~~~~~~~~~~~

Here's a first stab at making a step for our "Given I am a logged-in user"
step. I started by stealing the code for `create_pre_authenticated_session`
from 'functional_tests/test_my_lists.py', and adapting it slightly (removing
the server-side version, for example, although it would be easy to re-add
later).

[role="sourcecode"]
.bdd_tests/features/steps/my_lists.py
[source,python]
----
from behave import given, when, then
from functional_tests.management.commands.create_session import create_pre_authenticated_session
from django.conf import settings


@given('I am a logged-in user')
def given_i_am_logged_in(context):
    session_key = create_pre_authenticated_session(email='edith@example.com')
    ## to set a cookie we need to first visit the domain.
    ## 404 pages load the quickest!
    context.browser.get(context.server_url + "/404_no_such_url/")
    context.browser.add_cookie(dict(
        name=settings.SESSION_COOKIE_NAME,
        value=session_key,
        path='/',
    ))
----

The 'context' variable needs a little explaining -- it's a sort of global
variable, in the sense that it's passed to each step that's executed, and it
can be used to store information that we need to share between steps. Here
we've assumed we'll be storing a browser object on it, and the `server_url` (so
we're using it a lot like we used `self` when we were writing `unittest` FTs.


setUp and tearDown equivalents in environment.py
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Steps can make changes to state in the `context`, but the place to do
preliminary set-up, the equivalent of `setUp`, is in a file called
'environment.py':


[role="sourcecode"]
.bdd_tests/features/environment.py
[source,python]
----
from selenium import webdriver

def before_all(context):
    context.browser = webdriver.Firefox()
    context.browser.implicitly_wait(2)
    context.server_url = 'http://localhost:8081'

def after_all(context):
    context.browser.quit()

def before_feature(context, feature):
    pass
----


And now we switch to the django-behave test runner:

[subs="specialcharacters,quotes"]
----
$ *python manage.py test bdd_tests --testrunner=django_behave.runner.DjangoBehaveTestSuiteRunner*
Creating test database for alias 'default'...
Feature: My Lists # bdd_tests/features/my_lists.feature:1

  Scenario:                                                   # bdd_tests/features/my_lists.feature:2
    Given I am a logged-in user                               # bdd_tests/features/steps/my_lists.py:7
Not Found: /404_no_such_url/
Not Found: /favicon.ico
    Given I am a logged-in user                               # bdd_tests/features/steps/my_lists.py:7 0.379s
    When I create a list with first item "Reticulate Splines" # bdd_tests/features/steps/my_lists.py:20 0.001s
      Traceback (most recent call last):
        File "/home/harry/.virtualenvs/superlists/lib/python3.4/site-packages/behave/model.py", line 1173, in run
          match.run(runner.context)
        File "/home/harry/.virtualenvs/superlists/lib/python3.4/site-packages/behave/model.py", line 1589, in run
          self.func(context, *args, **kwargs)
        File "bdd_tests/features/steps/my_lists.py", line 22, in step_impl
          assert False
      AssertionError
[...]   
----

And you'll notice all this output is nicely coloured, as in <<behave-output>>:

[[behave-output]]
.Behave with coloured console ouptut
image::images/behave-output-colour.png[Colourful console output]

That seems to have made it through the first step, let's define up the rest of
them.  

Capturing parameters in steps
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We'll see how behave allows you to capture parameters from step descriptions. Our next step
says:

[role="sourcecode"]
.bdd_tests/features/my_lists.feature
[source,gherkin]
----
    When I create a list with first item "Reticulate Splines"
----

And the auto-generated step definition looked like this

[role="sourcecode currentcontents"]
.bdd_tests/features/steps/test_my_lists.py
[source,python]
----
@when('I create a list with first item "Reticulate Splines"')
def step_impl(context):
    assert False
----

We want to be able to create lists with arbitrary first items, so it would be nice to somehow
capture whatever is between those quotes, and pass them in as an argument to a more generic
function.  That's a common requirement in BDD, and behave has a nice syntax for it, reminiscent
of the new-style Python string formatting syntax:


[role="sourcecode"]
.bdd_tests/features/steps/test_my_lists.py
[source,python]
----
@when('I create a list with first item "{first_item_text}"')
def create_a_list(context, first_item_text):
    context.browser.get(context.server_url)
    context.browser.find_element_by_id('id_text').send_keys(first_item_text)
    context.browser.find_element_by_id('id_text').send_keys('\n')
----

Neat huh?

Similarly, we can do adding to an existing list, and see or click on links:


[role="sourcecode"]
.bdd_tests/features/steps/test_my_lists.py
[source,python]
----
@when('I add an item "{item_text}"')
def add_an_item(context, item_text):
    context.browser.find_element_by_id('id_text').send_keys(item_text)
    context.browser.find_element_by_id('id_text').send_keys('\n')

@then('I will see a link to "{link_text}"')
def see_a_link(context, link_text):
    context.browser.find_element_by_link_text(link_text)

@when('I click the link to "{link_text}"')
def click_link(context, link_text):
    context.browser.find_element_by_link_text(link_text).click()
----

And finally the slightly more complex step that says I am on the 
page for a particular list:

[role="sourcecode"]
.bdd_tests/features/steps/test_my_lists.py
[source,python]
----
@then('I will be on the "{first_item_text}" list page')
def step_impl(context, first_item_text):
    table = context.browser.find_element_by_id('id_list_table')
    rows = table.find_elements_by_tag_name('tr')
    expected_row_text = '1: ' + first_item_text
    assert rows[0].text == expected_row_text
----

