[[cheat-sheet]]
[appendix]
Cheat Sheet
-----------

By popular demand, this "cheat sheet" is loosely based on the little
recap/summary boxes from the end of each chapter.  The idea is to provide a few
reminders, and links to the chapters where you can find out more to jog your
memory. I hope you find it useful!


Initial project setup
~~~~~~~~~~~~~~~~~~~~~

* Start with a 'User Story' and map it to a first functional test

* Pick a test framework -- `unittest` is fine, options like `py.test`
  and `nose` can also offer some attributes

* Run the Functional Test and see your first 'expected failure'

* Pick a web framework such as Django, and find out how to run
  'unit tests' against it.

* Create your first 'unit test' to address the current FT failure,,
  and see it fail.

* Do  your 'first commit' to a VCS like 'Git'.

Relevant chapters: <<chapter-1>>, <<chapter-2>>, <<chapter-3>>.


The basic TDD workflow
~~~~~~~~~~~~~~~~~~~~~~

* Double-loop TDD (<<Double-Loop-TDD-diagram2>>)

* Red, Green, Refactor

* Trianglulation

* The scratchpad

* "3 Strikes and Refactor"

* "Working State to Working State"

* "YAGNI"


[[Double-Loop-TDD-diagram2]]
.The TDD process with Functional and Unit tests
image::images/twdp_0404.png[A flowchart showing functional tests as the overall cycle, and unit tests helping to code]


Chapters <<chapter-4>>, <<chapter-5>>, <<chapter-6>>.



Moving beyond dev-only testing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Start system testing early. Ensure your components work together: web server,
  static content, database

* Build a staging environment to match your production environment, and run
  your FT suite against it.

* Automate your staging and production environments:
    * PaaS vs VPS
    * Fabric
    * Configuration management (Chef, Puppett, Salt, Ansible...)
    * Vagrant

* Think through deployment pain points

* Build a CI server as soon as possible, so that you don't have to rely
  on self-discipline to see the tests run.

See <<deployment-chapter>>, <<fabric-chapter>>, <<CI-chapter>>, and
<<appendix3>>.


General testing best practices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Each test should test one thing

* One tests file per application code source file

* Consider at least a placeholder test for every function and class,
  no matter how simple.

* "Don't test constants"

* Try to test behaviour rather than implementation

* Try to think beyond the charmed path through the code, and think
  through edge cases, and error cases.


See <<manual-validation-chapter>>, <<simple-form-chapter>>,


Selenium / functional testing best practices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Use explicit rather than implicit waits, and the interaction / wait pattern

* Avoid duplication of test code -- helper methods in base class, or Page
  pattern are one way to go

* Avoid double-testing functionality. If you have a test that covers a 
  time-consuming process (eg login), consider ways of skipping it in 
  other tests (but be aware of unexpected interactions between seemingly
  unrelated bits of functionality)

* Look into BDD tools as another way of structuring your FTs

See <<testfixtures-and-logging>>, <<CI-chapter>>, and <<page-pattern-chapter>>.



Outside-in, Test Isolation vs integrated tests, and mocking
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Be reminded of the reason we right tests in the first place:

* To ensure correctness, and prevent regressions
* To help us to write clean, maintainable code
* To enable a fast, productive workflow

And with those objectives in mind, think of different types of tests,
and the tradeoffs between them


Functional tests::
    * Provide the best guarantee that your application really works correctly,
    from the point of view of the user.
    * But: it's a slower feedback cycle,
    * And they don't necessarily help you write clean code.

Integrated tests (reliant on, eg, the ORM or the Django Test Client)::
    * Are quick to write,
    * Easy to understand,
    * Will warn you of any integration issues,
    * But may not always drive good design (that's up to you!).
    * And are usually slower than isolated tests

Isolated ("mocky") tests::
    * These involve the most hard work.
    * They can be harder to read and understand,
    * But: these are the best ones for guiding you towards better design.
    * And they run the fastest.


See <<outside-in-chapter>>, <<isolation-chapter>>, <<hot-lava-chapter>>.

