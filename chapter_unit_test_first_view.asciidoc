[[chapter_unit_test_first_view]]
Testing a Simple Home Page with [keep-together]#Unit Tests#
-----------------------------------------------------------

Let's start an app for our to-do lists:


Our First Django App, and Our First Unit Test
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

'Projects' are made up of 'apps'...

[subs="specialcharacters,quotes"]
----
$ *python manage.py startapp lists*
----

That will create a folder called 'lists', next to 'manage.py' and the existing
'superlists' folder , and within it a number of placeholder files for things
like models, views, and, of immediate interest to us, tests:

----
.
├── db.sqlite3
├── functional_tests.py
├── lists
│   ├── admin.py
│   ├── apps.py
│   ├── __init__.py
│   ├── migrations
│   │   └── __init__.py
│   ├── models.py
│   ├── tests.py
│   └── views.py
├── manage.py
├── superlists
│   ├── __init__.py
│   ├── __pycache__
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── virtualenv
    ├── [...]
----


Unit Tests, and How They Differ from Functional Tests
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

NOTE: a good place to ask questions, if I don't explain myself well here!


Unit Testing in Django
~~~~~~~~~~~~~~~~~~~~~~



((("unit tests", "in Django", "writing basic", secondary-sortas="Django", id="UTdjango03")))Let's
see how to write a unit test for our home page view. Open up the new
file at 'lists/tests.py', and you'll see something like this:


[role="sourcecode currentcontents"]
.lists/tests.py
====
[source,python]
----
from django.test import TestCase

# Create your tests here.
----
====


Let's deliberately create a breaking test and see if we can see it fail.

[role="sourcecode"]
.lists/tests.py
====
[source,python]
----
from django.test import TestCase

class SmokeTest(TestCase):

    def test_bad_maths(self):
        self.assertEqual(1 + 1, 3)
----
====


Now let's invoke this mysterious Django test runner. As usual, it's a
'manage.py' [keep-together]#command#:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test*]
Creating test database for alias 'default'...
F
======================================================================
FAIL: test_bad_maths (lists.tests.SmokeTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "...python-tdd-book/lists/tests.py", line 6, in test_bad_maths
    self.assertEqual(1 + 1, 3)
AssertionError: 2 != 3

 ---------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
System check identified no issues (0 silenced).
Destroying test database for alias 'default'...
----

Excellent.  The machinery seems to be working. This is a good point for a
commit:


[subs="specialcharacters,quotes"]
----
$ *git status*  # should show you lists/ is untracked
$ *git add lists*
$ *git diff --staged*  # will show you the diff that you're about to commit
$ *git commit -m "Add app for lists, with deliberately failing unit test"*
----

As you've no doubt guessed, the `-m` flag lets you pass in a commit message
at the command-line.


Django's MVC, URLs, and View Functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Ask if I don't explain all three clearly! 

* MVC
* resolving URLs
* view functions

Open up 'lists/tests.py', and change our silly test to something like this:


Unit testing a view
~~~~~~~~~~~~~~~~~~~

[role="sourcecode"]
.lists/tests.py
====
[source,python]
----
from django.http import HttpRequest
from django.test import TestCase
from lists.views import home_page  #<2>

class HomePageTest(TestCase):

    def test_home_page_returns_correct_html(self):
        request = HttpRequest() #<1>
        response = home_page(request) #<2>
        html = response.content.decode('utf8')
        self.assertTrue(html.startswith('<html>')) #<3>
        self.assertIn('<title>To-Do lists</title>', html) #<4>
        self.assertTrue(html.endswith('</html>')) #<3>
----
====


So, what do you think will happen when we run the tests?


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test*]
ImportError: cannot import name 'home_page'
----


At Last! We Actually Write Some Application Code!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

What next?


[role="sourcecode"]
.lists/views.py
====
[source,python]
----
from django.shortcuts import render

# Create your views here.
home_page = None
----
====


Yeah. Srsly


Unit test / code cycle
^^^^^^^^^^^^^^^^^^^^^^

Next error:
+
----
    response = home_page(request)
TypeError: 'NoneType' object is not callable
----

Back in 'lists/views.py':


* minimal code:
+
[role="sourcecode"]
.lists/views.py
====
[source,python]
----
from django.shortcuts import render

# Create your views here.
def home_page():
    pass
----
====


* tests:
+
----
TypeError: home_page() takes 0 positional arguments but 1 was given
----

Let's see how fast we can get this cycle going:

* Minimal code change:
+
[role="sourcecode"]
.lists/views.py
====
[source,python]
----
def home_page(request):
    pass
----
====


* Tests:
+
----
html = response.content.decode('utf8')
AttributeError: 'NoneType' object has no attribute 'content'
----


* Code--we use `django.http.HttpResponse`, as predicted:
+
[role="sourcecode"]
.lists/views.py
====
[source,python]
----
from django.http import HttpResponse

# Create your views here.
def home_page(request):
    return HttpResponse()
----
====

* Tests again:
+
----
    self.assertTrue(html.startswith('<html>'))
AssertionError: False is not true
----


[role="pagebreak-before"]
* Code again:
+
[role="sourcecode"]
.lists/views.py
====
[source,python]
----
def home_page(request):
    return HttpResponse('<html>')
----
====

* Tests:
+
----
AssertionError: '<title>To-Do lists</title>' not found in '<html>'
----

* Code:
+
[role="sourcecode"]
.lists/views.py
====
[source,python]
----
def home_page(request):
    return HttpResponse('<html><title>To-Do lists</title>')
----
====

* Tests--almost there?
+
----
    self.assertTrue(html.endswith('</html>'))
AssertionError: False is not true
----

* Come on, one last effort:
+
[role="sourcecode"]
.lists/views.py
====
[source,python]
----
def home_page(request):
    return HttpResponse('<html><title>To-Do lists</title></html>')
----
====


* Surely?
+
[subs="specialcharacters,macros"]
----
$ pass:quotes[*python manage.py test*]
Creating test database for alias 'default'...
.
 ---------------------------------------------------------------------
Ran 1 test in 0.003s

OK
System check identified no issues (0 silenced).
Destroying test database for alias 'default'...
----

Yes!  Now, let's run our functional tests.  Don't forget to spin up the dev
server again, if it's not still running. It feels like the final heat
of the race here; surely this is it...could it be?

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python functional_tests.py*]
F
======================================================================
FAIL: test_can_start_a_list_and_retrieve_it_later (__main__.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "functional_tests.py", line 18, in
test_can_start_a_list_and_retrieve_it_later
    self.assertIn('To-Do', self.browser.title)
AssertionError: 'To-Do' not found in 'Welcome to Django'

 ---------------------------------------------------------------------
Ran 1 test in 1.747s

FAILED (failures=1)
----

Nope!


Urls.py
~~~~~~~


[role="sourcecode"]
.superlists/urls.py
[source,python]
----
from django.conf.urls import url
from lists import views

urlpatterns = [
    url(r'^$', views.home_page, name='home'),
]
----


.Advanced Exercise:
********************************************************************

How would you write a unit test for urls.py?  Hint: look into the Django
'reverse' and 'resolve' functions.

********************************************************************




Back to FTS:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 functional_tests.py*]
F
======================================================================
FAIL: test_can_start_a_list_and_retrieve_it_later (__main__.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "functional_tests.py", line 19, in
test_can_start_a_list_and_retrieve_it_later
    self.fail('Finish the test!')
AssertionError: Finish the test!

 ---------------------------------------------------------------------
Ran 1 test in 1.609s

FAILED (failures=1)
----

Yay!  expected failure.



[subs="specialcharacters,quotes"]
----
$ *git diff* # should show urls.py, tests.py, views.py
$ *git commit -am"Basic view now returns minimal HTML"*
----


Not bad--we covered:


* Starting a Django app
* The Django unit test runner
* The difference between FTs and unit tests
* Django URL resolving and 'urls.py'
* Django view functions, request and response objects
* And returning basic HTML


[role="pagebreak-before less_space"]
.Useful Commands and Concepts
*******************************************************************************
((("Django framework", "commands and concepts", "python manage.py runserver")))Running the Django dev server::
    *`python manage.py runserver`*

((("Django framework", "commands and concepts", "python functional_tests.py")))Running the functional tests::
    *`python functional_tests.py`*

((("Django framework", "commands and concepts", "python manage.py test")))Running the unit tests::
    *`python manage.py test`*

((("Django framework", "commands and concepts", "unit-test/code cycle")))((("unit-test/code cycle")))The unit-test/code cycle::
    1. Run the unit tests in the terminal.
    2. Make a minimal code change in the editor.
    3. Repeat!

*******************************************************************************

