User authentication, the admin site and integrating 3rd party plugins
---------------------------------------------------------------------

So our beautiful lists site has been live for a few days, and our users are
starting to come back to us with feedback.  "We love the site", they say, "but
we keep losing our lists.  Manually remembering URLs is hard. It'd be great if
it could remember what lists we'd started"

Remember Henry Ford and faster horses. Whenever you hear a user requirement,
it's important to dig a little deeper and think -- what is the real requirement
here?  And how can I make it involve a cool new technology I've been wanting
to try out?

Clearly the requirement here is that people want to have some kind of user
account on the site.  So, without further ado, let's dive into authentication.

Naturally we're not going to mess about with remembering passwords ourselves
-- besides being 'so' 90s, secure storage of user passwords is a security
nightmare we'd rather leave to someone else.  We'll use federated
authentication system instead.

NOTE: If you 'insist' on storing your own passwords, Django's default auth
module ready and waiting for you. It's nice and straightforward, and I'll leave
it to you to discover on your own.


Mozilla Persona (Browser-ID)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

But which federated authentication system?  Oauth?  Openid?  "Login with
Facebook"?   Ugh.  In my book those all have unacceptable creepy overtones,
why should Google or Facebook know what sites you're logging into and when?
Thankfully there are still some techno-hippy-idealists out there, and the
lovely people at Mozilla have cooked up a privacy-friendly auth mechanism
they call "Persona", or sometimes "browser-id".  

The theory goes that your web browser acts as a third party between the
website that wants to check your ID, and the website that you will use
as a guarantor of your ID.  This latter may be Google or Facebook or whomever,
but a clever protocol means that they never need know which website you were
logging into or when.

Ultimately, Persona may never take off as an authentication platform, but
the main lessons from this chapter should be relevant no matter what 3rd
party auth system you want to integrate:

* Don't test other people's code or APIs
* But, test that you've integrated them correctly into your own code
* Check everything works from the point of view of the user
* Test that your system degrades gracefully if the third party is down


Exploratory coding, aka "spiking"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Before I wrote this chapter all I'd seen of Persona was a talk at PyCon by Dan
Callahan, in which he promised it could be implemented in 30 lines of code, and
magic'd his way through a demo -- in other words, I knew it not at all.

In chapters 10 & 11 we saw that you can use a unit test as a way of
exploring a new API, but sometimes you just want to hack something together
without any tests at all, just to see if it works, to learn it or get a feel for
it.  That's absolutely fine.  When learning a new tool or exploring a new
possible solution, it's often appropriate to leave the rigorous TDD process to
one side, and build a little prototype without tests, or perhaps with very few
tests.  The goat doesn't mind looking the other way for a bit.

This kind of prototyping activity is often called a "spike", for 
http://stackoverflow.com/questions/249969/why-are-tdd-spikes-called-spikes[reasons
best known].

The first thing I did was take a look at an existing  django-persona integration
called https://github.com/mozilla/django-browserid[Django-BrowserID], but
unfortunately it didn't really support Python 3.  I'm sure it will by the time
you read this, but I was quietly relieved since I was rather looking forward
to writing my own code for this! 

It took me about 3 hours of hacking about, using a combination of code stolen
from Dan's talk and the example code on the
https://developer.mozilla.org/en-US/docs/Mozilla/Persona[Persona site], but by
the end I had something which just about works.  I'll take you on a tour,
and then we'll go through and "de-spike" the implementation.  Feel free to
add this code to your own site too, and then you can have a play with it too!

Let's start with the front-end.  I was able to cut & paste code from the
Persona site and Dan's slides with essentially no modification:


[source,html]
.lists/templates/base.html
----
        <script src="/static/bootstrap/js/bootstrap.min.js"></script>
        <script src="https://login.persona.org/include.js"></script>
        <script>
            $(document).ready(function() {

var loginLink = document.getElementById('login');
if (loginLink) {
  loginLink.onclick = function() { navigator.id.request(); };
}

var logoutLink = document.getElementById('logout');
if (logoutLink) {
  logoutLink.onclick = function() { navigator.id.logout(); };
}

var currentUser = '{{ user.email }}' || null;
var csrf_token = '{{ csrf_token }}';
console.log(currentUser);

navigator.id.watch({
  loggedInUser: currentUser,
  onlogin: function(assertion) {
    $.post('/accounts/login', {assertion: assertion, csrfmiddlewaretoken: csrf_token})
    .done(function() { window.location.reload(); })
    .fail(function() { navigator.id.logout();});
  },
  onlogout: function() {
    $.post('/accounts/logout')
    .always(function() { window.location.reload(); });
  }
});

            });
        </script>
----

The Persona JavaScript library gives us a special `navigator.id` object.
We bind its `request` method to our a link called "login" (which I've put
in any old where at the top of the page), and similarly a "logout" link 
gets bound to a `logout` function.

[role="sourcecode"]
.lists/templates/base.html
[source,html]
----
<body>
    <div id="auth">
        {% if user.email %}
            <p>Logged in as {{ user.email}}</p>
            <p><a id="logout" href="{% url 'logout' %}">Sign out</a></p>
        {% else %}
            <a href="#" id="login">Sign in</a>
        {% endif %}
        <p>User: {{user}}</p>
    </div>
    <div class="container">
    [...]
----


Persona will now pop up its authentication dialog box if users
click the log in link. What happens next is the clever part of the Persona
protocol:  the user enters an email address, and the browser takes care
of validating that email address, by taking the user to the email provider
(Google, Yahoo or whoever), and validating it with them. 

Let's say it's Google: Google asks the user to confirm their username and
password, and maybe even does some two-factor auth wizardry, and is then
prepared to confirm to your browser that you are who you say you are.  Google
then passes a certificate back to the browser, which is cryptographically
signed to prove it's from Google, and which contains the user's email address.

At this point the browser can trust that you do own that email address, and
it can incidentally re-use that certificate for any other websites that use
Persona.

Now it combines the certificate with the domain name of the website
you want to log into into a blob called an "assertion", and sends them on
to our site for validation.

This is the point between the `navigator.id.request` and the
`navigator.id.watch` callback for `onlogin` - we send the assertion via
POST to the login URL on our site, which I've put at 'accounts/login'.

On the server, we now have the job of verifying the assertion: is it really
proof that the user owns that email address?  Our server can check, because
Google has signed part of the assertion with its public key.  We can either
write code to do the crypto for this step ourselves, or we can use a public
service from Mozilla to do it for us?

NOTE: yes, letting Mozilla do it for us totally defeats the whole privacy
point, but it's the 'principle'. We could do it ourselves if we wanted to.
It's left as an exercise for the reader!  There's more details on the 
https://developer.mozilla.org/en-US/docs/Mozilla/Persona/Protocol_Overview[Mozilla
site], including all the clever public key crypto that keeps Google from 
knowing what site you want to log into, but also stops replay attacks and
so on. Smart.


Here's the view that handles the POST to 'accounts/login':

[source,python]
.accounts/views.py
----
from django.contrib.auth import authenticate
from django.contrib.auth import login as auth_login
from django.shortcuts import redirect

def login(request):
    print('login view', file=sys.stderr)
    #user = PersonaAuthenticationBackend().authenticate(request.POST['assertion'])
    user = authenticate(assertion=request.POST['assertion'])
    if user is not None:
        auth_login(request, user)
    return redirect('/')
----

And here's the `authenticate` function, which is implemented as a custom
Django authentication backend (we could have done it inline in the view,
but using an authentication backend will let us re-use the authentication
system in the admin site, for example.

//TODO: check, is this actually true?

[source,python]
.accounts/authentication.py
----
from accounts.models import ListUser

class PersonaAuthenticationBackend(object):

    def authenticate(self, assertion):
        # Send the assertion to Mozilla's verifier service.
        data = {'assertion': assertion, 'audience': 'localhost'}
        print('sending to mozilla', data, file=sys.stderr)
        resp = requests.post('https://verifier.login.persona.org/verify', data=data)
        print('got', resp, file=sys.stderr)

        # Did the verifier respond?
        if resp.ok:
            # Parse the response
            verification_data = resp.json()

            # Check if the assertion was valid
            if verification_data['status'] == 'okay':
                email = verification_data['email']
                try:
                    return self.get_user(email)
                except ListUser.DoesNotExist:
                    return ListUser.objects.create(email=email)


    def get_user(self, email):
        return ListUser.objects.get(email=email)
----

This code is copy-pasted directly from the Mozilla site, as you can see from
the explanatory comments.  To finish off the job of customising authentication
in Django, we just need a custom user model:

[source,python]
.accounts/models.py
----
class ListUser(AbstractBaseUser, PermissionsMixin):
    email = models.EmailField(primary_key=True)
    USERNAME_FIELD = 'email'
    #REQUIRED_FIELDS = ['email', 'height']

    objects = ListUserManager()

    @property
    def is_staff(self):
        return self.email == 'harry.percival@gmail.com'

    @property
    def is_active(self):
        return True
----

That's what I call a minimal user model!  One field, none of this
firstname/lastname/username nonsense, and, pointedly, no password! 
Somebody else's problem!   But you can see that this code isn't ready
for production, from the commented-out lines to the hard-coded harry
email address.

NOTE: At this point I'd recommend a little browse through the 
https://docs.djangoproject.com/en/1.5/topics/auth/customizing/[Django 
auth documentation]

Aside from that, you need a model manager for the user:

[source,python]
.accounts/models.py
----
class ListUserManager(BaseUserManager):

    def create_user(self, email):
        ListUser.objects.create(email=email)

    def create_superuser(self, email, password):
        self.create_user(email)
----

And a logout view:


[role="sourcecode"]
.lists/tests.py
[source,python]
----
def logout(request):
    auth_logout(request)
    return redirect('/')
----

And finally, switch on the auth backend and our new accounts app in
'settings.py':

[role="sourcecode"]
.superlists/settings.py
[source,python]
----
    'django.contrib.staticfiles',
    # Uncomment the next line to enable the admin:
    'django.contrib.admin',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
    'lists',
    'functional_tests',
    'south',
    'accounts',
)

AUTH_USER_MODEL = 'accounts.ListUser'
AUTHENTICATION_BACKENDS = (
    'accounts.authentication.PersonaAuthenticationBackend',
)
----

Why not spin up a dev server with `runserver` and see how it all looks?

.It works! It works! mwahahahaha.
image::images/mozilla_persona_signin.png["The Persona login screen"]

NB - you will need to run a `syncdb` to get the accounts tables all
set up.

That's pretty much it! Along the way, I had to fight pretty hard, including
debugging ajax requests by hand in the Firefox console, catching infinite
page-refresh loops, stumbling over several missing attributes on my custom user
model (because I didn't read the docs properly), and finally discovering that
we have to upgrade to the dev version of Django to actually get it to work in
the admin site.
footnote:[http://stackoverflow.com/questions/16983547/django-problems-with-id-in-custom-usermodel/18458659#18458659]
But we now have a working solution!  Time to de-spike

//TODO screenshot ajax debug



De-Spiking
~~~~~~~~~~

De-Spiking means re-writing your prototype code using TDD.  We now have enough
information to "do it properly".  So what's the first step?  An FT of course!

A common Selenium technique: waiting for 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Here's the basic outline:

[role="sourcecode"]
.lists/functional_tests/tests/test_login.py
[source,python]
----
from .base import FunctionalTest

class LoginTest(FunctionalTest):

    def test_login_with_persona(self):
        # Edith goes to the awesome superlists site
        # and notices a "Sign in" link for the first time.
        self.browser.get(self.server_url)
        self.browser.find_element_by_id('login').click()

        # A Persona login box appears
        self.switch_to_new_window('Mozilla Persona')
        self.browser.find_element_by_id(
            'authentication_email'
        ).send_keys(TEST_EMAIL)
        self.browser.find_element_by_tag_name('button').click()

        # We get redirected to the Yahoo page
        self.wait_for_element_with_id('username')
        self.browser.find_element_by_id(
            'username'
        ).send_keys(TEST_EMAIL)
        self.browser.find_element_by_id(
            'passwd'
        ).send_keys(TEST_PASSWORD)
        self.browser.find_element_by_id('.save').click()

        # The Persona window closes
        self.switch_to_new_window('To-Do')

        # She can see that she is logged in
        self.wait_for_element_with_id('logout')
----

It needs two helper functions, both of which do something that's very
common in Selenium testing:  the wait for something to happen.  Here's
the first:


[role="sourcecode"]
.lists/functional_tests/tests/test_login.py
[source,python]
----
import time
[...]

    def switch_to_new_window(self, text_in_title):
        retries = 50
        while retries > 0:
            for handle in self.browser.window_handles:
                self.browser.switch_to_window(handle)
                if text_in_title in self.browser.title:
                    return
            retries -= 1
            time.sleep(0.2)
        self.fail('could not find window')
----

In this one we've "rolled our own" wait -- we iterate through all the
current browser windows, looking for one with a particular title. If
we can't find it, we do a short wait, and try again, decrementing a retry
counter.

This is such a common pattern in Selenium tests that the team created an API
for waiting -- it doesn't quite handle all use cases though, so that's why we 
had to roll our own the first time around.  When doing something simpler like
waiting for an element with a given ID to appear on the page, we can use the
`WebDriverWait` class:


[role="sourcecode"]
.lists/functional_tests/tests/test_login.py
[source,python]
----
from selenium.webdriver.support.ui import WebDriverWait
[...]

    def wait_for_element_with_id(self, element_id):
        WebDriverWait(self.browser, timeout=10).until(
            lambda b: b.find_element_by_id(element_id)
        )
----

This is what Selenium calls an "explicit wait".  If you remember, we
already defined an "implicit wait" in the `FunctionalTest.setUp`.  We set that
to just 3 seconds though, which is fine in most cases, but when we're waiting
for an external service like Persona, we sometimes need to bump that default
timeout.

There are more examples in the 
http://docs.seleniumhq.org/docs/04_webdriver_advanced.jsp[Selenium docs], but I
actually found reading the 
http://code.google.com/p/selenium/source/browse/py/selenium/webdriver/support/wait.py[source
code] more instructive -- there are good docstrings!

And if we run the FT, it works!

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.LoginTest*]
Creating test database for alias 'default'...
login view
sending to mozilla {'audience': 'localhost', 'assertion':
[...]
/usr/lib/python3.3/http/client.py:1172: DeprecationWarning: the 'strict'
argument isn't supported anymore; http.client now always assumes HTTP/1.x
compliant servers.
  source_address)

got <Response [200]>
.
 ---------------------------------------------------------------------
Ran 1 test in 32.222s

OK
Destroying test database for alias 'default'...
----

You can even see some of the debug output I left in my spiked view
implementations.  Now it's time to revert all of our temporary changes,
and re-introduce them one by one in a test-driven way.

Reverting our temporary changes

[subs="specialcharacters,quotes"]
----
$ *git add functiional_tests* # save our new FT.
$ *git commit -m "FT for login with Persona"*
$ *git add .*  # commit everything else, for reference
$ *git commit -m "SPIKED Persona implementation"*
$ *git revert HEAD* # and revert all our spiked stuff
----

Now we re-run the FT and let it drive our development:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.LoginTest*]
selenium.common.exceptions.NoSuchElementException: Message: 'Unable to locate
element: {"method":"id","selector":"login"}' ; Stacktrace: 
[...]
----

The first thing it wants us to do is add a login link. Incidentally, I prefer
prefixing HTML ids with `id_`, so let's tweak the FT first:

[role="sourcecode"]
.lists/functional_tests/tests/test_login.py
[source,python]
----
    self.browser.find_element_by_id('id_login').click()
    [...]
    self.wait_for_element_with_id('id_logout')
----


OK -- so let's add a do-nothing log in link:

[role="sourcecode"]
.lists/templates/base.html
[source,html]
----
<div class="container">
    <nav class="navbar navbar-default" role="navigation">
        <a class="navbar-brand" href="/">Superlists</a>
        <a class="btn navbar-btn navbar-right" id="id_login" href="#">Sign in</a>
    </nav>
    <div class="row">
    [...]
----

TODO: I have silently upgraded to bootstrap 3.  Grandfather this into ch. 7


After 10 seconds, that gives:

----
AssertionError: could not find window
----

License to move on!  Next thing: more javascript!


Javascript unit tests involving external components.  Our first Mock!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

First off, a bit of housekeeping.  We create a site-wide static files 
directory inside 'superlists/superlists', and we move all the 
bootsrap css, qunit code, and base.css into it

----
superlists
├── __init__.py
├── settings.py
├── static
│   ├── base.css
│   ├── bootstrap
│   │   ├── css
│   │   │   └[...]
│   │   ├── fonts
│   │   │   └[...]
│   │   └── js
│   │       └[...]
│   └── tests
│       ├── qunit.css
│       └── qunit.js
├── urls.py
└── wsgi.py
----

TODO: move templates/base.html in there too?

Here's how we tell our settings file about the new static folder:

[role="sourcecode"]
.superlists/settings.py
[source,python]
----
# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
    path.join(PROJECT_ROOT, 'superlists', 'static'),
)
----

Next, create an app called `accounts` to hold all the code related to
login.  That will include our Persona javascript stuff:

----
$ python3 manage.py startapp accounts
$ mkdir -p accounts/static/tests
----

And now let's take another look at our spiked-in javascript:

----
var loginLink = document.getElementById('login');
if (loginLink) {
  loginLink.onclick = function() { navigator.id.request(); };
}
----

Why Mock?
^^^^^^^^^

We want our login link's on-click to be bound to a function provided by
the Persona library, `navigator.id.request`.

Now we don't want to call the 'actual' 3rd party function in our unit tests,
because we don't need our unit tests popping up persona windows all over the
shop.  So instead, we are going to do what's called "mocking it out".  I had
hoped that our first Mock example was going to be in Python, but it looks like
it's going to be JavaScript instead.  Ah well, needs must.  Thankfully, it's
quite a straightforward one.  Still, you may find you need to read this next
section a few times before it all makes total sense.

WARNING: It took me weeks to get my head around mocking when I first
encountered it.  I'm worried that this chapter has a much steeper learning
curve than any other so far.  Please, let me know how you feel about this!
//TODO: remove me

What we're going to do is replace the real `navigator` object with a 'fake'
one that we've built ourselves, one that will be able to tell us what happens
to it.

Namespacing
^^^^^^^^^^^

In the context of 'base.html', `navigator` is just an object in the global
scope, as provided by the 'include.js' `<script>` tag that we get from 
Mozilla.  Testing global variables is a pain though, so we can turn it 
into a local variable by passing it into an "initialize" function. The
code we'll end up with in 'base.html' will look like this:


[source,html]
.lists/templates/base.html
----
<script src="https://login.persona.org/include.js"></script>
<script src="/static/accounts/accounts.js"></script>
<script>
        $(document).ready(function() {

Superlists.Accounts.initialize(navigator)

});
</script>
----

I've specified that our `initialize` function will be 'namespaced' inside
some nested objects, `Superlists.Accounts`.  JavaScript suffers from a
programming model that's tied into a global scope, and this sort of namespacing
/ naming convention helps to keep things under control.  Lots of JavaScript 
libraries might want to call a function `initialize`, but very few will call
it `Superlists.Accounts.initialize`!

TODO: look into require.js as an alternative to namespacing?

This code is short enough that I'm happy it doesn't need any unit tests.



A simple mock to unit tests our initialize function
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The initialize function itself, we will test though:

[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
    <script src="http://code.jquery.com/jquery.min.js"></script>
    <script src="../../../superlists/static/tests/qunit.js"></script>
    <script src="../accounts.js"></script>
    <script>

test("initialize binds sign in button to navigator.id.request", function () {
    var requestWasCalled = false; //<6>
    var mockRequestFunction = function() { requestWasCalled = true; }; //<5>
    var mockNavigator = { //<4>
        id: {
            request: mockRequestFunction
        }
    };

    Superlists.Accounts.initialize(mockNavigator) //<3>

    $('#id_login').trigger('click'); //<2>

    equal(requestWasCalled, true); //<1>
});

    </script>
----

One of the best ways to understand this test, or indeed any test, is to work 
backwards.  The first thing we see is the assertion:

<1> We are asserting that a variable called `requestWasCalled` is true. We're
checking that, one way or another, the `request` function, as in `navigator.id.request`, was called
<2> Called when?  When a click event happens to the `id_login` element
<3> Before we trigger that click event, we call our 
`Superlists.Accounts.Initialize` function, just like we will on the real page.
The only difference is, instead of passing it the real global `navigator`
object from Persona, we pass in a fake one called `mockNavigator`
<4> That's defined as a generic JavaScript object, with an attribute called
`id` which in turn has an attribute called `request`, which we're assigning
to a variable called `mockRequestFunction`
<5> `mockRequestFunction` we define as a very simple function which, if called
will simply set the value of the `requestWasCalled` variable to `true`.
<6> And finally (firstly?) we make sure that `requestWasCalled` starts out
as `false`.

The upshot of all this is:  the only way this test will pass is if our
`initialize` function binds the `click` event on `id_login` to the method
`.id.request` of the object we pass it.

Does that make sense?  Let's play around with the test and see if we can 
get the hang of it.

Our first error is this:

----
Died on test #1
@file:///workspace/superlists/accounts/static/tests/tests.html:20 : Superlists
is not defined
----

That's the equivalent of an `ImportError` in Python.  Let's got start work
on 'accounts/static/accounts.js':


[role="sourcecode"]
.accounts/static/accounts.js
[source,javascript]
----
$(document).ready(function() {

    window.Superlists = null;

});
----

We start with the usual on-document-ready boilerplate, and then address our
immediate problem: Superlists is not defined.  Now, just as in Python we
might do `Superlists = None`, we do `window.Superlists = null`.  Using
`window.` makes sure we get the global object.

TODO: $.extend

----
Died on test #1
@file:///workspace/superlists/accounts/static/tests/tests.html:20 : Superlists
is null
----

OK, next baby step or two:

[role="sourcecode"]
.accounts/static/accounts.js
[source,javascript]
----
    window.Superlists = {
        Accounts: {}
    };
----

Gives

----
: Superlists.Accounts.initialize is not a function
----

So let's make it a function:

[role="sourcecode"]
.accounts/static/accounts.js
[source,javascript]
----
    window.Superlists = {
        Accounts: {
            initialize: function () {}
        }
    };
----

And now we get a real test failure instead of just errors

----
initialize binds sign in button to navigator.id.request (1, 0, 1)

    failed
    Expected: 	true
    Result: 	false

    Diff: 	true false 
----

Next -- let's separate defining our initialize function from the part where we
export it into the Superlists namespace.  We'll also do a `console.log`, which
is the JavaScript equivalent of a debug-print, to take a look at what the
initialize function is being called with:


[role="sourcecode"]
.accounts/static/accounts.js
[source,javascript]
----
    var initialize = function (navigator){
        console.log(navigator);
    };

    window.Superlists = {
        Accounts: {
            initialize: initialize
        }
    };
----

.Debugging in the JavaScript console
image::images/console_dot_log.png["The JavaScript console in our qunit run, showing the console.log"]

In Firefox and I believe Chrome also, you can use the shortcut `Ctrl-Shift-I` 
to bring up the JavaScript console, and see the [object Object] that was
logged.  If you click on it, you can see it has the properties we defined in
our test: an `id`, and inside that, a function called `request`.

So let's now just pile in and get the test to pass:


[role="sourcecode"]
.accounts/static/accounts.js
[source,javascript]
----
    var initialize = function (navigator){
        navigator.id.request();
    };
----

That gets the tests to pass, but it's not quite the implementation we
want.  We're calling `navigator.id.request` always, instead of only
on click.  We'll need to adjust our tests.

----
Tests completed in 51 milliseconds.
1 assertions of 1 passed, 0 failed.

    initialize binds sign in button to navigator.id.request (0, 1, 1)
----

Before we do, let's just have a play around to see if we really understand
what's going on.  What happens if we do this:


[role="sourcecode"]
.accounts/static/accounts.js
[source,javascript]
----
    var initialize = function (navigator){
        navigator.id.request();
        navigator.id.doSomethingElse();
    };
----

We get:

----
Died on test #1
@file:///workspace/superlists/accounts/static/tests/tests.html:20 :
navigator.id.doSomethingElse is not a function
----

You see, the mock navigator object that we pass in is entirely under our
control. It has only the attributes and methods we give it.  You can
play around with it now if you like:


[role="sourcecode"]
.accounts/static/tests/tests.html
[source,html]
----
    var mockNavigator = {
        id: {
            request: mockRequestFunction,
            doSomethingElse: function () { console.log("called me!");}
        }
    };
----

That will give you a pass, and if you open up the debug window, you'll see:

----
[01:22:27.456] "called me!"
----

Does that help to see what's going on?  Let's revert those last two changes,
and tweak our unit test so that it checks the `request` function is only
called 'after' we fire off the click event.  We also add some error messages
to help see which of the two `equal` assertions is failing:


[role="sourcecode"]
.accounts/static/tests/tests.html
[source,html]
----
    var mockNavigator = {
        id: {
            request: mockRequestFunction
        }
    };

    Superlists.Accounts.initialize(mockNavigator)
    equal(requestWasCalled, false, 'check request not called before click'); 

    $('#id_login').trigger('click');
    equal(requestWasCalled, true, 'check request called after click'); 
----

NOTE: assertion messages (the third argument to `equal`), in Qunit, are
actually "success" messages. Rather than only being displayed if the test
fails, they are also displayed when the test passes.  That's why they have
the positive phrasing.

Now we get a neater failure:

----
    initialize binds sign in button to navigator.id.request (1, 1, 2)
        check request called before click
        Expected: 	false
        Result: 	true
----

So let's make it so that the call to `navigator.id.request` only happens
if our `id_login` is clicked:

[role="sourcecode"]
.accounts/static/accounts.js
[source,javascript]
----
    var initialize = function (navigator){
        $('#id_login').on('click', function () {
            navigator.id.request();
        });
    };
----

That passes. A good start!  Let's try pulling it into our template:

[source,html]
.lists/templates/base.html
----
    <script src="http://code.jquery.com/jquery.js"></script>
    <script src="https://login.persona.org/include.js"></script>
    <script src="/static/list.js"></script>
    <script src="/static/accounts.js"></script>
    <script>
        $(document).ready( function () {
            Superlists.Accounts.initialize(navigator);
        });
    </script>
----

We also need to add the `accounts` app to 'settings.py', otherwise
it won't be serving the static file at 'accounts/static/accounts.js':

----
+++ b/superlists/settings.py
@@ -130,6 +130,7 @@ INSTALLED_APPS = (
     'lists',
     'functional_tests',
     'south',
+    'accounts',
 )
----

A quick check on the FT ... Doesn't get any further unfortunately.  To see
why, we can open up the site manually, and check the JavaScript debug console:

----
[01:36:54.572] Error: navigator.id.watch must be called before
navigator.id.request @ https://login.persona.org/include.js:8
----


Checking a call to a 3rd party API with a more complex mock
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We now need to call Mozilla's `navigator.id.watch` correctly. Taking another
look at our spike, it should be something like this:


[source,javascript]
----
var currentUser = '{{ user.email }}' || null;
var csrf_token = '{{ csrf_token }}';
console.log(currentUser);

navigator.id.watch({
  loggedInUser: currentUser, //<1>
  onlogin: function(assertion) {
    $.post('/accounts/login', {assertion: assertion, csrfmiddlewaretoken: csrf_token}) //<2>
    .done(function() { window.location.reload(); })
    .fail(function() { navigator.id.logout();});
  },
  onlogout: function() {
    $.post('/accounts/logout')
    .always(function() { window.location.reload(); });
  }
});
----

Decoding that, the watch function needs to know a couple of things from 
the global scope:  

<1> the current user's email, to be passed in as the `loggedInUser` parameter
to watch

<2> the current CSRF token, to pass in the Ajax POST request to the login
view

We've also got two hard-coded URLs in there, which it would be better to
get from Django, something like this:

----
var urls = {
    login: "{% url 'login' %}",
    logout: "{% url 'logout' %}",
};
----

So that would be a third parameter to pass in from the global scope.  We've
already got an initialize function, so let's imagine using it like this:

-----
Superlists.Accounts.initialize(navigator, user, token, urls);
-----


A mock that makes assertions
++++++++++++++++++++++++++++

How to write some unit test for this?  More mocking!

----
test("initialize calls navigator.id.watch", function () {
    var user = 'current user';
    var token = 'csrf token';
    var urls = { login: 'login url', logout: 'logout url'};

    var watchFunctionCalled = false;
    var mockWatchFunction = function (params) {
        equal(params.loggedInUser, user, 'check user'); //<3>
        equal(params.onlogin, Superlists.Accounts.submitAssertion, 'check login fn'); //<4>
        equal(params.onlogout, Superlists.Accounts.logOut, 'check logout fn'); //<4>
        watchFunctionCalled = true;
    };
    var mockNavigator = { id: { watch: mockWatchFunction } }; //<2>

    Superlists.Accounts.initialize(mockNavigator, user, token, urls); //<1>

    equal(watchFunctionCalled, true, 'check watch function called');

});
----

This is a slightly more advanced mocking technique.  In the previous test, our
mock function's job was just set a flag if it was called, and it was the job of
a later assertion in the test to check that flag.  In this test, the mock
function actually makes several assertions if it gets called, and can cause the
test to fail on its own. Let's work through it step by step:

<1> We call initialize with a mock navigator object, as before, and two extra
parameters which are straightforward constants.

<2> The mock navigator object provides a mock watch function.  It takes a
single argument, "params" (short for parameters).  JavaScript doesn't have
keyword arguments for functions, so passing in an object with various
attributes as parameters is a common pattern.

<3> This time, in the mock function, we don't just set a flag saying it was
called, we also make several assertions:  we check that it was called with the
correct parameters, with the right user, and ...

<4> ... with the correct onlogin and onlogout functions.  You can see we're
comparing them to some objects we expect to be on the `Superlists.Accounts` 
namespace.  In Python, we would import the objects from the source file into
our tests, and use them for these assertions -- like we do when we import a
constant, to check that a function under test uses the correct constant.

That gives

----
2 assertions of 3 passed, 1 failed.
initialize binds sign in button to navigator.id.request (0, 2, 2)
initialize calls navigator.id.watch (1, 0, 1)
    check watch function called
    Expected: 	true
    Result: 	false
    Diff: 	true false 
    Source:
    @file:///workspace/superlists/accounts/static/tests/tests.html:54
----

And we're off. Minimal change:

[role="sourcecode"]
.accounts/static/accounts.js
[source,javascript]
----
    var initialize = function (navigator){
        $('#id_login').on('click', function () {
            navigator.id.request();
        });

        navigator.id.watch();
    };
----

Breaks everything!

----
0 assertions of 2 passed, 2 failed.

initialize binds sign in button to navigator.id.request (1, 0, 1)
    Died on test #1
    @file:///workspace/superlists/accounts/static/tests/tests.html:20 :
    missing argument 1 when calling function navigator.id.watch

initialize calls navigator.id.watch (1, 0, 1)
    Died on test #1
    @file:///workspace/superlists/accounts/static/tests/tests.html:36 :
    params is undefined
----

The fact that our first test fails as well was a puzzler. That "missing
argument 1 when calling function navigator.id.watch" took me a while to figure
out.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/watch[Turns
out that], in Firefox, `.watch` is a function on every object.  We'll need
to mock it out in there too:


[role="sourcecode"]
.accounts/static/tests/tests.html
[source,html]
----
test("initialize binds sign in button to navigator.id.request", function () {
    var requestWasCalled = false;
    var mockRequestFunction = function() { requestWasCalled = true; };
    var mockNavigator = {
        id: {
            request: mockRequestFunction,
            watch: function () {}
        }
    };
----

That gets us back to just the expected failure:

----
2 assertions of 3 passed, 1 failed.
initialize binds sign in button to navigator.id.request (0, 2, 2)
initialize calls navigator.id.watch (1, 0, 1)
    Died on test #1
    @file:///workspace/superlists/accounts/static/tests/tests.html:37 :
    params is undefined
----

Now we can get some more specific error messages by:

----
    navigator.id.watch({});
----

Which gives:

----
initialize calls navigator.id.watch
    check user
    Expected: 	"current user"
    Result: 	undefined
----

Our mock function is telling us that we're not calling it correctly, it wants
us to pass in the user inside the params object.  Let's do that:


[role="sourcecode"]
.accounts/static/accounts.js
[source,javascript]
----
    var initialize = function (navigator, user, token, urls){
        $('#id_login').on('click', function () {
            navigator.id.request();
        });

        navigator.id.watch({
            loggedInUser: user
        });
    };
----

Notice I've had to adjust the `initialize` function's arguments, so that it
now expects the logged-in user and urls.

undefined equals undefined
++++++++++++++++++++++++++

Slightly unexpectedly, that gets all the tests passing!

----
Tests completed in 52 milliseconds.
6 assertions of 6 passed, 0 failed.
    initialize binds sign in button to navigator.id.request (0, 2, 2)
    initialize calls navigator.id.watch (0, 4, 4)
----

How about our assertions on the `onlogin` and `onlogout` functions?  Shouldn't
they be failing?  Actually, this is just one of those brain-melting JavaScript
things:  in Javascript, if you try and access an attribute on an object that's
not been explicitly defined, you get the `undefined`.  `params.onlogin` hasn't
been set, so it is `undefined`... but `Superlists.Accounts.submitAssertion`
doesn't exist either, so it is also `undefined`.  And `undefined ==
undefined`. Thankfully. Nothing is certain in JavaScript, as TDD supremo Gary
Bernhardt once hilariously demonstrated in a talk called
https://www.destroyallsoftware.com/talks/wat[WAT]).

Let's add them to our namespace then:

[role="sourcecode"]
.accounts/static/accounts.js
[source,javascript]
----
    var submitAssertion = function () {};
    var logOut = function () {};

    window.Superlists = {
        Accounts: {
            initialize: initialize,
            submitAssertion: submitAssertion,
            logOut: logOut
        }
    };
----

We now get:

----
check login fn
----

So let's fix them both:

[role="sourcecode"]
.accounts/static/accounts.js
[source,javascript]
----
    navigator.id.watch({
        loggedInUser: user,
        onlogin: submitAssertion,
        onlogout: logOut
    });
----

And that gets us passing.  How about the FT?  It does actually get a fair
bit further!

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests.LoginTest*]
Creating test database for alias 'default'...
E
======================================================================
ERROR: test_login_with_persona (functional_tests.tests.test_login.LoginTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File
  "/home/harry/Dropbox/book/source/chapter_14/superlists/functional_tests/tests/test_login.py",
  line 56, in test_login_with_persona
    self.wait_for_element_with_id('id_logout')
  File
  "/home/harry/Dropbox/book/source/chapter_14/superlists/functional_tests/tests/test_login.py",
  line 25, in wait_for_element_with_id
    lambda b: b.find_element_by_id(element_id)
  File
  "/usr/local/lib/python3.3/dist-packages/selenium/webdriver/support/wait.py",
  line 71, in until
    raise TimeoutException(message)
selenium.common.exceptions.TimeoutException: Message: '' 
----

The FT gets through all of the username + password submission steps, but when
it gets back to our website, it can't find a "logout" element -- in other
words, our site doesn't recognise that the user is logged in.  To do that, we
have to send our authentication information to the server, and have the server
validated it.  And to do that, we'll need at least the `submitAssertion`
function.


Just another tiny bit of JavaScript and we're there!
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Here's what our spiked login function looked like:

----
  onlogin: function(assertion) {
    $.post('/accounts/login', {assertion: assertion, csrfmiddlewaretoken: csrf_token})
    .done(function() { window.location.reload(); })
    .fail(function() { navigator.id.logout();});
  },
----

We need to do an Ajax post to our login url, passing in an assertion and
our csrf token.  We also want to refresh the window if it succeeds, and call
logout if it fails, but we can test those two things later.

Unit testing Ajax requests can be a bit of a pain, but there's a popular
mocking libary called 'sinon.js' that makes it a lot easier.  We should
download it (from http://sinonjs.org) and put it in our site-wide static tests
folder:


----
$ tree superlists/static/tests/
superlists/static/tests/
├── qunit.css
├── qunit.js
└── sinon.js
----

Next we include it in our accounts tests:

[role="sourcecode"]
.accounts/static/tests/tests.html
[source,html]
----
    <script src="../../../superlists/static/jquery.js"></script>
    <script src="../../../superlists/static/tests/qunit.js"></script>
    <script src="../../../superlists/static/tests/sinon.js"></script>
    <script src="../accounts.js"></script>
----

And now we can write a test that uses sinon's
http://sinonjs.org/docs/#server[fake XMLHttpRequest].
This patches out the native JavaScript XMLHttpRequest class, so it's good
practice to make sure we restore it afterwards.  This gives us a good
excuse to learn about Qunit's `setUp` and `tearDown` methods -- they
are used in a function called `module`, which acts a bit like a 
`unittest.TestCase` class, and groups all the tests that follow it
together:

[role="sourcecode"]
.accounts/static/tests/tests.html
[source,html]
----
var xhr;
var requests = [];

module("ajax tests", {
    setUp: function () {
        requests = [];
        xhr = sinon.useFakeXMLHttpRequest();
        xhr.onCreate = function (request) { requests.push[request]; };
    },
    tearDown: function() {
        xhr.restore() 
    }
});

test("submitAssertion does ajax post", function () {
)};
----

This is standard boilerplate for sinon, here's what's happening:

We declare the variables `xhr` and `requests` in the global scope, so they're
available to all our tests.  Then, in `setUp`, we activate sinon's fake
XMLHttpRequest, and we also set its special `onCreate` function, which logs any
requests it sees into the `requests` array.  `xhr.restore` puts everything
back the way it was.

That allows us to write a test for our Ajax submission function that 
looks like this: 


[role="sourcecode"]
.accounts/static/tests/tests.html
[source,html]
----
test("submitAssertion does ajax post", function () {
    var user = 'user';
    var token = 'csrf token';
    var urls = {'login': 'login url'};
    var assertion = 'an assertion';
    var mockNavigator = {id: { watch: function () {}}};

    Superlists.Accounts.initialize(mockNavigator, user, token, urls); //<1>
    Superlists.Accounts.submitAssertion(assertion); //<2>

    equal(requests.length, 1, 'check request made') //<3>
    var request = requests[0]; 
    equal(request.method, 'POST', 'check request was a POST'); //<3>
    equal(request.url, urls.login, 'check url'); //<3>
    equal(
        request.requestBody,
        $.param({ assertion: assertion, csrfmiddlewaretoken: token }), //<4>
        'check POST data'
    );
});
----

The first block just sets up some test variables, including a mock navigator
object. Then:

<1> We call the initialize function to pass in the various bits of global state

<2> We call the function under test, submitAssertion

<3> We check that an Ajax request was made using POST to the correct URL

<4> And we check what data was sent as part of the request.  The `$.param` 
function decodes it from url-encoded format for us.

Let's see how we get on!

----
ajax tests: submitAssertion does ajax post (2, 0, 2)Rerun0 ms
    check request made
    Expected: 	1
    Result: 	0
----

So:


[role="sourcecode"]
.accounts/static/accounts.js
[source,javascript]
----
    var submitAssertion = function () {
        $.post();
    };
----

And then:

----
check url
Expected: 	"login url"
Result: 	"file:///workspace/superlists/accounts/static/tests/tests.html"
----

How about?

[role="sourcecode"]
.accounts/static/accounts.js
[source,javascript]
----
    $.post(urls.login);
----

Nope:

----
Died on test #1
@file:///workspace/superlists/accounts/static/tests/tests.html:72 : urls is
not defined
----

The urls that we pass in are only available inside the scope of the 
`initialize` function.  To pop them out of it, we do this:

[role="sourcecode"]
.accounts/static/accounts.js
[source,javascript]
----
    var urls;

    var initialize = function (navigator, user, token, urls_){
        urls = urls_;
        [...]
----

TODO: do we like that `urls_`?  Or should we rename one to, eg,
`siteUrls`?  


That gets us onto:

----
check POST data
Expected: 	"assertion=an+assertion&csrfmiddlewaretoken=csrf+token"
Result: 	null
----

A final step, with another yanking up of a variable to the top scope:

[role="sourcecode"]
.accounts/static/accounts.js
[source,javascript]
----
    var urls;
    var csrfToken;

    var initialize = function (navigator, user, token, urls_){
        urls = urls_;
        csrfToken = token;
        [...]


    var submitAssertion = function (assertion) {
        $.post(urls.login, { assertion: assertion, csrfmiddlewaretoken: csrfToken });
    };
----
